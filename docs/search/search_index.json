{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 Pyneal GitHub repository What is it? \u00b6 Pyneal is an open source software package to support real-time functional magnetic resonance imaging (fMRI). It is entirely Python-based and depends exclusively on free, open source neuroimaging libraries. It allows users to: access functional MRI data in real-time compute on-going analyses throughout a scan monitor data quality share analysis results with remote devices (e.g. send results to an experimental task presenting neurofeedback to participants) It currently supports data formats used across 3 major MRI manufacturers: GE , Siemens , Philips . In addition to allowing users to compute basic, ROI-based analyses during a scan, Pyneal also provides a simple framework for designing and writing customized analyses that can be computed across the whole brain volume at each timepoint. Design/Structure \u00b6 The software is broken into two main components: Pyneal Scanner and Pyneal . Once downloaded, you'll find the directory structure shown below. Note that Pyneal Scanner is contained within it's own directory in the main Pyneal directory. Pyneal directory structure: \u251c\u2500\u2500 pyneal \u2502 \u251c\u2500\u2500 LICENSE.txt \u2502 \u251c\u2500\u2500 README.md \u2502 \u251c\u2500\u2500 pyneal.py \u2502 \u251c\u2500\u2500 pyneal_scanner/ \u2502 \u251c\u2500\u2500 requirements.txt \u2502 \u251c\u2500\u2500 src/ \u2502 \u2514\u2500\u2500 utils/ Pyneal Scanner : Accesses incoming data, modifies it to match a standardized format, and then sends the data out, one 3D volume at a time, to Pyneal . Pyneal : Listens for incoming 3D volumes from Pyneal Scanner , runs whatever analyses you have specified, and hosts the results on a server, which other downstream components (e.g. an experimental task) can make requests to. This design allows the software to easily accommodate the various directory structures and data formats that are found on different scanner models at different institutions around the world. (However, it also means that the steps to install, and setup Pyneal can vary from environment to environment): For instructions on installing and setting up your environment, see: Installation guide Setup guide For instructions on simulating a scanner environment to test/debug, see : Simulations guide For step-by-step tutorials on testing/using Pyneal, see : Pyneal Tutorials Terms/Definitions \u00b6 Throughout the documentation specific terms are used to describe the different components of the software, the underlying architecture, and the various processes involved. Despite sincere efforts to keep these terms intuitive, they're probably not in all cases. Please check the glossary for any unfamiliar terms you come across. (You can also find it under Reference in the lefthand menu)","title":"Introduction"},{"location":"#introduction","text":"Pyneal GitHub repository","title":"Introduction"},{"location":"#what-is-it","text":"Pyneal is an open source software package to support real-time functional magnetic resonance imaging (fMRI). It is entirely Python-based and depends exclusively on free, open source neuroimaging libraries. It allows users to: access functional MRI data in real-time compute on-going analyses throughout a scan monitor data quality share analysis results with remote devices (e.g. send results to an experimental task presenting neurofeedback to participants) It currently supports data formats used across 3 major MRI manufacturers: GE , Siemens , Philips . In addition to allowing users to compute basic, ROI-based analyses during a scan, Pyneal also provides a simple framework for designing and writing customized analyses that can be computed across the whole brain volume at each timepoint.","title":"What is it?"},{"location":"#designstructure","text":"The software is broken into two main components: Pyneal Scanner and Pyneal . Once downloaded, you'll find the directory structure shown below. Note that Pyneal Scanner is contained within it's own directory in the main Pyneal directory. Pyneal directory structure: \u251c\u2500\u2500 pyneal \u2502 \u251c\u2500\u2500 LICENSE.txt \u2502 \u251c\u2500\u2500 README.md \u2502 \u251c\u2500\u2500 pyneal.py \u2502 \u251c\u2500\u2500 pyneal_scanner/ \u2502 \u251c\u2500\u2500 requirements.txt \u2502 \u251c\u2500\u2500 src/ \u2502 \u2514\u2500\u2500 utils/ Pyneal Scanner : Accesses incoming data, modifies it to match a standardized format, and then sends the data out, one 3D volume at a time, to Pyneal . Pyneal : Listens for incoming 3D volumes from Pyneal Scanner , runs whatever analyses you have specified, and hosts the results on a server, which other downstream components (e.g. an experimental task) can make requests to. This design allows the software to easily accommodate the various directory structures and data formats that are found on different scanner models at different institutions around the world. (However, it also means that the steps to install, and setup Pyneal can vary from environment to environment): For instructions on installing and setting up your environment, see: Installation guide Setup guide For instructions on simulating a scanner environment to test/debug, see : Simulations guide For step-by-step tutorials on testing/using Pyneal, see : Pyneal Tutorials","title":"Design/Structure"},{"location":"#termsdefinitions","text":"Throughout the documentation specific terms are used to describe the different components of the software, the underlying architecture, and the various processes involved. Despite sincere efforts to keep these terms intuitive, they're probably not in all cases. Please check the glossary for any unfamiliar terms you come across. (You can also find it under Reference in the lefthand menu)","title":"Terms/Definitions"},{"location":"createMask/","text":"Creating Masks \u00b6 Pyneal requires that you input a mask for use during real-time analysis. This mask must have the same voxel dimensions and image orientation as the incoming functional data. Depending on your real-time analysis needs, one option could be to create a functional ROI by collecting a localizer task run and quickly analyzing it during your scanning session. Alternatively, you may wish to focus your analysis on predefined anatomical ROIs. In this case, you need to transform an anatomical mask from a standard space (like MNI) to match the functional data of your participant in the scanner. The createMask.py tool will assist you in quickly creating whole-brain or anatomical masks during a real-time session. createMask provides you with two mask creation options: Whole Brain Mask : This option will create a whole brain mask from the functional data you supply. Transform mask from MNI space : This option will take a mask defined in MNI space and transform it to the dimensions and orientation of the functional data you supply. Note: Behind the scenes, createMask.py relies on various functions from FSL. Make sure you have installed FSL 5.0 Launching createMask \u00b6 The createMask tool is found in pyneal/utils/createMask.py You can launch the createMask GUI by navigating to the utils directory via the terminal and running createMask.py with Python cd utils python createMask.py Specifying a reference 4D functional file \u00b6 In order to create masks, we need to know the voxel size, 3D volume dimensions, and image orientation of the functional data for the current session. The easiest way to get this data is to include a brief (30sec or less) functional scan near the beginning of your session. Use the exact same slice prescriptions and image settings as you plan to use during your real-time scans. After the scan has finished, use the getSeries.py tool from Pyneal Scanner to convert the images to a 4D nifti file. Note that getSeries.py will automatically reorient the output data to RAS+ orientation. Thus, by using this data as our reference functional data we will create a mask that is also in RAS+. This is good since, during a real-time run, Pyneal will be receiving data in RAS+ orientation (see image orientation for more info) createMask.py will create an example 3D functional image for reference by taking the mean across time of the specified 4D functional. Deciding on a mask type \u00b6 Whole Brain Mask \u00b6 If you check Create whole-brain FUNC mask , a 3D whole-brain mask will be created using the 4D FUNC file as a reference. Every brain voxel will be labeled 1 and every non-brain voxel will be labeled 0 . The output file will be found in mask_transforms/FUNC_masks/wholeBrain_FUNC_mask.nii.gz A whole-brain mask is useful in situations where you are using a custom analysis during real-time runs and want access to the entire 3D brain volume (e.g. calculating grand volume mean as a reference value for other steps in your analysis). Transform MNI space mask \u00b6 More commonly, your real-time analysis may focus on activation in one or more predefined regions of interest (ROIs). Before beginning your real-time run, you need to create a mask(s) of your desired ROI(s) that match the resolution and orientation of the participant's functional data. createMask.py offers a way to quickly transform a mask from MNI space to the required functional space. To do so, the following intermediate steps take place: a transformation matrix is created mapping from MNI space to the participant's high-res anatomical image ( mni2hires.mat ) a transformation matrix is created mapping from the participant's high-resolution anatomical image to the participant's functional data ( hires2func.mat ) a 3rd tranformation matrix is created by concatenating the previous two matrices in order to create a transformation mapping from MNI space to functional space ( mni2func.mat ) The resulting mni2func.mat matrix is used to transform the specifed MNI-space mask to functional space. Specify the following input to createMask.py when selecting Transform MNI mask to FUNC : hi-res ANAT : path to participant's high-resolution anatomical image, collected during the current scanning session if the anatomical image has not been skull stripped yet, check Skull Strip? . If you have already manually skull stripped the anatomical image, make sure this box is deselected. MNI-standard : path to the MNI standard. This standard must be in the same space as the mask you wish to transform. For instance, if your mask is in MNI space with a resolution of 1mm, you must select the MNI152_T1_1mm standard image. Sample MNI standard images can be found in pyneal/utils/MNI_templates MNI mask : The mask file you wish to transform Output Prefix: : The output prefix that will be prepended to the transformed masks. Once you hit Submit , createMask.py will go about creating the necessary intermediate tranforms. Once complete, the new masks will open automatically in FSLeyes so that you may confirm that everything completed correctly. The new masks (and intermedate files) will be saved to the output directory. Output files \u00b6 The output from createMask.py will be saved to the same directory as the specified reference 4D file. Within that directory, you will find a new directory named mask_transforms that holds all of the output mask files and transformation matrices from createMask.py Depending on the type of mask you are creating, you will find some set of the following files: FUNC_masks/wholeBrain_FUNC_mask.nii.gz : whole brain mask in participant functional space FUNC_masks/<outputPrefix>_FUNC_mask.nii.gz : binarized version of the transformed MNI mask in participant functional space FUNC_masks/<outputPrefix>_FUNC_weighted.nii.gz : non-binarized version of the transformed MNI mask in participant functional space. If the MNI mask you used represents a probabilistic atlas, for instance, those voxel probabilities will be preserved in this file. exampleFunc.nii.gz : a 3D functional image created by averaging the input 4D FUNC file hires_brain.nii.gz : skull-stripped version of the input hi-res ANAT file hires_FUNC.nii.gz : hi-res anatomical image transformed to participant functional space mni_HIRES.nii.gz : MNI standard transformed to participant hi-res anatomical space hires2func.mat : transformation matrix mapping from hi-res anatomical space to participant functional space mni2hires.mat : transformation matrix mapping from MNI space to hi-res anatomical space mni2func.mat : transformation matrix mapping from MNI space to participant functional space maskTransforms.log : log file detailing all of the steps that were carried out","title":"Creating Masks"},{"location":"createMask/#creating-masks","text":"Pyneal requires that you input a mask for use during real-time analysis. This mask must have the same voxel dimensions and image orientation as the incoming functional data. Depending on your real-time analysis needs, one option could be to create a functional ROI by collecting a localizer task run and quickly analyzing it during your scanning session. Alternatively, you may wish to focus your analysis on predefined anatomical ROIs. In this case, you need to transform an anatomical mask from a standard space (like MNI) to match the functional data of your participant in the scanner. The createMask.py tool will assist you in quickly creating whole-brain or anatomical masks during a real-time session. createMask provides you with two mask creation options: Whole Brain Mask : This option will create a whole brain mask from the functional data you supply. Transform mask from MNI space : This option will take a mask defined in MNI space and transform it to the dimensions and orientation of the functional data you supply. Note: Behind the scenes, createMask.py relies on various functions from FSL. Make sure you have installed FSL 5.0","title":"Creating Masks"},{"location":"createMask/#launching-createmask","text":"The createMask tool is found in pyneal/utils/createMask.py You can launch the createMask GUI by navigating to the utils directory via the terminal and running createMask.py with Python cd utils python createMask.py","title":"Launching createMask"},{"location":"createMask/#specifying-a-reference-4d-functional-file","text":"In order to create masks, we need to know the voxel size, 3D volume dimensions, and image orientation of the functional data for the current session. The easiest way to get this data is to include a brief (30sec or less) functional scan near the beginning of your session. Use the exact same slice prescriptions and image settings as you plan to use during your real-time scans. After the scan has finished, use the getSeries.py tool from Pyneal Scanner to convert the images to a 4D nifti file. Note that getSeries.py will automatically reorient the output data to RAS+ orientation. Thus, by using this data as our reference functional data we will create a mask that is also in RAS+. This is good since, during a real-time run, Pyneal will be receiving data in RAS+ orientation (see image orientation for more info) createMask.py will create an example 3D functional image for reference by taking the mean across time of the specified 4D functional.","title":"Specifying a reference 4D functional file"},{"location":"createMask/#deciding-on-a-mask-type","text":"","title":"Deciding on a mask type"},{"location":"createMask/#whole-brain-mask","text":"If you check Create whole-brain FUNC mask , a 3D whole-brain mask will be created using the 4D FUNC file as a reference. Every brain voxel will be labeled 1 and every non-brain voxel will be labeled 0 . The output file will be found in mask_transforms/FUNC_masks/wholeBrain_FUNC_mask.nii.gz A whole-brain mask is useful in situations where you are using a custom analysis during real-time runs and want access to the entire 3D brain volume (e.g. calculating grand volume mean as a reference value for other steps in your analysis).","title":"Whole Brain Mask"},{"location":"createMask/#transform-mni-space-mask","text":"More commonly, your real-time analysis may focus on activation in one or more predefined regions of interest (ROIs). Before beginning your real-time run, you need to create a mask(s) of your desired ROI(s) that match the resolution and orientation of the participant's functional data. createMask.py offers a way to quickly transform a mask from MNI space to the required functional space. To do so, the following intermediate steps take place: a transformation matrix is created mapping from MNI space to the participant's high-res anatomical image ( mni2hires.mat ) a transformation matrix is created mapping from the participant's high-resolution anatomical image to the participant's functional data ( hires2func.mat ) a 3rd tranformation matrix is created by concatenating the previous two matrices in order to create a transformation mapping from MNI space to functional space ( mni2func.mat ) The resulting mni2func.mat matrix is used to transform the specifed MNI-space mask to functional space. Specify the following input to createMask.py when selecting Transform MNI mask to FUNC : hi-res ANAT : path to participant's high-resolution anatomical image, collected during the current scanning session if the anatomical image has not been skull stripped yet, check Skull Strip? . If you have already manually skull stripped the anatomical image, make sure this box is deselected. MNI-standard : path to the MNI standard. This standard must be in the same space as the mask you wish to transform. For instance, if your mask is in MNI space with a resolution of 1mm, you must select the MNI152_T1_1mm standard image. Sample MNI standard images can be found in pyneal/utils/MNI_templates MNI mask : The mask file you wish to transform Output Prefix: : The output prefix that will be prepended to the transformed masks. Once you hit Submit , createMask.py will go about creating the necessary intermediate tranforms. Once complete, the new masks will open automatically in FSLeyes so that you may confirm that everything completed correctly. The new masks (and intermedate files) will be saved to the output directory.","title":"Transform MNI space mask"},{"location":"createMask/#output-files","text":"The output from createMask.py will be saved to the same directory as the specified reference 4D file. Within that directory, you will find a new directory named mask_transforms that holds all of the output mask files and transformation matrices from createMask.py Depending on the type of mask you are creating, you will find some set of the following files: FUNC_masks/wholeBrain_FUNC_mask.nii.gz : whole brain mask in participant functional space FUNC_masks/<outputPrefix>_FUNC_mask.nii.gz : binarized version of the transformed MNI mask in participant functional space FUNC_masks/<outputPrefix>_FUNC_weighted.nii.gz : non-binarized version of the transformed MNI mask in participant functional space. If the MNI mask you used represents a probabilistic atlas, for instance, those voxel probabilities will be preserved in this file. exampleFunc.nii.gz : a 3D functional image created by averaging the input 4D FUNC file hires_brain.nii.gz : skull-stripped version of the input hi-res ANAT file hires_FUNC.nii.gz : hi-res anatomical image transformed to participant functional space mni_HIRES.nii.gz : MNI standard transformed to participant hi-res anatomical space hires2func.mat : transformation matrix mapping from hi-res anatomical space to participant functional space mni2hires.mat : transformation matrix mapping from MNI space to hi-res anatomical space mni2func.mat : transformation matrix mapping from MNI space to participant functional space maskTransforms.log : log file detailing all of the steps that were carried out","title":"Output files"},{"location":"customAnalysis/","text":"Customized Analyses \u00b6 One of Pyneal's most powerful features is its ability to run customized analyses during a real-time scan. This means you can design your own analyses to fit your unique experimental needs, and Pyneal will execute those analyses on every new timepoint and store the results. To take advantage of this feature, you write a custom analysis script (in python ), and select the Custom button in the Analysis pane of the GUI: Custom Analysis Script \u00b6 While custom analyses offer a lot of flexibility, there are a couple of important constraints that need to be included in the script to ensure it can be integrated into the typical Pyneal data flow. The best way to ensure these constraints are met is to base your script off of the template file included with Pyneal . You can find this template in pyneal/utils/customAnalyses/customAnalysisTemplate.py Or, you can simply copy the text here: import sys import os from os.path import join import logging import numpy as np import nibabel as nib class CustomAnalysis: \"\"\" Custom Analysis Module This class contains all of the methods needed for setting up and executing customized analyses in Pyneal during a real-time scan \"\"\" def __init__(self, maskFile, weightMask, numTimepts): \"\"\" Initialize the class Everything in the `__init__` method will be executed BEFORE the scan begins. This is a place to run any necessary setup code. The `__init__` method provides a number of inputs from the setup GUI that can be used to help set up a customized analyses. You are free to use or ignore these inputs as needed. Parameters ---------- maskFile : string full path to the mask file specified in the Pyneal setup GUI weightMask : boolean flag indicating whether the \"weight mask?\" option in setup GUI was checked. numTimepts : int number of timepts in the run, as specified in the setup GUI \"\"\" # Load masks and weights, and create an within-class reference to # each for use in later methods. mask_img = nib.load(maskFile) if weightMask is True: self.weights = mask_img.get_data().copy() self.mask = mask_img.get_data() > 0 # 3D boolean array of mask voxels # within-class reference to numTimepts for use in later methods self.numTimepts = numTimepts # Add the directory that this script lives in to the path. This way it # is easy to load any additional files you want to put in the same # directory as your custom analysis script self.customAnalysisDir = os.path.abspath(os.path.dirname(__file__)) sys.path.append(self.customAnalysisDir) # Import the logger. If desired, you can write log messages to the # Pyneal log file using: # self.logger.info('my log message') - log file and stdOut # self.logger.debug('my log message') - log file only self.logger = logging.getLogger('PynealLog') ######################################################################## ############# vvv INSERT USER-SPECIFIED CODE BELOW vvv ################# self.myResult = 1 ############# ^^^ END USER-SPECIFIED CODE ^^^ ########################## ######################################################################## def compute(self, vol, volIdx): \"\"\" Compute method This method will be executed on EACH new 3D volume that arrives DURING the real-time scan. Results must be returned in a dictionary. No restrictions on dict key names or values, but note that the volume index will get added automatically by Pyneal before the result gets placed on the results server, so no need to specify that here Parameters ---------- vol : numpy-array 3D array of voxel data for the current volume volIdx : int 0-based index indicating where, in time (4th dimension), the volume belongs Returns ------- dict dictionary containing key:value pair(s) for the results for the current volume \"\"\" ######################################################################## ############# vvv INSERT USER-SPECIFIED CODE BELOW vvv ################# self.myResult += 1 ############# ^^^ END USER-SPECIFIED CODE ^^^ ########################## ######################################################################## return {'result': self.myResult} The script class consists of a single class ( CustomAnalysis ) with two methods: __init__ and compute . You are welcome to include any additional methods that are useful, just make sure these two methods exist. See below for details on what each method does and how to customize them. __init__ (initialize) \u00b6 The __init__ method is called as soon as you hit submit on the setup GUI. In other words, the code in this method runs before the scan begins. Thus, the __init__ method is where you will specify any set up code that needs to be initialized before the scan begins (e.g. loading multiple mask files). Let's take a look at the code in more detail: def __init__(self, maskFile, weightMask, numTimepts): \"\"\" Initialize the class Everything in the `__init__` method will be executed BEFORE the scan begins. This is a place to run any necessary setup code. The `__init__` method provides a number of inputs from the setup GUI that can be used to help set up a customized analyses. You are free to use or ignore these inputs as needed. Parameters ---------- maskFile : string full path to the mask file specified in the Pyneal setup GUI weightMask : boolean flag indicating whether the \"weight mask?\" option in setup GUI was checked. numTimepts : int number of timepts in the run, as specified in the setup GUI \"\"\" # Load masks and weights, and create an within-class reference to # each for use in later methods. mask_img = nib.load(maskFile) if weightMask is True: self.weights = mask_img.get_data().copy() self.mask = mask_img.get_data() > 0 # 3D boolean array of mask voxels # within-class reference to numTimepts for use in later methods self.numTimepts = numTimepts # Add the directory that this script lives in to the path. This way it # is easy to load any additional files you want to put in the same # directory as your custom analysis script self.customAnalysisDir = os.path.abspath(os.path.dirname(__file__)) sys.path.append(self.customAnalysisDir) # Import the logger. If desired, you can write log messages to the # Pyneal log file using: # self.logger.info('my log message') - log file and stdOut # self.logger.debug('my log message') - log file only self.logger = logging.getLogger('PynealLog') ######################################################################## ############# vvv INSERT USER-SPECIFIED CODE BELOW vvv ################# self.myResult = 1 ############# ^^^ END USER-SPECIFIED CODE ^^^ ########################## ######################################################################## Preset variables, and creating new ones \u00b6 First, note that certain settings from the setup GUI are passed into the custom analysis script. Namely: maskFile : the path to the mask specified in the GUI weightMask : a True/False boolean flag indicating whether the weight mask? option was checked or not. numTimepts : the number of timepts in the run, as specified in the GUI. At the top of the __init__ method, you'll see some code that reads in each of those settings, and creates local variables for each: # Load masks and weights, and create an within-class reference to # each for use in later methods. mask_img = nib.load(maskFile) if weightMask == True: self.weights = mask_img.get_data().copy() self.mask = mask_img.get_data() > 0 # 3D boolean array of mask voxels # within-class reference to numTimepts for use in later methods self.numTimepts = numTimepts This enables you to reference these variables in any other method by referring to self.mask , self.weights , and self.numTimepts . In fact, the same thing is true for any variable you create in the __init__ method; in order to access the variable in other methods, you must prepend the variable name with self. The __init__ method also contains a couple of other useful tidbits near the top. First, we add the directory that contains your custom analysis script to the path. This way, you can easily load any additional files that are exist in that same directory. # Add the directory that this script lives in to the path. This way it # is easy to load any additional files you want to put in the same # directory as your custom analysis script self.customAnalysisDir = os.path.abspath(os.path.dirname(__file__)) sys.path.append(self.customAnalysisDir) Adding log messages \u00b6 It also creates a reference to the logger, which is the tool that adds new messages to the pynealLog.log output file. You can use this reference anywhere in your script to add new log messages, which will be automatically timestamped and included in the output file. You can even control the type of log message info messages will get written to the output file AND appear in the stdOut of the terminal debug messages will only get written to the output file # Import the logger. If desired, you can write log messages to the # Pyneal log file using: # self.logger.info('my log message') - log file and stdOut # self.logger.debug('my log message') - log file only self.logger = logging.getLogger('PynealLog') User-specified __init__ code \u00b6 Finally, at the bottom of the __init__ method is space for you to include any additional code that is needed. ######################################################################## ############# vvv INSERT USER-SPECIFIED CODE BELOW vvv ################# self.myResult = 1 ############# ^^^ END USER-SPECIFIED CODE ^^^ ########################## ######################################################################## In order to illustrate, in the example above we're simply creating a new variable ( self.myResult ) and assigning it a value of 1 . compute \u00b6 The compute method is what actually gets called during a scan. In fact, it gets called each time a new 3D volume appears from the scanner. Here's the code in more detail: def compute(self, vol, volIdx): \"\"\" Compute method This method will be executed on EACH new 3D volume that arrives DURING the real-time scan. Results must be returned in a dictionary. No restrictions on dict key names or values, but note that the volume index will get added automatically by Pyneal before the result gets placed on the results server, so no need to specify that here Parameters ---------- vol : numpy-array 3D array of voxel data for the current volume volIdx : int 0-based index indicating where, in time (4th dimension), the volume belongs Returns ------- dict dictionary containing key:value pair(s) for the results for the current volume \"\"\" ######################################################################## ############# vvv INSERT USER-SPECIFIED CODE BELOW vvv ################# self.myResult += 1 ############# ^^^ END USER-SPECIFIED CODE ^^^ ########################## ######################################################################## return {'result': self.myResult} Note that the compute method passes in references to the current volume (3D numpy array, [x,y,z]), as well as the volIdx , an integer representing the current volume index (in 4th dimension; 0-based index). User-specified compute code \u00b6 The compute method includes space for you to insert your own analysis code: ######################################################################## ############# vvv INSERT USER-SPECIFIED CODE BELOW vvv ################# self.myResult += 1 ############# ^^^ END USER-SPECIFIED CODE ^^^ ########################## ######################################################################## You can use this area to write customized analysis code that will be executed on each volume. In the simple example above, each time a new volume arrives, the compute method will increment the self.myResult variable (created in the __init__ method) by 1. Storing results \u00b6 The compute method must return a python dictionary containing the analysis result (or results) for the current volume. return {'result': self.myResult} That said, you are free to customize the contents of this dictionary as needed to fit your experimental needs. For instance, if you are calculating the mean signal in multiple ROIs (and storing those value in variables named roi1_meanSignal , roi2_meanSignal , and roi3_meanSignal ) your dictionary could look something like this: {'roi1_mean': roi1_meanSignal, 'roi2_mean`: roi2_meanSignal, 'roi3_mean`: roi3_meanSignal} Pyneal automatically tacks on the current volIdx as an entry to the dictionary later on, so no need to include that information here.","title":"Customized Analyses"},{"location":"customAnalysis/#customized-analyses","text":"One of Pyneal's most powerful features is its ability to run customized analyses during a real-time scan. This means you can design your own analyses to fit your unique experimental needs, and Pyneal will execute those analyses on every new timepoint and store the results. To take advantage of this feature, you write a custom analysis script (in python ), and select the Custom button in the Analysis pane of the GUI:","title":"Customized Analyses"},{"location":"customAnalysis/#custom-analysis-script","text":"While custom analyses offer a lot of flexibility, there are a couple of important constraints that need to be included in the script to ensure it can be integrated into the typical Pyneal data flow. The best way to ensure these constraints are met is to base your script off of the template file included with Pyneal . You can find this template in pyneal/utils/customAnalyses/customAnalysisTemplate.py Or, you can simply copy the text here: import sys import os from os.path import join import logging import numpy as np import nibabel as nib class CustomAnalysis: \"\"\" Custom Analysis Module This class contains all of the methods needed for setting up and executing customized analyses in Pyneal during a real-time scan \"\"\" def __init__(self, maskFile, weightMask, numTimepts): \"\"\" Initialize the class Everything in the `__init__` method will be executed BEFORE the scan begins. This is a place to run any necessary setup code. The `__init__` method provides a number of inputs from the setup GUI that can be used to help set up a customized analyses. You are free to use or ignore these inputs as needed. Parameters ---------- maskFile : string full path to the mask file specified in the Pyneal setup GUI weightMask : boolean flag indicating whether the \"weight mask?\" option in setup GUI was checked. numTimepts : int number of timepts in the run, as specified in the setup GUI \"\"\" # Load masks and weights, and create an within-class reference to # each for use in later methods. mask_img = nib.load(maskFile) if weightMask is True: self.weights = mask_img.get_data().copy() self.mask = mask_img.get_data() > 0 # 3D boolean array of mask voxels # within-class reference to numTimepts for use in later methods self.numTimepts = numTimepts # Add the directory that this script lives in to the path. This way it # is easy to load any additional files you want to put in the same # directory as your custom analysis script self.customAnalysisDir = os.path.abspath(os.path.dirname(__file__)) sys.path.append(self.customAnalysisDir) # Import the logger. If desired, you can write log messages to the # Pyneal log file using: # self.logger.info('my log message') - log file and stdOut # self.logger.debug('my log message') - log file only self.logger = logging.getLogger('PynealLog') ######################################################################## ############# vvv INSERT USER-SPECIFIED CODE BELOW vvv ################# self.myResult = 1 ############# ^^^ END USER-SPECIFIED CODE ^^^ ########################## ######################################################################## def compute(self, vol, volIdx): \"\"\" Compute method This method will be executed on EACH new 3D volume that arrives DURING the real-time scan. Results must be returned in a dictionary. No restrictions on dict key names or values, but note that the volume index will get added automatically by Pyneal before the result gets placed on the results server, so no need to specify that here Parameters ---------- vol : numpy-array 3D array of voxel data for the current volume volIdx : int 0-based index indicating where, in time (4th dimension), the volume belongs Returns ------- dict dictionary containing key:value pair(s) for the results for the current volume \"\"\" ######################################################################## ############# vvv INSERT USER-SPECIFIED CODE BELOW vvv ################# self.myResult += 1 ############# ^^^ END USER-SPECIFIED CODE ^^^ ########################## ######################################################################## return {'result': self.myResult} The script class consists of a single class ( CustomAnalysis ) with two methods: __init__ and compute . You are welcome to include any additional methods that are useful, just make sure these two methods exist. See below for details on what each method does and how to customize them.","title":"Custom Analysis Script"},{"location":"customAnalysis/#__init__-initialize","text":"The __init__ method is called as soon as you hit submit on the setup GUI. In other words, the code in this method runs before the scan begins. Thus, the __init__ method is where you will specify any set up code that needs to be initialized before the scan begins (e.g. loading multiple mask files). Let's take a look at the code in more detail: def __init__(self, maskFile, weightMask, numTimepts): \"\"\" Initialize the class Everything in the `__init__` method will be executed BEFORE the scan begins. This is a place to run any necessary setup code. The `__init__` method provides a number of inputs from the setup GUI that can be used to help set up a customized analyses. You are free to use or ignore these inputs as needed. Parameters ---------- maskFile : string full path to the mask file specified in the Pyneal setup GUI weightMask : boolean flag indicating whether the \"weight mask?\" option in setup GUI was checked. numTimepts : int number of timepts in the run, as specified in the setup GUI \"\"\" # Load masks and weights, and create an within-class reference to # each for use in later methods. mask_img = nib.load(maskFile) if weightMask is True: self.weights = mask_img.get_data().copy() self.mask = mask_img.get_data() > 0 # 3D boolean array of mask voxels # within-class reference to numTimepts for use in later methods self.numTimepts = numTimepts # Add the directory that this script lives in to the path. This way it # is easy to load any additional files you want to put in the same # directory as your custom analysis script self.customAnalysisDir = os.path.abspath(os.path.dirname(__file__)) sys.path.append(self.customAnalysisDir) # Import the logger. If desired, you can write log messages to the # Pyneal log file using: # self.logger.info('my log message') - log file and stdOut # self.logger.debug('my log message') - log file only self.logger = logging.getLogger('PynealLog') ######################################################################## ############# vvv INSERT USER-SPECIFIED CODE BELOW vvv ################# self.myResult = 1 ############# ^^^ END USER-SPECIFIED CODE ^^^ ########################## ########################################################################","title":"__init__ (initialize)"},{"location":"customAnalysis/#preset-variables-and-creating-new-ones","text":"First, note that certain settings from the setup GUI are passed into the custom analysis script. Namely: maskFile : the path to the mask specified in the GUI weightMask : a True/False boolean flag indicating whether the weight mask? option was checked or not. numTimepts : the number of timepts in the run, as specified in the GUI. At the top of the __init__ method, you'll see some code that reads in each of those settings, and creates local variables for each: # Load masks and weights, and create an within-class reference to # each for use in later methods. mask_img = nib.load(maskFile) if weightMask == True: self.weights = mask_img.get_data().copy() self.mask = mask_img.get_data() > 0 # 3D boolean array of mask voxels # within-class reference to numTimepts for use in later methods self.numTimepts = numTimepts This enables you to reference these variables in any other method by referring to self.mask , self.weights , and self.numTimepts . In fact, the same thing is true for any variable you create in the __init__ method; in order to access the variable in other methods, you must prepend the variable name with self. The __init__ method also contains a couple of other useful tidbits near the top. First, we add the directory that contains your custom analysis script to the path. This way, you can easily load any additional files that are exist in that same directory. # Add the directory that this script lives in to the path. This way it # is easy to load any additional files you want to put in the same # directory as your custom analysis script self.customAnalysisDir = os.path.abspath(os.path.dirname(__file__)) sys.path.append(self.customAnalysisDir)","title":"Preset variables, and creating new ones"},{"location":"customAnalysis/#adding-log-messages","text":"It also creates a reference to the logger, which is the tool that adds new messages to the pynealLog.log output file. You can use this reference anywhere in your script to add new log messages, which will be automatically timestamped and included in the output file. You can even control the type of log message info messages will get written to the output file AND appear in the stdOut of the terminal debug messages will only get written to the output file # Import the logger. If desired, you can write log messages to the # Pyneal log file using: # self.logger.info('my log message') - log file and stdOut # self.logger.debug('my log message') - log file only self.logger = logging.getLogger('PynealLog')","title":"Adding log messages"},{"location":"customAnalysis/#user-specified-__init__-code","text":"Finally, at the bottom of the __init__ method is space for you to include any additional code that is needed. ######################################################################## ############# vvv INSERT USER-SPECIFIED CODE BELOW vvv ################# self.myResult = 1 ############# ^^^ END USER-SPECIFIED CODE ^^^ ########################## ######################################################################## In order to illustrate, in the example above we're simply creating a new variable ( self.myResult ) and assigning it a value of 1 .","title":"User-specified __init__ code"},{"location":"customAnalysis/#compute","text":"The compute method is what actually gets called during a scan. In fact, it gets called each time a new 3D volume appears from the scanner. Here's the code in more detail: def compute(self, vol, volIdx): \"\"\" Compute method This method will be executed on EACH new 3D volume that arrives DURING the real-time scan. Results must be returned in a dictionary. No restrictions on dict key names or values, but note that the volume index will get added automatically by Pyneal before the result gets placed on the results server, so no need to specify that here Parameters ---------- vol : numpy-array 3D array of voxel data for the current volume volIdx : int 0-based index indicating where, in time (4th dimension), the volume belongs Returns ------- dict dictionary containing key:value pair(s) for the results for the current volume \"\"\" ######################################################################## ############# vvv INSERT USER-SPECIFIED CODE BELOW vvv ################# self.myResult += 1 ############# ^^^ END USER-SPECIFIED CODE ^^^ ########################## ######################################################################## return {'result': self.myResult} Note that the compute method passes in references to the current volume (3D numpy array, [x,y,z]), as well as the volIdx , an integer representing the current volume index (in 4th dimension; 0-based index).","title":"compute"},{"location":"customAnalysis/#user-specified-compute-code","text":"The compute method includes space for you to insert your own analysis code: ######################################################################## ############# vvv INSERT USER-SPECIFIED CODE BELOW vvv ################# self.myResult += 1 ############# ^^^ END USER-SPECIFIED CODE ^^^ ########################## ######################################################################## You can use this area to write customized analysis code that will be executed on each volume. In the simple example above, each time a new volume arrives, the compute method will increment the self.myResult variable (created in the __init__ method) by 1.","title":"User-specified compute code"},{"location":"customAnalysis/#storing-results","text":"The compute method must return a python dictionary containing the analysis result (or results) for the current volume. return {'result': self.myResult} That said, you are free to customize the contents of this dictionary as needed to fit your experimental needs. For instance, if you are calculating the mean signal in multiple ROIs (and storing those value in variables named roi1_meanSignal , roi2_meanSignal , and roi3_meanSignal ) your dictionary could look something like this: {'roi1_mean': roi1_meanSignal, 'roi2_mean`: roi2_meanSignal, 'roi3_mean`: roi3_meanSignal} Pyneal automatically tacks on the current volIdx as an entry to the dictionary later on, so no need to include that information here.","title":"Storing results"},{"location":"dataflow/","text":"This schematic gives a very broad overview of the path that data follows throughout a real-time scan with Pyneal Once the scan begins, raw images are collected by Pyneal Scanner , and then converted and reoriented to a standardized format (see image orientation for more info). Pyneal Scanner exports converted 3D volumes to Pyneal . Pyneal receives 3D volumes, and concatenates them into a 4D volume over time throughout the scan. With every new 3D volume that arrives, Pyneal will preprocess the volume, and run any specified analyses. The analysis results for each volume are stored on a separate server, which listens for requests from remote end users or devices throughout the scan (see requesting results for more info). Anytime a request is received, the server checks to see if that volume has been processed yet. If so, it returns the results; if not, it sends a message saying that volume has not been processed yet","title":"Data Flow"},{"location":"endUser/","text":"We refer to any component that requests results from Pyneal during a scan as an End User . For instance, a potential End User could be task presentation software that periodically makes requests for analysis results in order to update a neurofeedback display for the participant. Sending requests \u00b6 Sending a request to Pyneal for the results from a specific volume simply requires you to establish a connection to Pyneal and send the index value of the volume you'd like to request (0-based index). The volume index should be formatted as a 4-character string, with zero-padded as needed. For instance, to request the results from the 9th volume (i.e. index 8), the request would be formatted as 0008 . Here is an example, written in python for how you might send a request for the 9th volume: import socket # socket configs host = '127.0.0.1' # Pyneal address port = 5556 # results server port number # connect to the results server of Pyneal clientSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) clientSocket.connect((host, port)) # format request for the 9th volume (index 8). request = '0008' # send the request clientSocket.send(request.encode()) This approach can be incorporated into any End User application (e.g. an experimental task) to request specific results throughout a scan. Parsing Responses \u00b6 Continuing from the previous section, once the results server on Pyneal receives a request for volume index 0008 , it will check to see if that volume has arrived and been analyzed yet. If the volume has not arrived, the response will be a JSON message that contains a single key:value pair: \"foundResults\":False If the volume has arrived, the response will be a JSON message that contains the key:value pair \"foundResults\":True as well all of the results key:value pairs for that volume. For instance, if the real-time analysis is set to compute the average activation with the selected mask, the response message for volume 0008 may look like {'foundResults': True, 'average':2432} . If you are using a custom analysis script that computes multiple results on each volume, all of those results will appear in the response message. For instance, if you have a custom analysis script that is computing the mean activation separately in 3 ROIs, the response message may look like {'foundResults': True, \"roi1_average\": 2149.81, \"roi2_average\": 2519.11, \"roi3_average\": 2543.61} For reference, here is the code that the results server uses to send responses: def sendResults(self, connection, results): \"\"\" Format the results dict to a json string, and send results to the client. Message will be sent in 2 waves: first a header indicating the msg length, and then the message itself \"\"\" # format as json string and then convert to bytes formattedMsg = '{}\\n'.format(json.dumps(results)).encode() # send results as formatted message connection.sendall(formattedMsg) self.logger.debug('Sent result: {}'.format(formattedMsg)) Example Responses \u00b6 Here are some example of what the JSON responses might look like using different analysis options. Results were not found : The End User requested a volume that has not arrived or been analyzed yet: {'foundResults': False} Pyneal Built-in Analysis Options \u00b6 Average (from GUI): compute the average signal within the specified mask: {'foundResults': True, 'average':2432} Weighted Average (from GUI): compute the weighted average within the specified mask, using mask voxels values as weights (\"Weighted Mask?\" is checked in GUI): {'foundResults': True, 'weightedAverage':2432} Median (from GUI): compute the median signal within the specified mask: {'foundResults': True, 'median':2432} Weighted Median (from GUI): compute the weighted median within the specified mask, using mask voxel values as weights (\"Weighted Mask?\" is checked in GUI): {'foundResults': True, 'weightedMedian':2432} Using Custom Analyses \u00b6 The JSON responses from custom analyses will vary based on your custom analysis script. At a minimum, all responses will contain the 'foundResults' entry. For instance, if you have a custom analysis script that is computing the mean activation separately in 3 ROIs, the response message may look like: {'foundResults': True, \"roi1_average\": 2149.81, \"roi2_average\": 2519.11, \"roi3_average\": 2543.61}","title":"End User"},{"location":"endUser/#sending-requests","text":"Sending a request to Pyneal for the results from a specific volume simply requires you to establish a connection to Pyneal and send the index value of the volume you'd like to request (0-based index). The volume index should be formatted as a 4-character string, with zero-padded as needed. For instance, to request the results from the 9th volume (i.e. index 8), the request would be formatted as 0008 . Here is an example, written in python for how you might send a request for the 9th volume: import socket # socket configs host = '127.0.0.1' # Pyneal address port = 5556 # results server port number # connect to the results server of Pyneal clientSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) clientSocket.connect((host, port)) # format request for the 9th volume (index 8). request = '0008' # send the request clientSocket.send(request.encode()) This approach can be incorporated into any End User application (e.g. an experimental task) to request specific results throughout a scan.","title":"Sending requests"},{"location":"endUser/#parsing-responses","text":"Continuing from the previous section, once the results server on Pyneal receives a request for volume index 0008 , it will check to see if that volume has arrived and been analyzed yet. If the volume has not arrived, the response will be a JSON message that contains a single key:value pair: \"foundResults\":False If the volume has arrived, the response will be a JSON message that contains the key:value pair \"foundResults\":True as well all of the results key:value pairs for that volume. For instance, if the real-time analysis is set to compute the average activation with the selected mask, the response message for volume 0008 may look like {'foundResults': True, 'average':2432} . If you are using a custom analysis script that computes multiple results on each volume, all of those results will appear in the response message. For instance, if you have a custom analysis script that is computing the mean activation separately in 3 ROIs, the response message may look like {'foundResults': True, \"roi1_average\": 2149.81, \"roi2_average\": 2519.11, \"roi3_average\": 2543.61} For reference, here is the code that the results server uses to send responses: def sendResults(self, connection, results): \"\"\" Format the results dict to a json string, and send results to the client. Message will be sent in 2 waves: first a header indicating the msg length, and then the message itself \"\"\" # format as json string and then convert to bytes formattedMsg = '{}\\n'.format(json.dumps(results)).encode() # send results as formatted message connection.sendall(formattedMsg) self.logger.debug('Sent result: {}'.format(formattedMsg))","title":"Parsing Responses"},{"location":"endUser/#example-responses","text":"Here are some example of what the JSON responses might look like using different analysis options. Results were not found : The End User requested a volume that has not arrived or been analyzed yet: {'foundResults': False}","title":"Example Responses"},{"location":"endUser/#pyneal-built-in-analysis-options","text":"Average (from GUI): compute the average signal within the specified mask: {'foundResults': True, 'average':2432} Weighted Average (from GUI): compute the weighted average within the specified mask, using mask voxels values as weights (\"Weighted Mask?\" is checked in GUI): {'foundResults': True, 'weightedAverage':2432} Median (from GUI): compute the median signal within the specified mask: {'foundResults': True, 'median':2432} Weighted Median (from GUI): compute the weighted median within the specified mask, using mask voxel values as weights (\"Weighted Mask?\" is checked in GUI): {'foundResults': True, 'weightedMedian':2432}","title":"Pyneal Built-in Analysis Options"},{"location":"endUser/#using-custom-analyses","text":"The JSON responses from custom analyses will vary based on your custom analysis script. At a minimum, all responses will contain the 'foundResults' entry. For instance, if you have a custom analysis script that is computing the mean activation separately in 3 ROIs, the response message may look like: {'foundResults': True, \"roi1_average\": 2149.81, \"roi2_average\": 2519.11, \"roi3_average\": 2543.61}","title":"Using Custom Analyses"},{"location":"glossary/","text":"Glossary \u00b6 Computers \u00b6 The documentation refers to computers by their functional role: Scanner computer : The computer where reconstructed images from the scanner appear. In the case of GE scanners, for instance, new slice dicom files appear in a directory on the scanner console. Siemens scanners, on the other hand, may export new images to a directory on a shared network drive. The scanner computer is simply the computer that has local access to the directory where new images appear Analysis computer : The computer that will be running Pyneal . This is the computer on which users will setup their analysis, launch Pyneal , and monitor on-going scans. Note that in some cases, the same physical computer can play both functional roles. For instance, when working in a Siemens environment, new images from the scanner might be exported to a shared directory that is accessible on the analysis computer . In this case, the same machine could be playing the role of both the scanner computer and the analysis computer . End User : Generic term for any computer/process that is making a request to Pyneal for results during a scan. For instance, a task presentation computer that is requesting specific feedback values to present to the participant. Additional terms used \u00b6 Series : A complete scan representing either a single 3D anatomical image, or a 4D functional image. Session : A collection of series collected within the same experimental session. A session would typically represent all of the scans collected after the subject is placed in the scanner (e.g. Anatomical, functional series1, functional series2, etc...)","title":"Glossary"},{"location":"glossary/#glossary","text":"","title":"Glossary"},{"location":"glossary/#computers","text":"The documentation refers to computers by their functional role: Scanner computer : The computer where reconstructed images from the scanner appear. In the case of GE scanners, for instance, new slice dicom files appear in a directory on the scanner console. Siemens scanners, on the other hand, may export new images to a directory on a shared network drive. The scanner computer is simply the computer that has local access to the directory where new images appear Analysis computer : The computer that will be running Pyneal . This is the computer on which users will setup their analysis, launch Pyneal , and monitor on-going scans. Note that in some cases, the same physical computer can play both functional roles. For instance, when working in a Siemens environment, new images from the scanner might be exported to a shared directory that is accessible on the analysis computer . In this case, the same machine could be playing the role of both the scanner computer and the analysis computer . End User : Generic term for any computer/process that is making a request to Pyneal for results during a scan. For instance, a task presentation computer that is requesting specific feedback values to present to the participant.","title":"Computers"},{"location":"glossary/#additional-terms-used","text":"Series : A complete scan representing either a single 3D anatomical image, or a 4D functional image. Session : A collection of series collected within the same experimental session. A session would typically represent all of the scans collected after the subject is placed in the scanner (e.g. Anatomical, functional series1, functional series2, etc...)","title":"Additional terms used"},{"location":"imageOrientation/","text":"Image Orientation \u00b6 Throughout the Pyneal pipeline, from the output stage of Pyneal Scanner onward, we use the convention of orienting the images to RAS+ . This means: The 1st axis (x) is oriented from left to right The 2nd axis (y) is oriented from posterior to anterior The 3rd axis (z) is oriented from inferior to superior Visually, the RAS+ coordinate system is arranged like: There are a number of stages throughout the pipeline where this is important to keep in mind: Building nifti files offline with getSeries.py \u00b6 When you use the getSeries.py tool to build a nifti file from raw images from the scanner, the resulting image will be oriented to RAS+ Output from Pyneal Scanner \u00b6 Pyneal Scanner is designed to accept a variety of inputs from various scanner manufactures and imaging environments. One of Pyneal Scanner's important functions is to take the input data, in whatever form it appears, and convert it to a standardized format before passing each volume along to Pyneal . Pyneal expects each volume to arrive from Pyneal Scanner in RAS+ orientation. Creating masks for Pyneal \u00b6 Since Pyneal receives images from Pyneal Scanner that are oriented to RAS+ , the mask that Pyneal uses for analysis must also be oriented to RAS+ . (In fact, not only does the mask have to be in RAS+ , it also must match the dimensions of the incoming volumes. The easiest way to ensure this is the case is to use the Create Mask tool, which uses an example functional series from the current scan to transform the mask to the correct dimensions and orientation) Saved output from Pyneal \u00b6 At the conclusion of a real-time run, Pyneal will save the series data as a 4D nifti file in the specified output directory. This output file will be oriented to RAS+ . See also: \u00b6 For helpful guides on understanding image orientation, and using affine transformations, see: http://nipy.org/nibabel/dicom/dicom_orientation.html http://nipy.org/nibabel/coordinate_systems.html","title":"Image Orientation"},{"location":"imageOrientation/#image-orientation","text":"Throughout the Pyneal pipeline, from the output stage of Pyneal Scanner onward, we use the convention of orienting the images to RAS+ . This means: The 1st axis (x) is oriented from left to right The 2nd axis (y) is oriented from posterior to anterior The 3rd axis (z) is oriented from inferior to superior Visually, the RAS+ coordinate system is arranged like: There are a number of stages throughout the pipeline where this is important to keep in mind:","title":"Image Orientation"},{"location":"imageOrientation/#building-nifti-files-offline-with-getseriespy","text":"When you use the getSeries.py tool to build a nifti file from raw images from the scanner, the resulting image will be oriented to RAS+","title":"Building nifti files offline with getSeries.py"},{"location":"imageOrientation/#output-from-pyneal-scanner","text":"Pyneal Scanner is designed to accept a variety of inputs from various scanner manufactures and imaging environments. One of Pyneal Scanner's important functions is to take the input data, in whatever form it appears, and convert it to a standardized format before passing each volume along to Pyneal . Pyneal expects each volume to arrive from Pyneal Scanner in RAS+ orientation.","title":"Output from Pyneal Scanner"},{"location":"imageOrientation/#creating-masks-for-pyneal","text":"Since Pyneal receives images from Pyneal Scanner that are oriented to RAS+ , the mask that Pyneal uses for analysis must also be oriented to RAS+ . (In fact, not only does the mask have to be in RAS+ , it also must match the dimensions of the incoming volumes. The easiest way to ensure this is the case is to use the Create Mask tool, which uses an example functional series from the current scan to transform the mask to the correct dimensions and orientation)","title":"Creating masks for Pyneal"},{"location":"imageOrientation/#saved-output-from-pyneal","text":"At the conclusion of a real-time run, Pyneal will save the series data as a 4D nifti file in the specified output directory. This output file will be oriented to RAS+ .","title":"Saved output from Pyneal"},{"location":"imageOrientation/#see-also","text":"For helpful guides on understanding image orientation, and using affine transformations, see: http://nipy.org/nibabel/dicom/dicom_orientation.html http://nipy.org/nibabel/coordinate_systems.html","title":"See also:"},{"location":"installation/","text":"Installation \u00b6 Pyneal is built and tested using Python 3.6 in MacOS 10.13.4 Download Python from https://www.python.org/downloads/ or via a distribution like Anaconda Pyneal requires additional libraries beyond the standard library. Instructions below use pip to install these libraries. Verify that you have pip installed: which pip If not, download and install pip from https://pip.pypa.io/en/stable/installing/ Download Pyneal \u00b6 Download the Pyneal repository from GitHub, or clone the repository to your local machine: git clone https://github.com/jeffmacinnes/pyneal.git The installation instructions are broken down by Pyneal Scanner and Pyneal . If you haven't already, read the section on definitions , as those definitions are used throughout these instructions. Pyneal-Scanner \u00b6 The pyneal_scanner directory needs to be on the scanner computer . If the scanner computer is different from the analysis computer in your environment, copy the pyneal_scanner directory to the scanner computer . dependencies \u00b6 The scanner computer requires additional python libraries in order to run Pyneal Scanner . You can attempt to install all required libraries at once by navigating into the pyneal_scanner directory and typing: pip install -r requirements.txt If that fails for any reason, you can install manually one at a time: pip install numpy==1.17 pip install pydicom>=1.0.2 pip install nibabel>=2.1.0 pip install pyzmq>=16.0.2 pip install pyyaml>=3.12 These versions reflect the primary environment in which Pyneal is tested. It is likely that other versions maintain compatibility, but use at your own risk. Pyneal \u00b6 The pyneal directory needs to be on the analysis computer . dependencies \u00b6 Note : Pyneal relies on Nipy, which currently has compatibility issues with deprecated functions in Numpy and Scipy. Currently, the requirements files install older versions of Numpy and Scipy. If you are still experiencing errors, build the developer version of Nipy from source . Version 0.5.0.dev has been tested and works The analysis computer requires additional python libraries in order to run Pyneal . You can attempt to install all required libraries at once by navigating into the pyneal directory and typing: pip install -r requirements.txt If that fails for any reason, you can install manually one at a time: pip install numpy==1.17 pip install scipy==1.1.0 pip install nibabel>=2.1.0 pip install nipy>=0.4.1 pip install pyzmq>=16.0.2 pip install pyyaml>=3.12 pip install wxPython>=4.0.1 pip install flask>=0.12.2 pip install flask_socketio>=2.9.2 pip install eventlet>=0.21.0 These versions reflect the primary environment in which Pyneal is tested. It is likely that other versions maintain compatibility, but use at your own risk. Anaconda installation \u00b6 If you are running Python via Anacona installation, you may need to run the following additional commands during installation and setup. Prior to install \u00b6 Create new conda environment: conda create --name pynealEnv conda activate pynealEnv conda install pip Launching Pyneal \u00b6 Launch GUI with pythonw command sudo pythonw pyneal.py Additional Tools \u00b6 Pyneal itself does not require any additional libaries beyond what is listed above. However, there are various tools included that you may find useful during a real-time scan session. For instance, the tool createMask can be used to transform a standard space ROI mask to the subject's functional space, which can then be used as a mask for analysis during a real-time scan. In order to use these additional tools, make sure you have installed the following: FSL 5.0","title":"Installation"},{"location":"installation/#installation","text":"Pyneal is built and tested using Python 3.6 in MacOS 10.13.4 Download Python from https://www.python.org/downloads/ or via a distribution like Anaconda Pyneal requires additional libraries beyond the standard library. Instructions below use pip to install these libraries. Verify that you have pip installed: which pip If not, download and install pip from https://pip.pypa.io/en/stable/installing/","title":"Installation"},{"location":"installation/#download-pyneal","text":"Download the Pyneal repository from GitHub, or clone the repository to your local machine: git clone https://github.com/jeffmacinnes/pyneal.git The installation instructions are broken down by Pyneal Scanner and Pyneal . If you haven't already, read the section on definitions , as those definitions are used throughout these instructions.","title":"Download Pyneal"},{"location":"installation/#pyneal-scanner","text":"The pyneal_scanner directory needs to be on the scanner computer . If the scanner computer is different from the analysis computer in your environment, copy the pyneal_scanner directory to the scanner computer .","title":"Pyneal-Scanner"},{"location":"installation/#dependencies","text":"The scanner computer requires additional python libraries in order to run Pyneal Scanner . You can attempt to install all required libraries at once by navigating into the pyneal_scanner directory and typing: pip install -r requirements.txt If that fails for any reason, you can install manually one at a time: pip install numpy==1.17 pip install pydicom>=1.0.2 pip install nibabel>=2.1.0 pip install pyzmq>=16.0.2 pip install pyyaml>=3.12 These versions reflect the primary environment in which Pyneal is tested. It is likely that other versions maintain compatibility, but use at your own risk.","title":"dependencies"},{"location":"installation/#pyneal","text":"The pyneal directory needs to be on the analysis computer .","title":"Pyneal"},{"location":"installation/#dependencies_1","text":"Note : Pyneal relies on Nipy, which currently has compatibility issues with deprecated functions in Numpy and Scipy. Currently, the requirements files install older versions of Numpy and Scipy. If you are still experiencing errors, build the developer version of Nipy from source . Version 0.5.0.dev has been tested and works The analysis computer requires additional python libraries in order to run Pyneal . You can attempt to install all required libraries at once by navigating into the pyneal directory and typing: pip install -r requirements.txt If that fails for any reason, you can install manually one at a time: pip install numpy==1.17 pip install scipy==1.1.0 pip install nibabel>=2.1.0 pip install nipy>=0.4.1 pip install pyzmq>=16.0.2 pip install pyyaml>=3.12 pip install wxPython>=4.0.1 pip install flask>=0.12.2 pip install flask_socketio>=2.9.2 pip install eventlet>=0.21.0 These versions reflect the primary environment in which Pyneal is tested. It is likely that other versions maintain compatibility, but use at your own risk.","title":"dependencies"},{"location":"installation/#anaconda-installation","text":"If you are running Python via Anacona installation, you may need to run the following additional commands during installation and setup.","title":"Anaconda installation"},{"location":"installation/#prior-to-install","text":"Create new conda environment: conda create --name pynealEnv conda activate pynealEnv conda install pip","title":"Prior to install"},{"location":"installation/#launching-pyneal","text":"Launch GUI with pythonw command sudo pythonw pyneal.py","title":"Launching Pyneal"},{"location":"installation/#additional-tools","text":"Pyneal itself does not require any additional libaries beyond what is listed above. However, there are various tools included that you may find useful during a real-time scan session. For instance, the tool createMask can be used to transform a standard space ROI mask to the subject's functional space, which can then be used as a mask for analysis during a real-time scan. In order to use these additional tools, make sure you have installed the following: FSL 5.0","title":"Additional Tools"},{"location":"miscTools/","text":"Miscellaneous Tools \u00b6 TODO","title":"Miscellaneous Tools"},{"location":"miscTools/#miscellaneous-tools","text":"TODO","title":"Miscellaneous Tools"},{"location":"pyneal/","text":"Pyneal \u00b6 First step, make sure you've followed the instructions at setup: Pyneal to configure Pyneal to your environment. Directory Structure \u00b6 The Pyneal directory has the following structure: \u251c\u2500\u2500 pyneal \u2502 \u251c\u2500\u2500 LICENSE.txt \u2502 \u251c\u2500\u2500 README.md \u2502 \u251c\u2500\u2500 pyneal.py \u2502 \u251c\u2500\u2500 pyneal_scanner \u2502 \u251c\u2500\u2500 requirements.txt \u2502 \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 utils The root level of the directory contains basic commands for launching Pyneal ( pyneal.py ), as well as the license and README files. Subdirectories : pyneal_scanner/ : Pyneal Scanner directory; see Overview: Pyneal Scanner src/ : Source code for the GUIs and submodules that support Pyneal . utils/ : Additional utilities that you may find helpful in configuring Pyneal to your experiment. This directory is worth unpacking further: \u251c\u2500\u2500 pyneal \u2502 ... \u2502 \u2514\u2500\u2500 utils \u2502 \u251c\u2500\u2500 MNI_templates \u2502 \u251c\u2500\u2500 createMask.py \u2502 \u251c\u2500\u2500 customAnalyses \u2502 \u251c\u2500\u2500 masks \u2502 \u251c\u2500\u2500 mkDummyMask.py \u2502 \u2514\u2500\u2500 simulation Mask Utilities: createMask.py will launch the Create Mask tool, which will allow you to transform a MNI space mask down to the functional space of the current subject; see Create Mask MNI_templates/ : reference MNI template volumes to use with createMask.py masks/ : a sampling of MNI space anatomical masks that you can use with createMask.py . Note that it is also possible to supply your own MNI-space mask. mkDummyMask.py will allow you to quickly create a dummy mask in 3D volume that is whatever dimensions you specify. This is useful for when you may need a mask in a given functional space to test Pyneal but aren't concerned with the results. The resulting mask will be a rectangle positioned in the center of the middle slice of a volume. You specify the overall volume dimensions. Misc Utilities: customAnalyses/ : A custom analysis template that facilitates designing your own customized analysis routines to carry out in a real-time scanning run; see customAnalysis.md simulation/ : Tools for simulating inputs and outputs of Pyneal ; see simulations: Pyneal Simulation Tools Basic Usage \u00b6 To launch Pyneal from the analysis computer , open a terminal and navigate to the pyneal directory. From there, type: python pyneal.py usage: pyneal.py [-h] [--noGUI] [-s SETTINGSFILE] optional arguments: -h, --help show this help message and exit --noGUI run in headless mode, no setup GUI. (requires a valid settings file, either supplied here with -s option, or in {pyneal root}/src/GUIs/pynealSetup.yaml) -s SETTINGSFILE, --settingsFile SETTINGSFILE specify the path to a custom settings file This will launch a GUI that will allow you to set up Pyneal for a particular real-time scan. In most cases, this is how you'll want to configure Pyneal for the current session. However, as shown above, you also have the option to supply your own custom configuration file, or run in headless mode without showing the setup GUI. After you launch Pyneal , a dashboard will appear (if specified during configuration) that allows you to monitor the progress of your scan. Additional log messages will appear in the terminal throughout the scan. See below for a more detailed description of how to prepare for a real-time scan , what's going on during a real-time scan , and what type of data is available after a real-time scan Preparing for a real-time scan \u00b6 Network settings \u00b6 By this point, if you have followed the setup instructions for both Pyneal Scanner and Pyneal you will have delegated one machine to be the scanner computer and one machine to be the analysis computer . It is imperative that Pyneal Scanner and Pyneal can communicate with one another during a scan. That is, the scanner computer must be able to connect to the analysis computer over an available network port. Different scanning environments will have different configurations (see setup: setting up your network for more details). Regardless of your setup, make sure you know the IP address you will use for Pyneal , as well as the port numbers to use for communication with Pyneal Scanner and any remote End User . Creating Masks \u00b6 Pyneal requires the user to supply a mask that will specify which voxels to include during the real-time analysis. This mask can take any form you want, with the caveat that it must be in the same space (i.e. voxel size, slice dimensions, and orientation) as the incoming functional data throughout the real-time scan. One way to ensure this would to collect a short localizer scan at the beginning of the session that has the desired scan parameters, and use this data to create/register/align your mask for the subsequent real-time runs. Examples: Mask from functional ROI : You could include a mask that represents voxels with significant task-induced activation from the current subject. To do so, include a quick localizer task at the beginning of your session that you can access offline (for instance, by using the getSeries.py tool in Pyneal Scanner ) and analyze. Threshold and/or binarize the resulting statistical maps as appropriate, and create a funtional ROI mask file. Mask from anatomical ROI : You can create a subject-specific anatomical ROI mask by transforming a preselected MNI space mask to the participant's functional space. Pyneal includes an automated tool to assist in this process. See Additional Tools: Creating Masks . Your chosen source MNI mask can be a binary anatomical mask or a weighted probablistic mask. When you load the functional space mask into Pyneal you will have the option of preserving voxel weights. Choosing Analyses \u00b6 Prior to beginning a real-time project, determine what type of analysis is most appropriate to your project, and whether the built-in analysis routines will suffice or whether it'd be more appropriate to use a custom analysis script. Pyneal has built-in analysis tools that can compute simple descriptive summaries (e.g. mean, median) from a single ROI. However, by using a custom analysis script, you can develop unique and complex analyses, targeting one or more ROIs, that will execute on every incoming volume during the scan. See Additional Tools: Customized Analyses Running a real-time scan \u00b6 To launch Pyneal from the analysis computer , open the command line and navigate to the pyneal directory. From the pyneal directory, type: python pyneal.py This will launch the setup GUI, allowing you to enter the appropriate settings for your environment/session. The GUI is discussed below, but note that you can also supply a premade configuration file and/or run Pyneal in headless mode without viewing the setup GUI by following the usage examples: usage: pyneal.py [-h] [--noGUI] [-s SETTINGSFILE] optional arguments: -h, --help show this help message and exit --noGUI run in headless mode, no setup GUI. (requires a valid settings file, either supplied here with -s option, or in {pyneal root}/src/GUIs/pynealSetup.yaml) -s SETTINGSFILE, --settingsFile SETTINGSFILE specify the path to a custom settings file Set-up GUI \u00b6 Launching the GUI will load the settings from previous run. For running multiple scans in the same session, you may not need to change any settings after the first scan. If you do need to change settings, you can do so manually via each field in the GUI, or you can click Load Settings to load a custom .yaml configuration file. A custom settings file must contain one or more of the required configuration key:value pairs; see Setup: Pyneal for more details on the Configuration Keys . Any configuration keys not specified in the custom settings file will be set using default values. The GUI presents a number of options that can be customized to your project/enviroment: Communication \u00b6 The Communication panel is where you specify the network settings for communication between Pyneal Scanner , Pyneal , and any remote End User . Pyneal Host IP : The IP address of the machine running Pyneal (i.e. the analysis machine ). This is the IP address that Pyneal Scanner will try to connect to, as well as any remote End User that is making requests for results. Pyneal-Scanner Port : The port number over which Pyneal will be listening for incoming data from Pyneal Scanner . Results Server Port : The port number that Pyneal will use to set up the Results Server . Remote machines that wish to retrieve real-time analysis output during a scan can send requests over this port number. Mask \u00b6 Specify the path to mask file (Nifti - .nii/.nii.gz) to be used during real-time analysis. During the analysis stage, each incoming 3D volume will be masked to remove non-relevant voxels. The mask must match the dimensions and orientation of incoming functional data (see Creating Masks for Real-time Analysis). If Weighted Mask? is checked, the voxel values will be used as weights and passed along to the analysis stage. For a Custom analysis in which you want to use 2 or more ROIs, you should set your custom analysis script to load the desired ROIs. In that situation, you should choose a mask file here that represents a whole brain mask (see Creating Masks for Real-time Analysis). Preprocessing \u00b6 Specify how many timepoints will be in the upcoming series. The other dimensions of the dataset (i.e. slice dimensions, number of slices per vol) will be determined automatically from the incoming data. Analysis \u00b6 Choose the analyses you want to carry out during the real-time run Average : Built-in analysis routine. Compute the mean activation over all voxels in the Mask specified above. The results will be stored as a dictionary under the key name average . If the Weighted Mask? option is selected on the Mask panel, a weighted average will be calculated, using voxel values as weights. In this case, the results will be stored in a dictionary under the key name weightedAverage . Median : Built-in analysis routine. Compute the median activation value over all voxels in the Mask specifed above. The results will be stored in a dictionary under the key name median . If the Weighted Mask? option is selected on the Mask panel, a weighted mean will be calculated, using voxel values as weights. (see weightedstats for algorithm). In this case, the results will be stored in a dictionary under the key name weightedMedian . Custom : Load a custom analysis script. The analysis algorithms specified in the script will be executed on every incoming timepoint during the scan. How the results get stored in the results dictionary throughout a scan is up to your particular script (see Custom Analysis Scripts ) Output \u00b6 Specify a path to an output directory for the current session . Within this output directory, the results and log files for each new series will be written to unique subdirectories, starting with pyneal_001 for the first series and named sequentially thereafter. Launch Dashboard? : Option for whether to present a dashboard during the real-time scan or not. If selected, the dashboard will launch automatically upon submission. However, if you happen to close it for any reason, you can access it by pointing a web browser to 127.0.0.1:5558 (Note: 5558 is the dashboardClientPort number. To confirm the correct port, check the settings that are printed to the terminal once you hit Submit from the setup GUI (see Command line output below). For more information on using the Dashboard, see Dashboard below). Command line output \u00b6 Once you hit submit, the command line will print a message showing you where log files for the current series will be stored, as well as all of the configuration settings for this series: Logs written to: /path/to/outputDir/pyneal_001/pynealLog.log MainThread - Setting: analysisChoice: Average MainThread - Setting: dashboardClientPort: 5558 MainThread - Setting: dashboardPort: 5557 MainThread - Setting: launchDashboard: True MainThread - Setting: maskFile: /path/to/maskFile.nii.gz MainThread - Setting: maskIsWeighted: False MainThread - Setting: numTimepts: 60 MainThread - Setting: outputPath: /path/to/outputDir MainThread - Setting: pynealHost: 127.0.0.1 MainThread - Setting: pynealScannerPort: 5555 MainThread - Setting: resultsServerPort: 5556 MainThread - Setting: seriesOutputDir: /path/to/outputDir/pyneal_001 At the end of the message, you'll see a status indicator for the various subcomponents of Pyneal : MainThread - ScanReceiver Server alive and listening.... Waiting for connection from pyneal_scanner MainThread - Results Server alive and listening.... If everything is working properly, it'll say that both the ScanReceiver Server and Results Server are alive and listening. (for more information about what these components are doing, see Pyneal Subcomponents below). You should also see a message indicating that Pyneal is waiting to connect to Pyneal Scanner . Once you launch Pyneal Scanner , this message will update to: Received message: hello from pyneal_scanner Throughout the scan, the terminal will update with status and log messages reporting on-going processes. In addition to the command line output, you can monitor the status of the scan from the web-based dashboard. Dashboard \u00b6 The dashboard will launch automatically, but if you happen to close the window you can relaunch it at any time during the scan by opening a webbrowser and entering the URL 127.0.0.1:<dashboardClientPort> , where <dashboardClientPort> can be found from series configuration settings that are printed to the command line. For example, using the settings from above, the URL would be: 127.0.0.1:5558 The top of the dashboard contains a progress bar indicating the % completed of the current scan, as well as additional settings and details. Lower down, the dashboard contains: Head Motion Plot \u00b6 Plot displaying head motion throughout the scan. Head motion is expressed in both absolute displacement ( abs , dark blue) from a fixed reference volume (typically the 4th volume in the series), as well as relative displacement ( rel , light blue) relative to the previous volume. Head motion estimates are based on histogram registration algorithms, and are applied to fMRI data using a similar approach as found in https://github.com/cni/rtfmri/blob/master/rtfmri/analyzers.py Processing Time Plot \u00b6 Plot displaying the processing time per volume throughout a scan. You can use this plot to verify that your analyses are successfully keeping pace with the TR of data collection. Pyneal Scanner Log \u00b6 Simple log message area indicating incoming volumes from Pyneal Scanner as they arrive. Results Server Log \u00b6 A log window allowing you to monitor communication between Pyneal (specifically, the results server) and any remote End User . Each request for results sent from an End User will appear on the right half of the log window, along with a blue circle and details as to which volume the results are requested from. The response from the results server will be shown immediately below each request, left-aligned within the log window. If the requested results are found, the status circle will be maroon, and you will see the JSON message that was returned to the End User . The JSON message will contain a key:value pair indicating the requested results were found ( \"foundResults\":true ), as well as other key:value pairs containing the results themselves. If the requested results are not found (for instance, if the requested volume has not arrived and been analyzed yet), the status circle will be grey, and you will see a returned JSON message with a single key:value pair indicating that the results were not found ( \"foundResults\":false ) For more info, see sending requests and parsing responses After a real-time scan \u00b6 After the scan has completed, all output files will be found in a unique subdirectory for each scan. Subdirectories will appear within the Output Directory that was specified in the Pyneal setup GUI. Subdirectories follow the naming convention pyneal_### , staring with pyneal_001 for the first scan, and named sequentially thereafter. Note: you can find the full path to the unique series output directory in the command line output for this series: MainThread - Setting: seriesOutputDir: /path/to/outputDir/pyneal_001 The series output directory has the following structure: <seriesOutputDir> \u2514\u2500\u2500 pyneal_001 \u251c\u2500\u2500 pynealLog.log \u251c\u2500\u2500 receivedFunc.nii.gz \u2514\u2500\u2500 results.json Each series will contain the following output files: pynealLog.log - detailed log messages from the current series results.json - JSON formatted file containg all of the analysis results from the current series. (see below on Interpreting the results file for more info) receivedFunc.nii.gz - nifti formatted 4D file containing the series data itself, as received by Pyneal , from the current series Interpreting the results file \u00b6 The results from the analyses computed in real-time will be stored in the output directory in a file named results.json This file will have an entry for every volume in the series, and each entry will contain a nested JSON object that has all of the results for that particular volume. For instance, if the real-time analysis is calculating the average signal within the mask, the results file would look like: { \"0\": {\"average\": 2149.81}, \"1\": {\"average\": 2234.32}, \"2\": {\"average\": 1981.45}, . . . } Note that the top-level keys are volume indices that use a 0-based index. In the above example, we're computing a single result on every volume (i.e. \"average\"). However, if you are using a custom analysis script that is computing multple results on every volume, the same idea holds, and you'll see all of those results for each volume. For instance, if you have a custom analysis script that is computing the mean activation separately in 3 ROIs, the results may look like: { \"0\": { \"roi1_average\": 2149.81, \"roi2_average\": 2519.11, \"roi3_average\": 2543.61 }, \"1\": { \"roi1_average\": 1884.51, \"roi2_average\": 2341.43, \"roi3_average\": 2253.67 }, \"2\": { \"roi1_average\": 2001.76, \"roi2_average\": 2214.23, \"roi3_average\": 2877.17 }, . . . } Pyneal subcomponents \u00b6 Under the hood, Pyneal uses multiple threads to manage the various subcomponents and handle communication with remote components efficiently. This section will provide a brief overview of relevant threads in order to better understand how Pyneal works, and help with interpreting the content pynealLog.log output files. MainThread \u00b6 The MainThread of Pyneal can be thought of as the backbone, coordinating the various subcomponents and running the main analysis. The MainThread presents the setup GUI, initializes Pyneal based on the user-specified settings, and launches the various subthreads. Once the scan begins, the MainThread iterates through each expected volume in the series. It checks in with the scanReceiver to see which volumes have arrived. As soon as each volume is available, it will run the specified analyses, and send the results to the resultsServer . scanReceiver \u00b6 The scanReceiver runs on Thread-1 . Once the scanReceiver is launched by the MainThread , it opens a socket connection to Pyneal Scanner and waits for the scan to begin. Once the scan begins, Pyneal Scanner sends reformatted 3D volumes (and header information) over the socket connection. The scanReceiver receives this data, converts the byte stream into an array, and adds this data to the 4D matrix for the series (using the header information to determine the appropriate volume index). resultsServer \u00b6 The resultsServer runs on Thread-2 . During a scan, the resultsServer will listen for incoming requests from a remote End User . Each time a request is received, the resultsServer will check to see if the requested volume has arrived and been analyzed. If so, it will return a response containing the results for that volume. If not, it will return a response indicating that it could not find results for that volume. For more info, see sending requests and parsing responses","title":"Pyneal"},{"location":"pyneal/#pyneal","text":"First step, make sure you've followed the instructions at setup: Pyneal to configure Pyneal to your environment.","title":"Pyneal"},{"location":"pyneal/#directory-structure","text":"The Pyneal directory has the following structure: \u251c\u2500\u2500 pyneal \u2502 \u251c\u2500\u2500 LICENSE.txt \u2502 \u251c\u2500\u2500 README.md \u2502 \u251c\u2500\u2500 pyneal.py \u2502 \u251c\u2500\u2500 pyneal_scanner \u2502 \u251c\u2500\u2500 requirements.txt \u2502 \u251c\u2500\u2500 src \u2502 \u2514\u2500\u2500 utils The root level of the directory contains basic commands for launching Pyneal ( pyneal.py ), as well as the license and README files. Subdirectories : pyneal_scanner/ : Pyneal Scanner directory; see Overview: Pyneal Scanner src/ : Source code for the GUIs and submodules that support Pyneal . utils/ : Additional utilities that you may find helpful in configuring Pyneal to your experiment. This directory is worth unpacking further: \u251c\u2500\u2500 pyneal \u2502 ... \u2502 \u2514\u2500\u2500 utils \u2502 \u251c\u2500\u2500 MNI_templates \u2502 \u251c\u2500\u2500 createMask.py \u2502 \u251c\u2500\u2500 customAnalyses \u2502 \u251c\u2500\u2500 masks \u2502 \u251c\u2500\u2500 mkDummyMask.py \u2502 \u2514\u2500\u2500 simulation Mask Utilities: createMask.py will launch the Create Mask tool, which will allow you to transform a MNI space mask down to the functional space of the current subject; see Create Mask MNI_templates/ : reference MNI template volumes to use with createMask.py masks/ : a sampling of MNI space anatomical masks that you can use with createMask.py . Note that it is also possible to supply your own MNI-space mask. mkDummyMask.py will allow you to quickly create a dummy mask in 3D volume that is whatever dimensions you specify. This is useful for when you may need a mask in a given functional space to test Pyneal but aren't concerned with the results. The resulting mask will be a rectangle positioned in the center of the middle slice of a volume. You specify the overall volume dimensions. Misc Utilities: customAnalyses/ : A custom analysis template that facilitates designing your own customized analysis routines to carry out in a real-time scanning run; see customAnalysis.md simulation/ : Tools for simulating inputs and outputs of Pyneal ; see simulations: Pyneal Simulation Tools","title":"Directory Structure"},{"location":"pyneal/#basic-usage","text":"To launch Pyneal from the analysis computer , open a terminal and navigate to the pyneal directory. From there, type: python pyneal.py usage: pyneal.py [-h] [--noGUI] [-s SETTINGSFILE] optional arguments: -h, --help show this help message and exit --noGUI run in headless mode, no setup GUI. (requires a valid settings file, either supplied here with -s option, or in {pyneal root}/src/GUIs/pynealSetup.yaml) -s SETTINGSFILE, --settingsFile SETTINGSFILE specify the path to a custom settings file This will launch a GUI that will allow you to set up Pyneal for a particular real-time scan. In most cases, this is how you'll want to configure Pyneal for the current session. However, as shown above, you also have the option to supply your own custom configuration file, or run in headless mode without showing the setup GUI. After you launch Pyneal , a dashboard will appear (if specified during configuration) that allows you to monitor the progress of your scan. Additional log messages will appear in the terminal throughout the scan. See below for a more detailed description of how to prepare for a real-time scan , what's going on during a real-time scan , and what type of data is available after a real-time scan","title":"Basic Usage"},{"location":"pyneal/#preparing-for-a-real-time-scan","text":"","title":"Preparing for a real-time scan"},{"location":"pyneal/#network-settings","text":"By this point, if you have followed the setup instructions for both Pyneal Scanner and Pyneal you will have delegated one machine to be the scanner computer and one machine to be the analysis computer . It is imperative that Pyneal Scanner and Pyneal can communicate with one another during a scan. That is, the scanner computer must be able to connect to the analysis computer over an available network port. Different scanning environments will have different configurations (see setup: setting up your network for more details). Regardless of your setup, make sure you know the IP address you will use for Pyneal , as well as the port numbers to use for communication with Pyneal Scanner and any remote End User .","title":"Network settings"},{"location":"pyneal/#creating-masks","text":"Pyneal requires the user to supply a mask that will specify which voxels to include during the real-time analysis. This mask can take any form you want, with the caveat that it must be in the same space (i.e. voxel size, slice dimensions, and orientation) as the incoming functional data throughout the real-time scan. One way to ensure this would to collect a short localizer scan at the beginning of the session that has the desired scan parameters, and use this data to create/register/align your mask for the subsequent real-time runs. Examples: Mask from functional ROI : You could include a mask that represents voxels with significant task-induced activation from the current subject. To do so, include a quick localizer task at the beginning of your session that you can access offline (for instance, by using the getSeries.py tool in Pyneal Scanner ) and analyze. Threshold and/or binarize the resulting statistical maps as appropriate, and create a funtional ROI mask file. Mask from anatomical ROI : You can create a subject-specific anatomical ROI mask by transforming a preselected MNI space mask to the participant's functional space. Pyneal includes an automated tool to assist in this process. See Additional Tools: Creating Masks . Your chosen source MNI mask can be a binary anatomical mask or a weighted probablistic mask. When you load the functional space mask into Pyneal you will have the option of preserving voxel weights.","title":"Creating Masks"},{"location":"pyneal/#choosing-analyses","text":"Prior to beginning a real-time project, determine what type of analysis is most appropriate to your project, and whether the built-in analysis routines will suffice or whether it'd be more appropriate to use a custom analysis script. Pyneal has built-in analysis tools that can compute simple descriptive summaries (e.g. mean, median) from a single ROI. However, by using a custom analysis script, you can develop unique and complex analyses, targeting one or more ROIs, that will execute on every incoming volume during the scan. See Additional Tools: Customized Analyses","title":"Choosing Analyses"},{"location":"pyneal/#running-a-real-time-scan","text":"To launch Pyneal from the analysis computer , open the command line and navigate to the pyneal directory. From the pyneal directory, type: python pyneal.py This will launch the setup GUI, allowing you to enter the appropriate settings for your environment/session. The GUI is discussed below, but note that you can also supply a premade configuration file and/or run Pyneal in headless mode without viewing the setup GUI by following the usage examples: usage: pyneal.py [-h] [--noGUI] [-s SETTINGSFILE] optional arguments: -h, --help show this help message and exit --noGUI run in headless mode, no setup GUI. (requires a valid settings file, either supplied here with -s option, or in {pyneal root}/src/GUIs/pynealSetup.yaml) -s SETTINGSFILE, --settingsFile SETTINGSFILE specify the path to a custom settings file","title":"Running a real-time scan"},{"location":"pyneal/#set-up-gui","text":"Launching the GUI will load the settings from previous run. For running multiple scans in the same session, you may not need to change any settings after the first scan. If you do need to change settings, you can do so manually via each field in the GUI, or you can click Load Settings to load a custom .yaml configuration file. A custom settings file must contain one or more of the required configuration key:value pairs; see Setup: Pyneal for more details on the Configuration Keys . Any configuration keys not specified in the custom settings file will be set using default values. The GUI presents a number of options that can be customized to your project/enviroment:","title":"Set-up GUI"},{"location":"pyneal/#communication","text":"The Communication panel is where you specify the network settings for communication between Pyneal Scanner , Pyneal , and any remote End User . Pyneal Host IP : The IP address of the machine running Pyneal (i.e. the analysis machine ). This is the IP address that Pyneal Scanner will try to connect to, as well as any remote End User that is making requests for results. Pyneal-Scanner Port : The port number over which Pyneal will be listening for incoming data from Pyneal Scanner . Results Server Port : The port number that Pyneal will use to set up the Results Server . Remote machines that wish to retrieve real-time analysis output during a scan can send requests over this port number.","title":"Communication"},{"location":"pyneal/#mask","text":"Specify the path to mask file (Nifti - .nii/.nii.gz) to be used during real-time analysis. During the analysis stage, each incoming 3D volume will be masked to remove non-relevant voxels. The mask must match the dimensions and orientation of incoming functional data (see Creating Masks for Real-time Analysis). If Weighted Mask? is checked, the voxel values will be used as weights and passed along to the analysis stage. For a Custom analysis in which you want to use 2 or more ROIs, you should set your custom analysis script to load the desired ROIs. In that situation, you should choose a mask file here that represents a whole brain mask (see Creating Masks for Real-time Analysis).","title":"Mask"},{"location":"pyneal/#preprocessing","text":"Specify how many timepoints will be in the upcoming series. The other dimensions of the dataset (i.e. slice dimensions, number of slices per vol) will be determined automatically from the incoming data.","title":"Preprocessing"},{"location":"pyneal/#analysis","text":"Choose the analyses you want to carry out during the real-time run Average : Built-in analysis routine. Compute the mean activation over all voxels in the Mask specified above. The results will be stored as a dictionary under the key name average . If the Weighted Mask? option is selected on the Mask panel, a weighted average will be calculated, using voxel values as weights. In this case, the results will be stored in a dictionary under the key name weightedAverage . Median : Built-in analysis routine. Compute the median activation value over all voxels in the Mask specifed above. The results will be stored in a dictionary under the key name median . If the Weighted Mask? option is selected on the Mask panel, a weighted mean will be calculated, using voxel values as weights. (see weightedstats for algorithm). In this case, the results will be stored in a dictionary under the key name weightedMedian . Custom : Load a custom analysis script. The analysis algorithms specified in the script will be executed on every incoming timepoint during the scan. How the results get stored in the results dictionary throughout a scan is up to your particular script (see Custom Analysis Scripts )","title":"Analysis"},{"location":"pyneal/#output","text":"Specify a path to an output directory for the current session . Within this output directory, the results and log files for each new series will be written to unique subdirectories, starting with pyneal_001 for the first series and named sequentially thereafter. Launch Dashboard? : Option for whether to present a dashboard during the real-time scan or not. If selected, the dashboard will launch automatically upon submission. However, if you happen to close it for any reason, you can access it by pointing a web browser to 127.0.0.1:5558 (Note: 5558 is the dashboardClientPort number. To confirm the correct port, check the settings that are printed to the terminal once you hit Submit from the setup GUI (see Command line output below). For more information on using the Dashboard, see Dashboard below).","title":"Output"},{"location":"pyneal/#command-line-output","text":"Once you hit submit, the command line will print a message showing you where log files for the current series will be stored, as well as all of the configuration settings for this series: Logs written to: /path/to/outputDir/pyneal_001/pynealLog.log MainThread - Setting: analysisChoice: Average MainThread - Setting: dashboardClientPort: 5558 MainThread - Setting: dashboardPort: 5557 MainThread - Setting: launchDashboard: True MainThread - Setting: maskFile: /path/to/maskFile.nii.gz MainThread - Setting: maskIsWeighted: False MainThread - Setting: numTimepts: 60 MainThread - Setting: outputPath: /path/to/outputDir MainThread - Setting: pynealHost: 127.0.0.1 MainThread - Setting: pynealScannerPort: 5555 MainThread - Setting: resultsServerPort: 5556 MainThread - Setting: seriesOutputDir: /path/to/outputDir/pyneal_001 At the end of the message, you'll see a status indicator for the various subcomponents of Pyneal : MainThread - ScanReceiver Server alive and listening.... Waiting for connection from pyneal_scanner MainThread - Results Server alive and listening.... If everything is working properly, it'll say that both the ScanReceiver Server and Results Server are alive and listening. (for more information about what these components are doing, see Pyneal Subcomponents below). You should also see a message indicating that Pyneal is waiting to connect to Pyneal Scanner . Once you launch Pyneal Scanner , this message will update to: Received message: hello from pyneal_scanner Throughout the scan, the terminal will update with status and log messages reporting on-going processes. In addition to the command line output, you can monitor the status of the scan from the web-based dashboard.","title":"Command line output"},{"location":"pyneal/#dashboard","text":"The dashboard will launch automatically, but if you happen to close the window you can relaunch it at any time during the scan by opening a webbrowser and entering the URL 127.0.0.1:<dashboardClientPort> , where <dashboardClientPort> can be found from series configuration settings that are printed to the command line. For example, using the settings from above, the URL would be: 127.0.0.1:5558 The top of the dashboard contains a progress bar indicating the % completed of the current scan, as well as additional settings and details. Lower down, the dashboard contains:","title":"Dashboard"},{"location":"pyneal/#head-motion-plot","text":"Plot displaying head motion throughout the scan. Head motion is expressed in both absolute displacement ( abs , dark blue) from a fixed reference volume (typically the 4th volume in the series), as well as relative displacement ( rel , light blue) relative to the previous volume. Head motion estimates are based on histogram registration algorithms, and are applied to fMRI data using a similar approach as found in https://github.com/cni/rtfmri/blob/master/rtfmri/analyzers.py","title":"Head Motion Plot"},{"location":"pyneal/#processing-time-plot","text":"Plot displaying the processing time per volume throughout a scan. You can use this plot to verify that your analyses are successfully keeping pace with the TR of data collection.","title":"Processing Time Plot"},{"location":"pyneal/#pyneal-scanner-log","text":"Simple log message area indicating incoming volumes from Pyneal Scanner as they arrive.","title":"Pyneal Scanner Log"},{"location":"pyneal/#results-server-log","text":"A log window allowing you to monitor communication between Pyneal (specifically, the results server) and any remote End User . Each request for results sent from an End User will appear on the right half of the log window, along with a blue circle and details as to which volume the results are requested from. The response from the results server will be shown immediately below each request, left-aligned within the log window. If the requested results are found, the status circle will be maroon, and you will see the JSON message that was returned to the End User . The JSON message will contain a key:value pair indicating the requested results were found ( \"foundResults\":true ), as well as other key:value pairs containing the results themselves. If the requested results are not found (for instance, if the requested volume has not arrived and been analyzed yet), the status circle will be grey, and you will see a returned JSON message with a single key:value pair indicating that the results were not found ( \"foundResults\":false ) For more info, see sending requests and parsing responses","title":"Results Server Log"},{"location":"pyneal/#after-a-real-time-scan","text":"After the scan has completed, all output files will be found in a unique subdirectory for each scan. Subdirectories will appear within the Output Directory that was specified in the Pyneal setup GUI. Subdirectories follow the naming convention pyneal_### , staring with pyneal_001 for the first scan, and named sequentially thereafter. Note: you can find the full path to the unique series output directory in the command line output for this series: MainThread - Setting: seriesOutputDir: /path/to/outputDir/pyneal_001 The series output directory has the following structure: <seriesOutputDir> \u2514\u2500\u2500 pyneal_001 \u251c\u2500\u2500 pynealLog.log \u251c\u2500\u2500 receivedFunc.nii.gz \u2514\u2500\u2500 results.json Each series will contain the following output files: pynealLog.log - detailed log messages from the current series results.json - JSON formatted file containg all of the analysis results from the current series. (see below on Interpreting the results file for more info) receivedFunc.nii.gz - nifti formatted 4D file containing the series data itself, as received by Pyneal , from the current series","title":"After a real-time scan"},{"location":"pyneal/#interpreting-the-results-file","text":"The results from the analyses computed in real-time will be stored in the output directory in a file named results.json This file will have an entry for every volume in the series, and each entry will contain a nested JSON object that has all of the results for that particular volume. For instance, if the real-time analysis is calculating the average signal within the mask, the results file would look like: { \"0\": {\"average\": 2149.81}, \"1\": {\"average\": 2234.32}, \"2\": {\"average\": 1981.45}, . . . } Note that the top-level keys are volume indices that use a 0-based index. In the above example, we're computing a single result on every volume (i.e. \"average\"). However, if you are using a custom analysis script that is computing multple results on every volume, the same idea holds, and you'll see all of those results for each volume. For instance, if you have a custom analysis script that is computing the mean activation separately in 3 ROIs, the results may look like: { \"0\": { \"roi1_average\": 2149.81, \"roi2_average\": 2519.11, \"roi3_average\": 2543.61 }, \"1\": { \"roi1_average\": 1884.51, \"roi2_average\": 2341.43, \"roi3_average\": 2253.67 }, \"2\": { \"roi1_average\": 2001.76, \"roi2_average\": 2214.23, \"roi3_average\": 2877.17 }, . . . }","title":"Interpreting the results file"},{"location":"pyneal/#pyneal-subcomponents","text":"Under the hood, Pyneal uses multiple threads to manage the various subcomponents and handle communication with remote components efficiently. This section will provide a brief overview of relevant threads in order to better understand how Pyneal works, and help with interpreting the content pynealLog.log output files.","title":"Pyneal subcomponents"},{"location":"pyneal/#mainthread","text":"The MainThread of Pyneal can be thought of as the backbone, coordinating the various subcomponents and running the main analysis. The MainThread presents the setup GUI, initializes Pyneal based on the user-specified settings, and launches the various subthreads. Once the scan begins, the MainThread iterates through each expected volume in the series. It checks in with the scanReceiver to see which volumes have arrived. As soon as each volume is available, it will run the specified analyses, and send the results to the resultsServer .","title":"MainThread"},{"location":"pyneal/#scanreceiver","text":"The scanReceiver runs on Thread-1 . Once the scanReceiver is launched by the MainThread , it opens a socket connection to Pyneal Scanner and waits for the scan to begin. Once the scan begins, Pyneal Scanner sends reformatted 3D volumes (and header information) over the socket connection. The scanReceiver receives this data, converts the byte stream into an array, and adds this data to the 4D matrix for the series (using the header information to determine the appropriate volume index).","title":"scanReceiver"},{"location":"pyneal/#resultsserver","text":"The resultsServer runs on Thread-2 . During a scan, the resultsServer will listen for incoming requests from a remote End User . Each time a request is received, the resultsServer will check to see if the requested volume has arrived and been analyzed. If so, it will return a response containing the results for that volume. If not, it will return a response indicating that it could not find results for that volume. For more info, see sending requests and parsing responses","title":"resultsServer"},{"location":"pynealScanner/","text":"Pyneal Scanner \u00b6 First step, make sure you've followed the instructions at setup: Pyneal Scanner to configure Pyneal Scanner to your environment. Directory Structure \u00b6 The Pyneal Scanner directory has the following structure: \u251c\u2500\u2500 pyneal_scanner \u2502 \u251c\u2500\u2500 README.md \u2502 \u251c\u2500\u2500 data \u2502 \u251c\u2500\u2500 getSeries.py \u2502 \u251c\u2500\u2500 listSeries.py \u2502 \u251c\u2500\u2500 pynealScanner.log \u2502 \u251c\u2500\u2500 pynealScanner.py \u2502 \u251c\u2500\u2500 requirements.txt \u2502 \u251c\u2500\u2500 scannerConfig.yaml \u2502 \u251c\u2500\u2500 simulation \u2502 \u2514\u2500\u2500 utils The root level of the directory contains basic commands for launching Pyneal Scanner ( pynealScanner.py ), and accessing information about the current scanning session ( getSeries.py , listSeries.py ). Subdirectories : data/ : Any data that Pyneal Scanner saves to disk during a scanning session. For instance, using getSeries.py to build a nifti-formatted image from the current session will result in that file being written to this directory. simulation/ : Tools for simulating inputs and outputs of Pyneal Scanner . See simulations: Pyneal Scanner Simulation Tools utils/ : General and MRI manufacturer specific tools for settings up a scanning session, monitoring for incoming data during a scan, and processing/sending data to Pyneal throughout a scan. Basic Usage \u00b6 To launch Pyneal Scanner from the scanner computer , open a terminal and navigate to the pyneal_scanner directory. From the pyneal_scanner directory, type: python pynealScanner.py If you have set up Pyneal Scanner correctly, you will see a print out of your settings, info about any existing series directories in the scannerBaseDir path, and a message that Pyneal Scanner is attempting to connect to Pyneal over the specified pynealSocket : =============== SCANNER SETTINGS: pynealSocketHost: 127.0.0.1 pynealSocketPort: 5555 scannerBaseDir: /path/to/scanner/baseDir scannerMake: GE ============ Session Dir: /path/to/scanner/baseDir/p1/e666 Series Dirs: s1923 23.6 MB 5 min, 13 s ago s1925 26.2 MB 1 min, 10 s ago MainThread - Connecting to pynealSocket... Once you launch Pyneal on the analysis computer , you will see a confirmation that Pyneal Scanner has connected to Pyneal , and is now waiting for new data to arrive from the scanner: MainThread - pynealSocket connected MainThread - Waiting for new seriesDir... How it works \u00b6 Behind the scenes, Pyneal Scanner is running two separate threads. One thread is dedicated to monitoring the specifed directory for new data to appear. Whenever new data arrives, it places it in a queue. The 2nd thread is responsible for pulling data off of that queue, preprocessing it to convert to a standardized format, and then sending the reformatted data to Pyneal over a socket connection (defined by pynealSocketHost and pynealSocketPort in the configuration file). Depending on which type of scanner you are using, the directory structure for where new data will appear, and the format that it will appear in, can differ drastically. Pyneal Scanner comes with utilities designed to handle the directory structures and formats of 3 different scanner manufacturers: GE , Philips , and Siemens . Directory structures and data formats by scanner make \u00b6 Pyneal Scanner is designed to handle the standard data formats used across the 3 dominant scanner manufacturers, GE , Philips , and Siemens . This section will provide details on the directory structures and data formats across each in order to help make sure you configure Pyneal Scanner correctly. GE \u00b6 expected data format : dicom files, one file per slice. Each dicom file must contain the following tags: Columns ImagesInAcquisition ImageOrientationPatient ImagePositionPatient InStackPositionNumber InstanceNumber MRAcquisitionType NumberOfTemporalPositions PixelSpacing Rows SliceThickness expected directory structure : new dicom files are written to a directory on the scanner console. The path to that directory can be broken apart as: [scannerBaseDir]/[sessionDir]/[seriesDir] , where [scannerBaseDir] : path that remains constant across all scans [sessionDir] : directories that can change from session to session, named like p###/e### where the specific # values are unknown in advance. [seriesDir] : series specific directory named like s### where the specific # values are unknown in advance. Each new scan during a given exam session will be assigned a unique s### dir. To figure out the sessionDir and seriesDir for the current scan session, see the listSeries command below. Philips \u00b6 expected data format : new PAR/REC file pairs, where each file pair represents a 3D volume. expected directory structure : Philips scanners have the option to export reconstructed PAR/REC files to a remote directory. The path to that directory can be broken apart as [scannerBaseDir]/[seriesDir] , where [scannerBaseDir] : path to remote directory that remains constant across all scans [seriesDir] : series specific directory named like 0### , where the directory name is a 4-character number (zero padded as necessary) that increases sequentially with each new series. There is a unique series directory for each scan. Siemens \u00b6 expected data format : dicom mosaic files, where each file represents all slices from a 3D volume, arranged in mosaic format. File names are expected to follow a pattern like ###_######_######.dcm , where the 2nd field represents the series number, and the 3rd field represents the volume number. expected directory structure : Siemens scanners have the option to export reconstructed dicom mosaic files to a remote directory. The path to that directory can be refered to as [scannerBaseDir] The [scannerBaseDir] will contain all of the volume files for all series in a given scan session. Sending data to Pyneal \u00b6 During a scan, Pyneal Scanner will automatically send data to Pyneal over a socket connection (defined by pynealSocketHost and pynealSocketPort in the configuration file). Regardless of how the data is formatted coming off of the scanner (see Directory structures and data formats by scanner make above), Pyneal Scanner will convert everything to a standardized format before sending to Pyneal . Specifically, Pyneal Scanner will send data as 3D volumes. Each transmission actually takes place in 2 waves: First, a JSON header that contains metadata about the current volume, including fields for: volIdx - volume index (0-based) of the current volume dtype - datatype of the volume array shape - dimensions of the volume array affine - affine transformation that will convert the volume array to RAS+ orientation (see Image Orientation for more info) Second, the data array for the current volume. Pyneal will use information in the header message to rebuild the volume array, and carry out all subsequent preprocessing and analysis steps. Additional commands \u00b6 The pyneal_scanner directory also contains a couple of other commands that may be useful during a real-time session listSeries \u00b6 location: pyneal_scanner/listSeries.py usage: python listSeries.py listSeries.py will print to the screen a list of all of the series for the current session. Each series will include information like the relevant paths, directory/file sizes, and creation dates. In the case of GE scanners, this will also report the p###/e### parent directories (i.e. the sessionDir ) of new series directories. getSeries \u00b6 location: pyneal_scanner/getSeries.py usage: python getSeries.py getSeries.py will build a nifti file from a selected series from the current session. When called, it will print a list of all series for the current session, and prompt you to select one. You will also be prompted to specify an 'output prefix' that will be used to name the output file. You can select series that correspond to either 3D structural series or 4D functional series. The selected series will be converted to a single nifti file, and saved as: pyneal_scanner/data/<output prefix>_<seriesName>.nii.gz This tool is useful if you need to retrieve data during a session (for example, a localizer run that will be analyzed to create ROIs for the real-time runs).","title":"Pyneal Scanner"},{"location":"pynealScanner/#pyneal-scanner","text":"First step, make sure you've followed the instructions at setup: Pyneal Scanner to configure Pyneal Scanner to your environment.","title":"Pyneal Scanner"},{"location":"pynealScanner/#directory-structure","text":"The Pyneal Scanner directory has the following structure: \u251c\u2500\u2500 pyneal_scanner \u2502 \u251c\u2500\u2500 README.md \u2502 \u251c\u2500\u2500 data \u2502 \u251c\u2500\u2500 getSeries.py \u2502 \u251c\u2500\u2500 listSeries.py \u2502 \u251c\u2500\u2500 pynealScanner.log \u2502 \u251c\u2500\u2500 pynealScanner.py \u2502 \u251c\u2500\u2500 requirements.txt \u2502 \u251c\u2500\u2500 scannerConfig.yaml \u2502 \u251c\u2500\u2500 simulation \u2502 \u2514\u2500\u2500 utils The root level of the directory contains basic commands for launching Pyneal Scanner ( pynealScanner.py ), and accessing information about the current scanning session ( getSeries.py , listSeries.py ). Subdirectories : data/ : Any data that Pyneal Scanner saves to disk during a scanning session. For instance, using getSeries.py to build a nifti-formatted image from the current session will result in that file being written to this directory. simulation/ : Tools for simulating inputs and outputs of Pyneal Scanner . See simulations: Pyneal Scanner Simulation Tools utils/ : General and MRI manufacturer specific tools for settings up a scanning session, monitoring for incoming data during a scan, and processing/sending data to Pyneal throughout a scan.","title":"Directory Structure"},{"location":"pynealScanner/#basic-usage","text":"To launch Pyneal Scanner from the scanner computer , open a terminal and navigate to the pyneal_scanner directory. From the pyneal_scanner directory, type: python pynealScanner.py If you have set up Pyneal Scanner correctly, you will see a print out of your settings, info about any existing series directories in the scannerBaseDir path, and a message that Pyneal Scanner is attempting to connect to Pyneal over the specified pynealSocket : =============== SCANNER SETTINGS: pynealSocketHost: 127.0.0.1 pynealSocketPort: 5555 scannerBaseDir: /path/to/scanner/baseDir scannerMake: GE ============ Session Dir: /path/to/scanner/baseDir/p1/e666 Series Dirs: s1923 23.6 MB 5 min, 13 s ago s1925 26.2 MB 1 min, 10 s ago MainThread - Connecting to pynealSocket... Once you launch Pyneal on the analysis computer , you will see a confirmation that Pyneal Scanner has connected to Pyneal , and is now waiting for new data to arrive from the scanner: MainThread - pynealSocket connected MainThread - Waiting for new seriesDir...","title":"Basic Usage"},{"location":"pynealScanner/#how-it-works","text":"Behind the scenes, Pyneal Scanner is running two separate threads. One thread is dedicated to monitoring the specifed directory for new data to appear. Whenever new data arrives, it places it in a queue. The 2nd thread is responsible for pulling data off of that queue, preprocessing it to convert to a standardized format, and then sending the reformatted data to Pyneal over a socket connection (defined by pynealSocketHost and pynealSocketPort in the configuration file). Depending on which type of scanner you are using, the directory structure for where new data will appear, and the format that it will appear in, can differ drastically. Pyneal Scanner comes with utilities designed to handle the directory structures and formats of 3 different scanner manufacturers: GE , Philips , and Siemens .","title":"How it works"},{"location":"pynealScanner/#directory-structures-and-data-formats-by-scanner-make","text":"Pyneal Scanner is designed to handle the standard data formats used across the 3 dominant scanner manufacturers, GE , Philips , and Siemens . This section will provide details on the directory structures and data formats across each in order to help make sure you configure Pyneal Scanner correctly.","title":"Directory structures and data formats by scanner make"},{"location":"pynealScanner/#ge","text":"expected data format : dicom files, one file per slice. Each dicom file must contain the following tags: Columns ImagesInAcquisition ImageOrientationPatient ImagePositionPatient InStackPositionNumber InstanceNumber MRAcquisitionType NumberOfTemporalPositions PixelSpacing Rows SliceThickness expected directory structure : new dicom files are written to a directory on the scanner console. The path to that directory can be broken apart as: [scannerBaseDir]/[sessionDir]/[seriesDir] , where [scannerBaseDir] : path that remains constant across all scans [sessionDir] : directories that can change from session to session, named like p###/e### where the specific # values are unknown in advance. [seriesDir] : series specific directory named like s### where the specific # values are unknown in advance. Each new scan during a given exam session will be assigned a unique s### dir. To figure out the sessionDir and seriesDir for the current scan session, see the listSeries command below.","title":"GE"},{"location":"pynealScanner/#philips","text":"expected data format : new PAR/REC file pairs, where each file pair represents a 3D volume. expected directory structure : Philips scanners have the option to export reconstructed PAR/REC files to a remote directory. The path to that directory can be broken apart as [scannerBaseDir]/[seriesDir] , where [scannerBaseDir] : path to remote directory that remains constant across all scans [seriesDir] : series specific directory named like 0### , where the directory name is a 4-character number (zero padded as necessary) that increases sequentially with each new series. There is a unique series directory for each scan.","title":"Philips"},{"location":"pynealScanner/#siemens","text":"expected data format : dicom mosaic files, where each file represents all slices from a 3D volume, arranged in mosaic format. File names are expected to follow a pattern like ###_######_######.dcm , where the 2nd field represents the series number, and the 3rd field represents the volume number. expected directory structure : Siemens scanners have the option to export reconstructed dicom mosaic files to a remote directory. The path to that directory can be refered to as [scannerBaseDir] The [scannerBaseDir] will contain all of the volume files for all series in a given scan session.","title":"Siemens"},{"location":"pynealScanner/#sending-data-to-pyneal","text":"During a scan, Pyneal Scanner will automatically send data to Pyneal over a socket connection (defined by pynealSocketHost and pynealSocketPort in the configuration file). Regardless of how the data is formatted coming off of the scanner (see Directory structures and data formats by scanner make above), Pyneal Scanner will convert everything to a standardized format before sending to Pyneal . Specifically, Pyneal Scanner will send data as 3D volumes. Each transmission actually takes place in 2 waves: First, a JSON header that contains metadata about the current volume, including fields for: volIdx - volume index (0-based) of the current volume dtype - datatype of the volume array shape - dimensions of the volume array affine - affine transformation that will convert the volume array to RAS+ orientation (see Image Orientation for more info) Second, the data array for the current volume. Pyneal will use information in the header message to rebuild the volume array, and carry out all subsequent preprocessing and analysis steps.","title":"Sending data to Pyneal"},{"location":"pynealScanner/#additional-commands","text":"The pyneal_scanner directory also contains a couple of other commands that may be useful during a real-time session","title":"Additional commands"},{"location":"pynealScanner/#listseries","text":"location: pyneal_scanner/listSeries.py usage: python listSeries.py listSeries.py will print to the screen a list of all of the series for the current session. Each series will include information like the relevant paths, directory/file sizes, and creation dates. In the case of GE scanners, this will also report the p###/e### parent directories (i.e. the sessionDir ) of new series directories.","title":"listSeries"},{"location":"pynealScanner/#getseries","text":"location: pyneal_scanner/getSeries.py usage: python getSeries.py getSeries.py will build a nifti file from a selected series from the current session. When called, it will print a list of all series for the current session, and prompt you to select one. You will also be prompted to specify an 'output prefix' that will be used to name the output file. You can select series that correspond to either 3D structural series or 4D functional series. The selected series will be converted to a single nifti file, and saved as: pyneal_scanner/data/<output prefix>_<seriesName>.nii.gz This tool is useful if you need to retrieve data during a session (for example, a localizer run that will be analyzed to create ROIs for the real-time runs).","title":"getSeries"},{"location":"quickOverview/","text":"Quick Overview \u00b6 This section will provide a quick overview of running a scan with Pyneal. The aim is to familiarize you with the interface and commands you would use during a scan session, without getting lost in the details about what is happening underneath the hood. For a more in-depth discussion of the main components, see Pyneal Scanner (detailed) and Pyneal (detailed) . Data flow \u00b6 This schematic gives a very broad overview of the path that data follows throughout a real-time scan with Pyneal Once the scan begins, raw images are collected by Pyneal Scanner , and then converted and reoriented to a standardized format (see image orientation for more info). Pyneal Scanner exports converted 3D volumes to Pyneal . Pyneal receives 3D volumes, and concatenates them into a 4D volume over time throughout the scan. With every new 3D volume that arrives, Pyneal will preprocess the volume, and run any specified analyses. The analysis results for each volume are stored on a separate server, which listens for requests from remote end users or devices throughout the scan (see requesting results for more info). Anytime a request is received, the server checks to see if that volume has been processed yet. If so, it returns the results; if not, it sends a message saying that volume has not been processed yet Pyneal Scanner \u00b6 First step, make sure you've followed the instructions at setup: Pyneal Scanner to configure Pyneal Scanner to your environment. To launch Pyneal Scanner from the scanner computer , open the command line and navigate to the pyneal_scanner directory. From the pyneal_scanner directory, type: python pynealScanner.py If you have set up Pyneal Scanner correctly, you will see a print out of your settings, info about any existing series directories in the scannerBaseDir path, and a message that Pyneal Scanner is attempting to connect to Pyneal over the specified pynealSocket : =============== SCANNER SETTINGS: pynealSocketHost: 127.0.0.1 pynealSocketPort: 5555 scannerBaseDir: /path/to/scanner/baseDir scannerMake: GE ============ Session Dir: /path/to/scanner/baseDir/p1/e666 Series Dirs: s1923 23.6 MB 5 min, 13 s ago s1925 26.2 MB 1 min, 10 s ago MainThread - Connecting to pynealSocket... Once you launch Pyneal on the analysis computer , you will see a confirmation that Pyneal Scanner has connected to Pyneal , and is now waiting for new data to arrive from the scanner: MainThread - pynealSocket connected MainThread - Waiting for new seriesDir... For a more detailed look at how Pyneal Scanner works, see Pyneal Scanner (detailed) Pyneal \u00b6 First step, make sure you've followed the instructions at setup: Pyneal to configure Pyneal to your environment. To launch Pyneal from the analysis computer , open the command line and navigate to the pyneal directory. From the pyneal directory, type: python pyneal.py The GUI will appear, allowing you to enter the appropriate settings for your environment/session: Once you hit submit, the command line will print a message showing you where log files for the current series will be stored, as well as all of the configuration settings for this series: Logs written to: /path/to/outputDir/pyneal_001/pynealLog.log MainThread - Setting: analysisChoice: Average MainThread - Setting: dashboardClientPort: 5558 MainThread - Setting: dashboardPort: 5557 MainThread - Setting: launchDashboard: True MainThread - Setting: maskFile: /path/to/maskFile.nii.gz MainThread - Setting: maskIsWeighted: False MainThread - Setting: numTimepts: 60 MainThread - Setting: outputPath: /path/to/outputDir MainThread - Setting: pynealHost: 127.0.0.1 MainThread - Setting: pynealScannerPort: 5555 MainThread - Setting: resultsServerPort: 5556 MainThread - Setting: seriesOutputDir: /path/to/outputDir/pyneal_001 At the end of the message, you'll see a status indicator for the various subcomponents of Pyneal : MainThread - ScanReceiver Server alive and listening.... Waiting for connection from pyneal_scanner MainThread - Results Server alive and listening.... If everything is working properly, it'll say that both the ScanReceiver Server and Results Server are alive and listening. (for more information about what these components are doing, see Pyneal (detailed) . You should also see a message indicating that Pyneal is waiting to connect to Pyneal Scanner . Once you launch Pyneal Scanner , this message will update to: Received message: hello from pyneal_scanner In addition to the command line output, you can monitor the status of the scan from the web-based dashboard. The dashboard will launch automatically, but if you happen to close the window you can relaunch it at any time during the scan by opening a webbrowser and entering the URL 127.0.0.1:<dashboardClientPort> , where <dashboardClientPort> can be found from series configuration settings that are printed to the command line. For example, using the settings from above, the URL would be: 127.0.0.1:5558 The dashboard contains: progress bar indicating the % completed of the current scan head motion plot showing relative (to ref volume) and absolute displacement (in mm) scanner communication log showing volume indices as they arrive from the scanner processing time plot showing processing time per volume (in sec) request log showing incoming requests for results and each corresponding reply After the scan has completed, the seriesOutputDir will contain the folling output files: pynealLog.log - detailed log messages from the current scan results.json - JSON formatted file containg all of the analysis results from the current scan receivedFunc.nii.gz - nifti formatted 4D file containing the series data itself, as received by Pyneal , from the current scan For a more detailed look at how Pyneal works, see Pyneal (detailed) End User \u00b6 We refer to any component that requests results from Pyneal during a scan as an End User . For instance, a potential End User could be task presentation software that periodically makes requests for analysis results in order to update a neurofeedback display for the participant. For more details about how to format requests and parse responses, see Requesting Results","title":"Quick Overview"},{"location":"quickOverview/#quick-overview","text":"This section will provide a quick overview of running a scan with Pyneal. The aim is to familiarize you with the interface and commands you would use during a scan session, without getting lost in the details about what is happening underneath the hood. For a more in-depth discussion of the main components, see Pyneal Scanner (detailed) and Pyneal (detailed) .","title":"Quick Overview"},{"location":"quickOverview/#data-flow","text":"This schematic gives a very broad overview of the path that data follows throughout a real-time scan with Pyneal Once the scan begins, raw images are collected by Pyneal Scanner , and then converted and reoriented to a standardized format (see image orientation for more info). Pyneal Scanner exports converted 3D volumes to Pyneal . Pyneal receives 3D volumes, and concatenates them into a 4D volume over time throughout the scan. With every new 3D volume that arrives, Pyneal will preprocess the volume, and run any specified analyses. The analysis results for each volume are stored on a separate server, which listens for requests from remote end users or devices throughout the scan (see requesting results for more info). Anytime a request is received, the server checks to see if that volume has been processed yet. If so, it returns the results; if not, it sends a message saying that volume has not been processed yet","title":"Data flow"},{"location":"quickOverview/#pyneal-scanner","text":"First step, make sure you've followed the instructions at setup: Pyneal Scanner to configure Pyneal Scanner to your environment. To launch Pyneal Scanner from the scanner computer , open the command line and navigate to the pyneal_scanner directory. From the pyneal_scanner directory, type: python pynealScanner.py If you have set up Pyneal Scanner correctly, you will see a print out of your settings, info about any existing series directories in the scannerBaseDir path, and a message that Pyneal Scanner is attempting to connect to Pyneal over the specified pynealSocket : =============== SCANNER SETTINGS: pynealSocketHost: 127.0.0.1 pynealSocketPort: 5555 scannerBaseDir: /path/to/scanner/baseDir scannerMake: GE ============ Session Dir: /path/to/scanner/baseDir/p1/e666 Series Dirs: s1923 23.6 MB 5 min, 13 s ago s1925 26.2 MB 1 min, 10 s ago MainThread - Connecting to pynealSocket... Once you launch Pyneal on the analysis computer , you will see a confirmation that Pyneal Scanner has connected to Pyneal , and is now waiting for new data to arrive from the scanner: MainThread - pynealSocket connected MainThread - Waiting for new seriesDir... For a more detailed look at how Pyneal Scanner works, see Pyneal Scanner (detailed)","title":"Pyneal Scanner"},{"location":"quickOverview/#pyneal","text":"First step, make sure you've followed the instructions at setup: Pyneal to configure Pyneal to your environment. To launch Pyneal from the analysis computer , open the command line and navigate to the pyneal directory. From the pyneal directory, type: python pyneal.py The GUI will appear, allowing you to enter the appropriate settings for your environment/session: Once you hit submit, the command line will print a message showing you where log files for the current series will be stored, as well as all of the configuration settings for this series: Logs written to: /path/to/outputDir/pyneal_001/pynealLog.log MainThread - Setting: analysisChoice: Average MainThread - Setting: dashboardClientPort: 5558 MainThread - Setting: dashboardPort: 5557 MainThread - Setting: launchDashboard: True MainThread - Setting: maskFile: /path/to/maskFile.nii.gz MainThread - Setting: maskIsWeighted: False MainThread - Setting: numTimepts: 60 MainThread - Setting: outputPath: /path/to/outputDir MainThread - Setting: pynealHost: 127.0.0.1 MainThread - Setting: pynealScannerPort: 5555 MainThread - Setting: resultsServerPort: 5556 MainThread - Setting: seriesOutputDir: /path/to/outputDir/pyneal_001 At the end of the message, you'll see a status indicator for the various subcomponents of Pyneal : MainThread - ScanReceiver Server alive and listening.... Waiting for connection from pyneal_scanner MainThread - Results Server alive and listening.... If everything is working properly, it'll say that both the ScanReceiver Server and Results Server are alive and listening. (for more information about what these components are doing, see Pyneal (detailed) . You should also see a message indicating that Pyneal is waiting to connect to Pyneal Scanner . Once you launch Pyneal Scanner , this message will update to: Received message: hello from pyneal_scanner In addition to the command line output, you can monitor the status of the scan from the web-based dashboard. The dashboard will launch automatically, but if you happen to close the window you can relaunch it at any time during the scan by opening a webbrowser and entering the URL 127.0.0.1:<dashboardClientPort> , where <dashboardClientPort> can be found from series configuration settings that are printed to the command line. For example, using the settings from above, the URL would be: 127.0.0.1:5558 The dashboard contains: progress bar indicating the % completed of the current scan head motion plot showing relative (to ref volume) and absolute displacement (in mm) scanner communication log showing volume indices as they arrive from the scanner processing time plot showing processing time per volume (in sec) request log showing incoming requests for results and each corresponding reply After the scan has completed, the seriesOutputDir will contain the folling output files: pynealLog.log - detailed log messages from the current scan results.json - JSON formatted file containg all of the analysis results from the current scan receivedFunc.nii.gz - nifti formatted 4D file containing the series data itself, as received by Pyneal , from the current scan For a more detailed look at how Pyneal works, see Pyneal (detailed)","title":"Pyneal"},{"location":"quickOverview/#end-user","text":"We refer to any component that requests results from Pyneal during a scan as an End User . For instance, a potential End User could be task presentation software that periodically makes requests for analysis results in order to update a neurofeedback display for the participant. For more details about how to format requests and parse responses, see Requesting Results","title":"End User"},{"location":"setup/","text":"Setup \u00b6 The set-up instructions are broken down by Pyneal Scanner and Pyneal . If you haven't already, follow the installation instructions to configure your environment, and read the section on definitions , as those definitions are used throughout these instructions. After you have finished setting up Pyneal Scanner and Pyneal using the instructions below, you can verify your install using various simulation tools . These tools are helpful in troubleshooting any issues you may run into during install/setup. Setting up your network \u00b6 Pyneal communicates with other components in the pipeline, like Pyneal Scanner and any End User , via TCP/IP sockets. These are network communication portals very similar to how a web browser communicates with websites hosted on remote servers. For this type of commnunication, it's useful to think of one end as the server , listening for and responding to requests from remote clients . Clients connect to the server by specifying the server's IP address and a specific port number. In our case, Pyneal (running on the analysis computer ) is always playing the role of the server . The IP address you use for Pyneal will depend on how the rest of your environment is set up: If all components are running on the same machine, you can use the generic loopback IP address 127.0.0.1 . Put another way, you can use this address if and only if Pyneal Scanner and Pyneal and any End User that requests data are all running from the same physical machine. This might be the case, for instance, if you are testing/debugging certain steps of your analysis (see simulation tools ) In all other cases, you have to figure out the IP address assigned to the analysis computer running Pyneal . Pyneal will use one available port number for communication with Pyneal Scanner , and an additional port number dedicated for communication with remote end users or devices. You can manually specify the port number to use when setting up Pyneal If you don't know which port numbers to use, check with a network administrator, or simply try choosing ones in the range of 1024-49151. If you happen to choose a port number that is unavailable, Pyneal will return an error message. In that event, try a different number. Pyneal Scanner \u00b6 When you download Pyneal everything is contained in the root pyneal directory. From the pyneal directory, copy the pyneal_scanner directory to a new location on the scanner computer . On the scanner computer , launch Pyneal Scanner from the command line by navigating to the pyneal_scanner directory and running pynealScanner.py cd pyneal_scanner python pynealScanner.py Pyneal Scanner uses a set of configuration parameters that you can modify to fit your environment. These are stored in file named scannerConfig.yaml in the pyneal_scanner directory. If you're running Pyneal Scanner for the first time, this file won't exist yet. You can either create this file manually, or wait until pynealScanner.py prompts you to fill in any missing configuration values from the command line. Any values you enter from the command line will be saved in a new scannerConfig.yaml file. The scannerConfig.yaml file allows you to customize Pyneal Scanner to your scanning environment. The file contains just a few parameters stored as key:value pairs: scannerBaseDir: /path/to/new/scans scannerMake: GE pynealSocketHost: 127.0.0.1 pynealSocketPort: '9999' Configuration Keys : scannerBaseDir : The fixed portion of the directory path to where new reconstructed images will be appear during a scan. That is, the part that remains constant from scan to scan. Knowing what to set this value to can differ according to different scanner manufacturers: GE : During a scan, new slices dicom files are written to a directory on the scanner console. The path to that directory can be broken apart like [scannerBaseDir]/[sessionDir]/[seriesDir] , where [scannerBaseDir] : path that remains constant across all scans [sessionDir] : directories that can change from session to session, named like p###/e### where the specific # values are unknown in advance. [seriesDir] : series specific directory named like s### where the specific # values are unknown in advance. Each new scan during a given exam session will be assigned a unique s### dir. You only need to specify the path to the scannerBaseDir in the scannerConfig.yaml file; Pyneal Scanner will automaticaly find the most recently modified session and series directories and monitor for new series directories to appear. When you run pynealScanner.py you will see a printout in the terminal window about the names, sizes, and modification dates of all series directories in the session directory. Siemens : Siemens scanners can export reconstructed dicom images to a remote directory. The dicom images are mosaic files, one per volume, in which all slices from the volume are arranged in a 2D grid (or, mosaic, if you will). Siemens will export all files from all series during your session to the same directory, which we'll refer to as the scannerBaseDir . Each mosaic file follows a naming pattern that indicates the series number and volume number of the data contained within. The full path to a given mosaic file will look like [scannerBaseDir]/[session#]_[series#]_[volume#].dcm , where [scannerBaseDir] : path to remote directory that will receive all files throughout the session. [session#] : 3 characters representing the current session number, e.g. session 1: 001 [series#] : 6 characters representing the current series number, e.g. series 5: 000005 [volume#] : 6 characters represenitng the current volume number, e.g. volume 4: 000004 Philips : Philips scanners have the option to export reconstructed PAR/REC files to a remote directory. The path to that directory can be broken apart like [scannerBaseDir]/[seriesDir] , where [scannerBaseDir] : path to remote directory that remains constant across all scans [seriesDir] : series specific directory named like #### You only need to specify the path to the scannerBaseDir in the scannerConfig.yaml file; Pyneal Scanner will monitor for new series directories and/or files to appear. scannerMake : Scanner Manufacturer, must be one of GE , Siemens , or Philips (case sensitive) pynealSocketHost : I.P. address of the analysis computer running Pyneal . If the analysis and scanner computers are the same, you can use 127.0.0.1 , otherwise you must specify an I.P. for the analysis computer that is accessible to remote computers. pynealSocketPort : The port number over which Pyneal is listening for incoming data. Pyneal \u00b6 Launch Pyneal from the command line by navigating in to the pyneal directory and running pyneal.py Using Setup GUI \u00b6 The typical way to configure Pyneal for the current session is by using the setup GUI. When you launch pyneal.py a GUI will appear, allowing you to configure Pyneal to the current experiment cd pyneal python pyneal.py Communication : Pyneal Host IP : The IP address of the machine running Pyneal (i.e. the analysis machine ). This is the IP address that Pyneal Scanner will try to connect to, as well as any end user that is making requests for results. Make sure, therefore, that this is an IP address that is accessible to any remote machine that needs it. If you are doing everything locally from the same machine (e.g. testing, running simulations, etc), you can set this to the local host, or loopback address, at 127.0.0.1 . However, in all other situations, you'll probably want this to be the unique IP address assigned to the network card in the analysis machine . Pyneal-Scanner Port : The port number over which Pyneal will be listening for incoming data from Pyneal Scanner . Note that this number should match the port number specified in the pynealSocketPort configuration field of the Pyneal Scanner set up. Results Server Port : The port number that Pyneal will use to set up the Results Server . Remote machines that wish to retrieve real-time analysis output during a scan can send requests over this port number. See Requesting Results Mask : Path to mask file (Nifti - .nii/.nii.gz) to be used during real-time analysis. Each incoming 3D volume will be masked to remove non-relevant voxels. The mask must match the dimensions and orientation of incoming functional data (see Creating Masks for Real-time Analysis). The mask will limit which voxels get passed on to the analysis stage. So, for example: To calculate the Average ROI activation at every timepoint, choose a mask file that represents the target ROI. If Weighted Mask? is checked, the voxel values will be used as weights during the analysis. For a Custom analysis that uses the entire brain volume, choose a mask file that represents a whole brain mask (see Creating Masks for Real-time Analysis). Preprocessing : Set the number of timepoints for the current scan Analysis : Real-time analysis options. The analysis you select will be computed at every timepoint throughout the scan. Average : Compute the average activation at each timepoint across all voxels within the mask Median : Compute the median activation at each timepoint across all voxels within the mask Custom : Choose a custom analysis script. This script will be executed at each new timepoint (see Custom Analysis Scripts ) Output : Choose an output directory to store logs and results from the current session. The output from each new series will be stored as a subdirectory in this directory, named sequentially like 'pyneal_001'. Launch Dashboard : Check this box to launch an interactive dashboard that will allow you to monitor the status of the scan once it begins. Behind the scenes, all of the relevant Pyneal configuration settings are stored as key:value pairs in a file stored at pyneal/src/setupConfig.yaml . (In fact, the GUI simply reads this file at launch to get the previous configuration options, and then overwrites this file with the current GUI options whenever you click submit ). pynealHost: 127.0.0.1 pynealScannerPort: 5555 resultsServerPort: 5556 maskFile: /path/to/mask/file.nii.gz maskIsWeighted: false numTimePts: 60 analysisChoice: Average outputPath: /path/to/store/output launchDashboard: true dashboardPort: 5557 dashboardClientPort: 5558 Configuration Keys : pynealHost : The IP address of the machine running Pyneal (i.e. the analysis machine ). This is the IP address that Pyneal Scanner will try to connect to, as well as any end user that is making requests for results. pynealScannerPort : Port number over which Pyneal will be listening for incoming data resultsServerPort : Port number that Pyneal will use to set up the Results Server maskFile : Path to mask file (Nifti - .nii/.nii.gz) to be used during real-time analysis maskIsWeighted : Voxel values in mask represent weights [true/false] numTimePts : Number of timepoints in current scan analysisChoice : Real-time analysis options [Average/Median/Path to custom analysis file] outputPath : Path to output directory where logs and results will be saved launchDashboard : Launch dashboard to monitor real-time scan [true/false] dashboardPort : Port number over which to launch the dashboard webserver ( NOTE: this key does not appear in the setup GUI) dashboardClientPort : Port number that browsers can use to connect to the dashboard ( NOTE: this key does not appear in the setup GUI) Custom Settings Files \u00b6 You can supply your own custom setting file with the configurate keys described above in one of two ways: via GUI: \u00b6 At the top of the setup GUI you have the option to load a custom settings file. A custom settings should be a .yaml file with values for one or more of the configuration keys above. By loading a custom settings file, the GUI will be populated with whichever configure keys are included; any non-included keys will get their values from the setupConfig.yaml file as normal. The option allows users to create settings files on a per-project basis, and easily configure Pyneal to match the project demands. via command line: \u00b6 Alternatively, you can supply the path to this file at the command line when you launch Pyneal python pyneal.py --settingsFile /Path/to/custom/settingsFile.yaml or python pyneal.py -s /Path/to/custom/settingsFile.yaml Launching Pyneal \"Headless\" \u00b6 If for whatever reason you wish to launch Pyneal without opening the setup GUI, you can run in \"headless\" mode python pyneal.py --noGUI In this case, Pyneal will read the setupConfig.yaml file that was saved locally after the last time you ran Pyneal, and use those settings. Altnernatively, you can also supply the path to a different settings file using the steps described above","title":"Setup"},{"location":"setup/#setup","text":"The set-up instructions are broken down by Pyneal Scanner and Pyneal . If you haven't already, follow the installation instructions to configure your environment, and read the section on definitions , as those definitions are used throughout these instructions. After you have finished setting up Pyneal Scanner and Pyneal using the instructions below, you can verify your install using various simulation tools . These tools are helpful in troubleshooting any issues you may run into during install/setup.","title":"Setup"},{"location":"setup/#setting-up-your-network","text":"Pyneal communicates with other components in the pipeline, like Pyneal Scanner and any End User , via TCP/IP sockets. These are network communication portals very similar to how a web browser communicates with websites hosted on remote servers. For this type of commnunication, it's useful to think of one end as the server , listening for and responding to requests from remote clients . Clients connect to the server by specifying the server's IP address and a specific port number. In our case, Pyneal (running on the analysis computer ) is always playing the role of the server . The IP address you use for Pyneal will depend on how the rest of your environment is set up: If all components are running on the same machine, you can use the generic loopback IP address 127.0.0.1 . Put another way, you can use this address if and only if Pyneal Scanner and Pyneal and any End User that requests data are all running from the same physical machine. This might be the case, for instance, if you are testing/debugging certain steps of your analysis (see simulation tools ) In all other cases, you have to figure out the IP address assigned to the analysis computer running Pyneal . Pyneal will use one available port number for communication with Pyneal Scanner , and an additional port number dedicated for communication with remote end users or devices. You can manually specify the port number to use when setting up Pyneal If you don't know which port numbers to use, check with a network administrator, or simply try choosing ones in the range of 1024-49151. If you happen to choose a port number that is unavailable, Pyneal will return an error message. In that event, try a different number.","title":"Setting up your network"},{"location":"setup/#pyneal-scanner","text":"When you download Pyneal everything is contained in the root pyneal directory. From the pyneal directory, copy the pyneal_scanner directory to a new location on the scanner computer . On the scanner computer , launch Pyneal Scanner from the command line by navigating to the pyneal_scanner directory and running pynealScanner.py cd pyneal_scanner python pynealScanner.py Pyneal Scanner uses a set of configuration parameters that you can modify to fit your environment. These are stored in file named scannerConfig.yaml in the pyneal_scanner directory. If you're running Pyneal Scanner for the first time, this file won't exist yet. You can either create this file manually, or wait until pynealScanner.py prompts you to fill in any missing configuration values from the command line. Any values you enter from the command line will be saved in a new scannerConfig.yaml file. The scannerConfig.yaml file allows you to customize Pyneal Scanner to your scanning environment. The file contains just a few parameters stored as key:value pairs: scannerBaseDir: /path/to/new/scans scannerMake: GE pynealSocketHost: 127.0.0.1 pynealSocketPort: '9999' Configuration Keys : scannerBaseDir : The fixed portion of the directory path to where new reconstructed images will be appear during a scan. That is, the part that remains constant from scan to scan. Knowing what to set this value to can differ according to different scanner manufacturers: GE : During a scan, new slices dicom files are written to a directory on the scanner console. The path to that directory can be broken apart like [scannerBaseDir]/[sessionDir]/[seriesDir] , where [scannerBaseDir] : path that remains constant across all scans [sessionDir] : directories that can change from session to session, named like p###/e### where the specific # values are unknown in advance. [seriesDir] : series specific directory named like s### where the specific # values are unknown in advance. Each new scan during a given exam session will be assigned a unique s### dir. You only need to specify the path to the scannerBaseDir in the scannerConfig.yaml file; Pyneal Scanner will automaticaly find the most recently modified session and series directories and monitor for new series directories to appear. When you run pynealScanner.py you will see a printout in the terminal window about the names, sizes, and modification dates of all series directories in the session directory. Siemens : Siemens scanners can export reconstructed dicom images to a remote directory. The dicom images are mosaic files, one per volume, in which all slices from the volume are arranged in a 2D grid (or, mosaic, if you will). Siemens will export all files from all series during your session to the same directory, which we'll refer to as the scannerBaseDir . Each mosaic file follows a naming pattern that indicates the series number and volume number of the data contained within. The full path to a given mosaic file will look like [scannerBaseDir]/[session#]_[series#]_[volume#].dcm , where [scannerBaseDir] : path to remote directory that will receive all files throughout the session. [session#] : 3 characters representing the current session number, e.g. session 1: 001 [series#] : 6 characters representing the current series number, e.g. series 5: 000005 [volume#] : 6 characters represenitng the current volume number, e.g. volume 4: 000004 Philips : Philips scanners have the option to export reconstructed PAR/REC files to a remote directory. The path to that directory can be broken apart like [scannerBaseDir]/[seriesDir] , where [scannerBaseDir] : path to remote directory that remains constant across all scans [seriesDir] : series specific directory named like #### You only need to specify the path to the scannerBaseDir in the scannerConfig.yaml file; Pyneal Scanner will monitor for new series directories and/or files to appear. scannerMake : Scanner Manufacturer, must be one of GE , Siemens , or Philips (case sensitive) pynealSocketHost : I.P. address of the analysis computer running Pyneal . If the analysis and scanner computers are the same, you can use 127.0.0.1 , otherwise you must specify an I.P. for the analysis computer that is accessible to remote computers. pynealSocketPort : The port number over which Pyneal is listening for incoming data.","title":"Pyneal Scanner"},{"location":"setup/#pyneal","text":"Launch Pyneal from the command line by navigating in to the pyneal directory and running pyneal.py","title":"Pyneal"},{"location":"setup/#using-setup-gui","text":"The typical way to configure Pyneal for the current session is by using the setup GUI. When you launch pyneal.py a GUI will appear, allowing you to configure Pyneal to the current experiment cd pyneal python pyneal.py Communication : Pyneal Host IP : The IP address of the machine running Pyneal (i.e. the analysis machine ). This is the IP address that Pyneal Scanner will try to connect to, as well as any end user that is making requests for results. Make sure, therefore, that this is an IP address that is accessible to any remote machine that needs it. If you are doing everything locally from the same machine (e.g. testing, running simulations, etc), you can set this to the local host, or loopback address, at 127.0.0.1 . However, in all other situations, you'll probably want this to be the unique IP address assigned to the network card in the analysis machine . Pyneal-Scanner Port : The port number over which Pyneal will be listening for incoming data from Pyneal Scanner . Note that this number should match the port number specified in the pynealSocketPort configuration field of the Pyneal Scanner set up. Results Server Port : The port number that Pyneal will use to set up the Results Server . Remote machines that wish to retrieve real-time analysis output during a scan can send requests over this port number. See Requesting Results Mask : Path to mask file (Nifti - .nii/.nii.gz) to be used during real-time analysis. Each incoming 3D volume will be masked to remove non-relevant voxels. The mask must match the dimensions and orientation of incoming functional data (see Creating Masks for Real-time Analysis). The mask will limit which voxels get passed on to the analysis stage. So, for example: To calculate the Average ROI activation at every timepoint, choose a mask file that represents the target ROI. If Weighted Mask? is checked, the voxel values will be used as weights during the analysis. For a Custom analysis that uses the entire brain volume, choose a mask file that represents a whole brain mask (see Creating Masks for Real-time Analysis). Preprocessing : Set the number of timepoints for the current scan Analysis : Real-time analysis options. The analysis you select will be computed at every timepoint throughout the scan. Average : Compute the average activation at each timepoint across all voxels within the mask Median : Compute the median activation at each timepoint across all voxels within the mask Custom : Choose a custom analysis script. This script will be executed at each new timepoint (see Custom Analysis Scripts ) Output : Choose an output directory to store logs and results from the current session. The output from each new series will be stored as a subdirectory in this directory, named sequentially like 'pyneal_001'. Launch Dashboard : Check this box to launch an interactive dashboard that will allow you to monitor the status of the scan once it begins. Behind the scenes, all of the relevant Pyneal configuration settings are stored as key:value pairs in a file stored at pyneal/src/setupConfig.yaml . (In fact, the GUI simply reads this file at launch to get the previous configuration options, and then overwrites this file with the current GUI options whenever you click submit ). pynealHost: 127.0.0.1 pynealScannerPort: 5555 resultsServerPort: 5556 maskFile: /path/to/mask/file.nii.gz maskIsWeighted: false numTimePts: 60 analysisChoice: Average outputPath: /path/to/store/output launchDashboard: true dashboardPort: 5557 dashboardClientPort: 5558 Configuration Keys : pynealHost : The IP address of the machine running Pyneal (i.e. the analysis machine ). This is the IP address that Pyneal Scanner will try to connect to, as well as any end user that is making requests for results. pynealScannerPort : Port number over which Pyneal will be listening for incoming data resultsServerPort : Port number that Pyneal will use to set up the Results Server maskFile : Path to mask file (Nifti - .nii/.nii.gz) to be used during real-time analysis maskIsWeighted : Voxel values in mask represent weights [true/false] numTimePts : Number of timepoints in current scan analysisChoice : Real-time analysis options [Average/Median/Path to custom analysis file] outputPath : Path to output directory where logs and results will be saved launchDashboard : Launch dashboard to monitor real-time scan [true/false] dashboardPort : Port number over which to launch the dashboard webserver ( NOTE: this key does not appear in the setup GUI) dashboardClientPort : Port number that browsers can use to connect to the dashboard ( NOTE: this key does not appear in the setup GUI)","title":"Using Setup GUI"},{"location":"setup/#custom-settings-files","text":"You can supply your own custom setting file with the configurate keys described above in one of two ways:","title":"Custom Settings Files"},{"location":"setup/#via-gui","text":"At the top of the setup GUI you have the option to load a custom settings file. A custom settings should be a .yaml file with values for one or more of the configuration keys above. By loading a custom settings file, the GUI will be populated with whichever configure keys are included; any non-included keys will get their values from the setupConfig.yaml file as normal. The option allows users to create settings files on a per-project basis, and easily configure Pyneal to match the project demands.","title":"via GUI:"},{"location":"setup/#via-command-line","text":"Alternatively, you can supply the path to this file at the command line when you launch Pyneal python pyneal.py --settingsFile /Path/to/custom/settingsFile.yaml or python pyneal.py -s /Path/to/custom/settingsFile.yaml","title":"via command line:"},{"location":"setup/#launching-pyneal-headless","text":"If for whatever reason you wish to launch Pyneal without opening the setup GUI, you can run in \"headless\" mode python pyneal.py --noGUI In this case, Pyneal will read the setupConfig.yaml file that was saved locally after the last time you ran Pyneal, and use those settings. Altnernatively, you can also supply the path to a different settings file using the steps described above","title":"Launching Pyneal \"Headless\""},{"location":"simulations/","text":"Simulations \u00b6 Overview \u00b6 In order to help with the initial setup, as well as test any analysis scripts and network communications later on, Pyneal includes a suite of simulation tools that mimic various inputs and outputs along the data flow path. (To test your installation or analysis scripts using example data, download the Pyneal Tutorial Data , which contains sample data from GE, Philips, and Siemens environments) These tools allow you to simulate Pyneal (or Pyneal Scanner ) in a modular fashion without having to run the entire pipeline. If you are troubleshooting issues, these tools are immensely helpful. Here is a diagram highlighting the various simulation tools, and where they enter the data flow pipeline. During an actual real-time scan, data will flow through this diagram from left to right along the blue arrows. Simulation tools are indicated using dashed or dotted vertical lines. A dashed line indicates a simulation tool that generates input . In other words, these tools mimic real data as it exists at a particular stage of the pipeline A dotted line indicates a simulation tool that receives output . In other words, these tools allow you to simulate the next stage of the pipeline Both Pyneal Scanner and Pyneal have their own set of simulation tools. Pyneal Scanner simulation tools can be found in pyneal/pyneal_scanner/simulation and are shown in light blue below the real data pipeline in the schematic. See below for more details Pyneal simulation tools can be found in pyneal/utils/simulation and are shown in green above the real data pipeline in the schematic. See below for more details Pyneal Scanner Simulation Tools \u00b6 The Pyneal Scanner simulation tools can be found in pyneal/pyneal_scanner/simulation Scanner Simulators : Set of simulation scripts to mimic the behavior of real scanners with real data. pynealReceiver_sim.py : simulates the behavior of Pyneal (i.e. accepts incoming 3D volumes from Pyneal Scanner ) Scanner Simulators \u00b6 Use Case: Testing Pyneal Scanner (and anything else downstream) with real data. This will simulate the appearance of raw data coming off of the scanner. This works by pointing the simulator to a folder containing real scanner data. The simulator will copy the real data to a new directory in a way that mimics the behavior of a real scan, allowing you to test Pyneal Scanner and anything else downstream. The format of the raw data will vary according to different scanner environments/manufacturers. Accordingly, there are multiple scripts that will simulate different scanner formats: GE \u00b6 location : pyneal/pyneal_scanner/simulation/scannerSimulators/GE_sim.py usage : python GE_sim.py inputDir [--outputDir] [--TR] input args : inputDir: path to directory containing raw slice dicom images. -o outputDir: path to directory where slices will be copied to [default: create new directory named s9999 in the parent directory of the inputDir] -t/--TR TR: set the TR in ms [default: 1000] In order to run this script, you must have a local directory that contains raw slice dicom files from an actual scan. If you want to fully mimic the data directory structure of GE scanners, you can create a local directory path that follows the pattern [baseDir]/p##/e##/s## where the slice images are stored in a directory named like s### , which is nested two levels deep ( p###/e### ) from the [basedir] . This script will copy all of the slices from the inputDir and copy them to the outputDir at a rate that is set by the TR. After the script has completed, the outputDir will be deleted. Philips \u00b6 location : pyneal/pyneal_scanner/simulation/scannerSimulators/Philips_sim.py usage : python Philips_sim.py inputDir [--outputDir] [--TR] input args : inputDir: path to directory containing raw slice dicom images. -o outputDir: path to directory where slices will be copied to [default: create new directory named 9999 in the parent directory of the inputDir] -t/--TR TR: set the TR in ms [default: 1000] Philips scanners use XTC (eXTernal Control) to output reconstructed volumes to a directory during a scan. The files are written to a designated directory (e.g. XTC_Output), and within that directory, every series is assigned a new directory named sequentially starting with '0000'. For instance, volumes from the 3rd series will be stored like '.../XTC_Output/0002/'. This script will simulate the creation of a new series directory, and copy in PAR/REC files. You must specify a local path to the inputDir. That is, the directory that already contains a set of reconstructed PAR/REC files for a series (referred to below as seriesDir ). [OPTIONAL]: You can specify the full path to an output directory where the PAR/REC files will be copied to. If you don't specify an output directory, this tool will default to creating a new seriesDir , named '9999' saved in the parent directory of the seriesDir . python Philips_sim.py /Path/To/My/Existing/Series/0000 --outputDir /Where/I/Want/New/Slice/Data/To/appear if you did not specify an outputDir, new PAR/RECs would be copied to: /Path/To/My/Existing/Series/9999 [OPTIONAL]: You can specify the TR at which new PAR/REC data is copied. Default is 1000ms. python Philips_sim.py /Path/To/My/Existing/Series/0000 --TR 2000 Siemens \u00b6 location : pyneal/pyneal_scanner/simulation/scannerSimulators/Siemens_sim.py usage : python Siemens_sim.py inputDir seriesNum [--newSeriesNum] [--TR] input args : inputDir: path to directory containing raw slice dicom images. seriesNum: series number of data that you want to simulate -n/--newSeriesNum: seriesNumber to assign to the new \"simulated\" data -t/--TR: set the TR in ms [default: 1000] Siemens scanners stores reconstructed slices images by taking all of the slices for a single volume, and placing them side-by-side in a larger \"mosaic\" dicom image. A scan will produce one mosaic image per volume, and all mosaic images for all scans across a single session will be stored in the same directory. This script simulates the creation of that directory, and will pass in real mosaic images. You must specify a local path to the inputDir as well as the series number of the series you want to simulate. The input dir should be the directory that already contains a set of reconstructed mosaic images. A single session dir will hold all of the mosaic files for all of the scans for a given session. Mosaic files are named like: [session#]_[series#]_[vol#].dcm [OPTIONAL]: You can specify the series number that will be assigned to the \"new\" mosaic images. The default behavior is to assign a series number based on the next sequential number given the existing series. In the example below, the default would be to assign a newSeriesNum as '2', but we are overriding that to assign it as '19' python Siemens_sim.py /Path/To/My/Existing/inputDir 1 --newSeriesNum 19 [OPTIONAL]: You can specify the TR at which new slice data is copied. Default is 1000ms, and represents the approximate amount of time it should take to copy over all of the slices for one volume of data. python Siemens_sim.py /Path/To/My/Existing/inputDir 1 --TR 2000 pynealReceiver_sim.py \u00b6 Use Case: When you want to test Pyneal Scanner without having to actually run Pyneal This simulator will mimic the part of Pyneal that accepts incoming 3D volumes from Pyneal Scanner . This allows you to quickly test sending output with Pyneal Scanner , without having to fully run Pyneal (which entails a lot of extra overhead). You can (and should) run pynealReceiver_sim.py from the Scanner Computer . location : pyneal/pyneal_scanner/simulation/pynealReceiver_sim.py usage : python pynealReceiver_sim.py [--port] [--nVols] input args : -p/--port: port number to listen on for incoming data [default: 5556] -n/--nVols: number of 3D volumes to expect from Pyneal Scanner [default: 60] Make sure Pyneal Scanner is configured to use the same port number for pynealSocketPort (see Pyneal Scanner Setup ) After the scan is complete and all of the data has arrived, this will save the received 4D volume as a nifti image at pyneal/pyneal_scanner/simulation/receivedImg.nii.gz Pyneal Simulation Tools \u00b6 The Pyneal simulation tools can be found in pyneal/utils/simulation pynealScanner_sim.py : simulate the behavior of Pyneal Scanner (i.e. sends 3D vols to Pyneal) pynealResults_sim.py : simulate the results server of Pyneal (i.e. launches a server that stores fake results that can receive and respond to messages from the End User ) endUser_sim.py : simulate the behavior of an End User (i.e. sends request to Pyneal for results from a specific volume, then waits for response) pynealScanner_sim.py \u00b6 Use Case: When you want to test Pyneal without having to actually run Pyneal Scanner location : pyneal/utils/simulation/pynealScanner_sim.py usage : python pynealScanner_sim.py [--filePath] [--random] [--dims] [--TR] [--sockethost] [--socketport] input args : -f/--filePath: path to 4D nifti image that you want to use as the \"scan\" data -r/--random: flag to generate random data instead of using a pre-existing nifti image -d/--dims: desired dimensions of randomly generated dataset [default: 64 64 18 60] -t/--TR: set the TR in ms [default: 1000] -sh/--sockethost: IP address Pyneal host [default: 127.0.0.1] -sp/--socketport: port number to send 3D volumes over to Pyneal [default: 5555] This tool will simulate the behavior of Pyneal Scanner . During a real scan, pynealScanner will send data to pyneal over a socket connection. Each tranmission comes in 2 phases: first a json header with metadata about the volume, then the volume itself. This tool will send data in that same format, using either a pre-existing 4D nifti image, or randomly generated data. You can either supply real 4D image data: python pynealScanner_sim.py --filePath /path/to/my/data.nii.gz or use the tool to generate a dataset of random values python pynealScanner_sim.py --random --dims 64 64 32 100 [OPTIONAL]: You can specify the TR at which 3D vols are sent to Pyneal . Default is 1000ms. python pynealScanner_sim.py --filePath /path/to/my/data.nii.gz --TR 2000 [OPTIONAL]: You can set the socketHost and socketPort used for communication with Pyneal . Default host is 127.0.0.1 , which allows you to run this tool alongside Pyneal on the same computer. Default socket port number is 5555 . You must make sure that Pyneal is configured to be listening for incoming data on this port number (see Pyneal Set Up ) pynealResults_sim.py \u00b6 Use Case: When you want to test an End User without having to actually run Pyneal (or anything else further upstream) location : pyneal/utils/simulation/pynealResults_sim.py usage : python pynealResults_sim.py [--TR] [--sockethost] [--socketport] [--keepAlive] input args : -t/--TR: set the TR in ms [default: 1000] -sh/--sockethost: IP address Pyneal host [default: 127.0.0.1] -sp/--socketport: port number to send 3D volumes over to Pyneal [default: 5556] --keepAlive: True/False flag for whether to keep the simulated server alive and listening even once all of the made up data is added to it (see below for more details). Useful for debugging/testing. [default: False] This tool will launch a server that listen in for requests for results from a remote End User (e.g. a task presentation machine). This tools behaves exactly the same way as the results server component of Pyneal, allowing you to test the End User behavior. In this case the results that are returned are from a made up dataset generated each time the tool is called. There are 500 volumes in the generated dataset, and each volume has an associated \"Average\" result that is a random value drawn from a normal distribution (mean: 2400, stdDev: 15). Results for each volume will be available on the simulated results server at a rate set by the TR. For instance, with a 1000ms TR, it will take 500s for all of the results to appear. While this simulated results server is running, it will listen for requests from an End User . With each request that appears, it will check to see if the result from the requested volume has appeared yet. If it has, it will send back a message that looks something like: {foundResults: True, average: #####} If not, the response message will simply be: {foundResults: False} For more information on formatting requests and interpretting responses, see requesting results ) endUser_sim.py \u00b6 Use Case: When you want to test sending requests to Pyneal without having to actually run a real End User location : pyneal/utils/simulation/endUser_sim.py usage : python endUser_sim.py [-sh/--socketHost] [-sp/--socketPort] [volIdx] input args : -sh/--sockethost: IP address Pyneal host [default: '127.0.0.1'] -sp/--socketport: port number to send 3D volumes over to Pyneal [default: 5556] volIdx: the index of the volume you'd like to request results from [default: 0000]. Note: volume indices are 0-based This tool will simulate and demo how an End User may request results from Pyneal during a real-time scan. In a neurofeedback context, for example, the end-user may be the software that is controlling the experimental task. In this case, anytime the task wants to present feedback to the participant, it must request the output of the real-time analysis for a specific set of timepoints (or volumes). This is an example of how requests should be formatted and sent to Pyneal . Requests are made on a per-volume basis, and each request should take the form of a 4-character string representing the desired volume index (using a 0-based index). For example, to request the first volume in the series, the string would be '0000'; to request the 25th volume in the series the string would be '0024', and so on... For more information on formatting requests and interpretting responses, see requesting results and parsing responses","title":"Simulations"},{"location":"simulations/#simulations","text":"","title":"Simulations"},{"location":"simulations/#overview","text":"In order to help with the initial setup, as well as test any analysis scripts and network communications later on, Pyneal includes a suite of simulation tools that mimic various inputs and outputs along the data flow path. (To test your installation or analysis scripts using example data, download the Pyneal Tutorial Data , which contains sample data from GE, Philips, and Siemens environments) These tools allow you to simulate Pyneal (or Pyneal Scanner ) in a modular fashion without having to run the entire pipeline. If you are troubleshooting issues, these tools are immensely helpful. Here is a diagram highlighting the various simulation tools, and where they enter the data flow pipeline. During an actual real-time scan, data will flow through this diagram from left to right along the blue arrows. Simulation tools are indicated using dashed or dotted vertical lines. A dashed line indicates a simulation tool that generates input . In other words, these tools mimic real data as it exists at a particular stage of the pipeline A dotted line indicates a simulation tool that receives output . In other words, these tools allow you to simulate the next stage of the pipeline Both Pyneal Scanner and Pyneal have their own set of simulation tools. Pyneal Scanner simulation tools can be found in pyneal/pyneal_scanner/simulation and are shown in light blue below the real data pipeline in the schematic. See below for more details Pyneal simulation tools can be found in pyneal/utils/simulation and are shown in green above the real data pipeline in the schematic. See below for more details","title":"Overview"},{"location":"simulations/#pyneal-scanner-simulation-tools","text":"The Pyneal Scanner simulation tools can be found in pyneal/pyneal_scanner/simulation Scanner Simulators : Set of simulation scripts to mimic the behavior of real scanners with real data. pynealReceiver_sim.py : simulates the behavior of Pyneal (i.e. accepts incoming 3D volumes from Pyneal Scanner )","title":"Pyneal Scanner Simulation Tools"},{"location":"simulations/#scanner-simulators","text":"Use Case: Testing Pyneal Scanner (and anything else downstream) with real data. This will simulate the appearance of raw data coming off of the scanner. This works by pointing the simulator to a folder containing real scanner data. The simulator will copy the real data to a new directory in a way that mimics the behavior of a real scan, allowing you to test Pyneal Scanner and anything else downstream. The format of the raw data will vary according to different scanner environments/manufacturers. Accordingly, there are multiple scripts that will simulate different scanner formats:","title":"Scanner Simulators"},{"location":"simulations/#ge","text":"location : pyneal/pyneal_scanner/simulation/scannerSimulators/GE_sim.py usage : python GE_sim.py inputDir [--outputDir] [--TR] input args : inputDir: path to directory containing raw slice dicom images. -o outputDir: path to directory where slices will be copied to [default: create new directory named s9999 in the parent directory of the inputDir] -t/--TR TR: set the TR in ms [default: 1000] In order to run this script, you must have a local directory that contains raw slice dicom files from an actual scan. If you want to fully mimic the data directory structure of GE scanners, you can create a local directory path that follows the pattern [baseDir]/p##/e##/s## where the slice images are stored in a directory named like s### , which is nested two levels deep ( p###/e### ) from the [basedir] . This script will copy all of the slices from the inputDir and copy them to the outputDir at a rate that is set by the TR. After the script has completed, the outputDir will be deleted.","title":"GE"},{"location":"simulations/#philips","text":"location : pyneal/pyneal_scanner/simulation/scannerSimulators/Philips_sim.py usage : python Philips_sim.py inputDir [--outputDir] [--TR] input args : inputDir: path to directory containing raw slice dicom images. -o outputDir: path to directory where slices will be copied to [default: create new directory named 9999 in the parent directory of the inputDir] -t/--TR TR: set the TR in ms [default: 1000] Philips scanners use XTC (eXTernal Control) to output reconstructed volumes to a directory during a scan. The files are written to a designated directory (e.g. XTC_Output), and within that directory, every series is assigned a new directory named sequentially starting with '0000'. For instance, volumes from the 3rd series will be stored like '.../XTC_Output/0002/'. This script will simulate the creation of a new series directory, and copy in PAR/REC files. You must specify a local path to the inputDir. That is, the directory that already contains a set of reconstructed PAR/REC files for a series (referred to below as seriesDir ). [OPTIONAL]: You can specify the full path to an output directory where the PAR/REC files will be copied to. If you don't specify an output directory, this tool will default to creating a new seriesDir , named '9999' saved in the parent directory of the seriesDir . python Philips_sim.py /Path/To/My/Existing/Series/0000 --outputDir /Where/I/Want/New/Slice/Data/To/appear if you did not specify an outputDir, new PAR/RECs would be copied to: /Path/To/My/Existing/Series/9999 [OPTIONAL]: You can specify the TR at which new PAR/REC data is copied. Default is 1000ms. python Philips_sim.py /Path/To/My/Existing/Series/0000 --TR 2000","title":"Philips"},{"location":"simulations/#siemens","text":"location : pyneal/pyneal_scanner/simulation/scannerSimulators/Siemens_sim.py usage : python Siemens_sim.py inputDir seriesNum [--newSeriesNum] [--TR] input args : inputDir: path to directory containing raw slice dicom images. seriesNum: series number of data that you want to simulate -n/--newSeriesNum: seriesNumber to assign to the new \"simulated\" data -t/--TR: set the TR in ms [default: 1000] Siemens scanners stores reconstructed slices images by taking all of the slices for a single volume, and placing them side-by-side in a larger \"mosaic\" dicom image. A scan will produce one mosaic image per volume, and all mosaic images for all scans across a single session will be stored in the same directory. This script simulates the creation of that directory, and will pass in real mosaic images. You must specify a local path to the inputDir as well as the series number of the series you want to simulate. The input dir should be the directory that already contains a set of reconstructed mosaic images. A single session dir will hold all of the mosaic files for all of the scans for a given session. Mosaic files are named like: [session#]_[series#]_[vol#].dcm [OPTIONAL]: You can specify the series number that will be assigned to the \"new\" mosaic images. The default behavior is to assign a series number based on the next sequential number given the existing series. In the example below, the default would be to assign a newSeriesNum as '2', but we are overriding that to assign it as '19' python Siemens_sim.py /Path/To/My/Existing/inputDir 1 --newSeriesNum 19 [OPTIONAL]: You can specify the TR at which new slice data is copied. Default is 1000ms, and represents the approximate amount of time it should take to copy over all of the slices for one volume of data. python Siemens_sim.py /Path/To/My/Existing/inputDir 1 --TR 2000","title":"Siemens"},{"location":"simulations/#pynealreceiver_simpy","text":"Use Case: When you want to test Pyneal Scanner without having to actually run Pyneal This simulator will mimic the part of Pyneal that accepts incoming 3D volumes from Pyneal Scanner . This allows you to quickly test sending output with Pyneal Scanner , without having to fully run Pyneal (which entails a lot of extra overhead). You can (and should) run pynealReceiver_sim.py from the Scanner Computer . location : pyneal/pyneal_scanner/simulation/pynealReceiver_sim.py usage : python pynealReceiver_sim.py [--port] [--nVols] input args : -p/--port: port number to listen on for incoming data [default: 5556] -n/--nVols: number of 3D volumes to expect from Pyneal Scanner [default: 60] Make sure Pyneal Scanner is configured to use the same port number for pynealSocketPort (see Pyneal Scanner Setup ) After the scan is complete and all of the data has arrived, this will save the received 4D volume as a nifti image at pyneal/pyneal_scanner/simulation/receivedImg.nii.gz","title":"pynealReceiver_sim.py"},{"location":"simulations/#pyneal-simulation-tools","text":"The Pyneal simulation tools can be found in pyneal/utils/simulation pynealScanner_sim.py : simulate the behavior of Pyneal Scanner (i.e. sends 3D vols to Pyneal) pynealResults_sim.py : simulate the results server of Pyneal (i.e. launches a server that stores fake results that can receive and respond to messages from the End User ) endUser_sim.py : simulate the behavior of an End User (i.e. sends request to Pyneal for results from a specific volume, then waits for response)","title":"Pyneal Simulation Tools"},{"location":"simulations/#pynealscanner_simpy","text":"Use Case: When you want to test Pyneal without having to actually run Pyneal Scanner location : pyneal/utils/simulation/pynealScanner_sim.py usage : python pynealScanner_sim.py [--filePath] [--random] [--dims] [--TR] [--sockethost] [--socketport] input args : -f/--filePath: path to 4D nifti image that you want to use as the \"scan\" data -r/--random: flag to generate random data instead of using a pre-existing nifti image -d/--dims: desired dimensions of randomly generated dataset [default: 64 64 18 60] -t/--TR: set the TR in ms [default: 1000] -sh/--sockethost: IP address Pyneal host [default: 127.0.0.1] -sp/--socketport: port number to send 3D volumes over to Pyneal [default: 5555] This tool will simulate the behavior of Pyneal Scanner . During a real scan, pynealScanner will send data to pyneal over a socket connection. Each tranmission comes in 2 phases: first a json header with metadata about the volume, then the volume itself. This tool will send data in that same format, using either a pre-existing 4D nifti image, or randomly generated data. You can either supply real 4D image data: python pynealScanner_sim.py --filePath /path/to/my/data.nii.gz or use the tool to generate a dataset of random values python pynealScanner_sim.py --random --dims 64 64 32 100 [OPTIONAL]: You can specify the TR at which 3D vols are sent to Pyneal . Default is 1000ms. python pynealScanner_sim.py --filePath /path/to/my/data.nii.gz --TR 2000 [OPTIONAL]: You can set the socketHost and socketPort used for communication with Pyneal . Default host is 127.0.0.1 , which allows you to run this tool alongside Pyneal on the same computer. Default socket port number is 5555 . You must make sure that Pyneal is configured to be listening for incoming data on this port number (see Pyneal Set Up )","title":"pynealScanner_sim.py"},{"location":"simulations/#pynealresults_simpy","text":"Use Case: When you want to test an End User without having to actually run Pyneal (or anything else further upstream) location : pyneal/utils/simulation/pynealResults_sim.py usage : python pynealResults_sim.py [--TR] [--sockethost] [--socketport] [--keepAlive] input args : -t/--TR: set the TR in ms [default: 1000] -sh/--sockethost: IP address Pyneal host [default: 127.0.0.1] -sp/--socketport: port number to send 3D volumes over to Pyneal [default: 5556] --keepAlive: True/False flag for whether to keep the simulated server alive and listening even once all of the made up data is added to it (see below for more details). Useful for debugging/testing. [default: False] This tool will launch a server that listen in for requests for results from a remote End User (e.g. a task presentation machine). This tools behaves exactly the same way as the results server component of Pyneal, allowing you to test the End User behavior. In this case the results that are returned are from a made up dataset generated each time the tool is called. There are 500 volumes in the generated dataset, and each volume has an associated \"Average\" result that is a random value drawn from a normal distribution (mean: 2400, stdDev: 15). Results for each volume will be available on the simulated results server at a rate set by the TR. For instance, with a 1000ms TR, it will take 500s for all of the results to appear. While this simulated results server is running, it will listen for requests from an End User . With each request that appears, it will check to see if the result from the requested volume has appeared yet. If it has, it will send back a message that looks something like: {foundResults: True, average: #####} If not, the response message will simply be: {foundResults: False} For more information on formatting requests and interpretting responses, see requesting results )","title":"pynealResults_sim.py"},{"location":"simulations/#enduser_simpy","text":"Use Case: When you want to test sending requests to Pyneal without having to actually run a real End User location : pyneal/utils/simulation/endUser_sim.py usage : python endUser_sim.py [-sh/--socketHost] [-sp/--socketPort] [volIdx] input args : -sh/--sockethost: IP address Pyneal host [default: '127.0.0.1'] -sp/--socketport: port number to send 3D volumes over to Pyneal [default: 5556] volIdx: the index of the volume you'd like to request results from [default: 0000]. Note: volume indices are 0-based This tool will simulate and demo how an End User may request results from Pyneal during a real-time scan. In a neurofeedback context, for example, the end-user may be the software that is controlling the experimental task. In this case, anytime the task wants to present feedback to the participant, it must request the output of the real-time analysis for a specific set of timepoints (or volumes). This is an example of how requests should be formatted and sent to Pyneal . Requests are made on a per-volume basis, and each request should take the form of a 4-character string representing the desired volume index (using a 0-based index). For example, to request the first volume in the series, the string would be '0000'; to request the 25th volume in the series the string would be '0024', and so on... For more information on formatting requests and interpretting responses, see requesting results and parsing responses","title":"endUser_sim.py"},{"location":"test/","text":"/Users/jeff/gDrive/jeffCloud/real-time/pyneal/src/GUIs/pynealSetup pyneal Pyneal Real-time fMRI Acquisition and Analysis This is the main Pyneal application, designed to be called directly from the command line on the computer designated as your real-time analysis machine. It expects to receive incoming slice data from the Pyneal-Scanner application, which should be running concurrently elsewhere (e.g. on the scanner console itself) Once this application is called, it'll take care of opening the GUI, loading settings, launching separate threads for monitoring and analyzing incoming data, and hosting the Analysis output server launchPyneal launchPyneal() Main Pyneal Loop. This function will launch setup GUI, retrieve settings, initialize all threads, and start processing incoming scans createOutputDir createOutputDir(parentDir) Create a new output directory in the parent dir. Output directories are named sequentially, starting with pyneal_001. This function will find all existing pyneal_### directories in the parentDir and name the new output directory accordingly. returns full path to the new output directory src.scanReceiver Class to listen for incoming data from the scanner. This tool is designed to be run in a separate thread, where it will: - establish a socket connection to pynealScanner (which will be sending volume data from the scanner) - listen for incoming volume data (preceded by a header) - format the incoming data, and assign it to the proper location in a 4D matrix for the entire san In additiona, it also includes various methods for accessing the progress of an on-going scan, and returning data that has successfully arrived, etc. --- Notes for setting up: ** Socket Connection: This tool uses the ZeroMQ library, instead of the standard python socket library. ZMQ takes care of a lot of the backend work, is incredibily reliable, and offers methods for easily sending pre-formatted types of data, including JSON dicts, and numpy arrays. ** Expectations for data formatting: Once a scan has begun, this tool expects data to arrive over the socket connection one volume at a time. There should be two parts to each volume transmission: 1. First, a JSON header containing the following dict keys: - volIdx: within-volume index of the volume (0-based) - dtype: datatype of the voxel array (e.g. int16) - shape: voxel array dimensions (e.g. (64, 64, 18)) - affine: affine matrix to transform the voxel data from vox to mm space 2. Next, the voxel array, as a string buffer that can be converted into a numpy array. Once both of those peices of data have arrived, this tool will send back a confirmation string message. ** Volume Orientation: Pyneal works on the assumption that incoming volumes will have the 3D voxel array ordered like RAS+, and that the accompanying affine will provide a transform from voxel space RAS+ to mm space RAS+. In order to any mask-based analysis in Pyneal to work, we need to make sure that the incoming data and the mask data are reprsented in the same way. The pyneal_scanner utilities have all been configured to ensure that each volume that is transmitted is in RAS+ space. Along those same lines, the affine that gets transmitted in the header for each volume should be the same for all volumes in the series. ScanReceiver ScanReceiver(self, settings) Class to listen in for incoming scan data. As new volumes arrive, the header is decoded, and the volume is added to the appropriate place in the 4D data matrix Input a dictionary called 'settings' that has (at least) the following keys: numTimepts: number of expected timepoints in series [500] pynealHost: ip address for the computer running Pyneal pynealScannerPort: port # for scanner socket [e.g. 5555] createImageMatrix ScanReceiver.createImageMatrix(self, volHeader) Once the first volume appears, this function should be called to build the empty matrix to store incoming vol data, using info from the vol header. get_affine ScanReceiver.get_affine(self) Return the affine for this series get_vol ScanReceiver.get_vol(self, volIdx) Return the requested vol, if it is here. Note: volIdx is 0-based get_slice ScanReceiver.get_slice(self, volIdx, sliceIdx) Return the requested slice, if it is here. Note: volIdx, and sliceIdx are 0-based sendToDashboard ScanReceiver.sendToDashboard(self, msg) If dashboard is launched, send the msg to the dashboard. The dashboard expects messages formatted in specific way, namely a dictionary with 2 keys: 'topic', and 'content' Any message from the scanReceiver should set the topic as 'pynealScannerLog', and the content should be it's own dictionary with the key 'logString'. logString should contain the log message you want the dashboard to display saveResults ScanReceiver.saveResults(self) Save the image matrix as a Nifti file in the output directory for this series","title":"Test"},{"location":"troubleshooting/","text":"troubleshooting \u00b6 Installation \u00b6 Network Issues \u00b6 Address already in use \u00b6 You go to launch Pyneal and in the terminal you see an error that reads something like zmq.error.ZMQError: Address already in use Cause : Pyneal is trying to create a socket on a port that is already in use. This could occur if: A) There is another application currently using the same port(s) that Pyneal is trying to use B) Pyneal failed to properly close the port(s) the last time you used it Diagnose 1) Confirm which ports Pyneal is trying to use. By default, Pyneal uses ports in the 5555-5558 range; To verify, check the settings that are printed to the terminal when you run Pyneal, in particular: MainThread - Setting: dashboardClientPort: 5558 MainThread - Setting: dashboardPort: 5557 MainThread - Setting: pynealScannerPort: 5555 MainThread - Setting: resultsServerPort: 5556 2) Next, check which processes are currently using those ports. In a terminal, type: lsof -i :5555-5558 and you will be presented with a list Process IDs (PID column) currently using ports within that range: COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME Python 21115 jeff 14u IPv4 0xb42eb5e0931fdff 0t0 TCP localhost:personal-agent (LISTEN) Python 21115 jeff 17u IPv4 0xb42eb5dfde84dff 0t0 TCP *:freeciv (LISTEN) Python 21115 jeff 24u IPv4 0xb42eb5e0a2ca47f 0t0 TCP localhost:52786->localhost:5557 (ESTABLISHED) Python 21115 jeff 25u IPv4 0xb42eb5e0922647f 0t0 TCP localhost:52787->localhost:5557 (ESTABLISHED) Python 21115 jeff 26u IPv4 0xb42eb5e315700ff 0t0 TCP localhost:52788->localhost:5557 (ESTABLISHED) Python 21115 jeff 30u IPv4 0xb42eb5e095bf0ff 0t0 TCP localhost:52789->localhost:5557 (ESTABLISHED) This output indicates that Python is currently running a process that is occupying port 5557 . Despite the multiple lines, note that there is just a single process ID (PID) represented. In this case, it appears as though Pyneal has failed to properly close the socket on port 5557 the last time you ran it (unless you happen to be running other unrelated Python processes simultaneously that also happen to be using those same port numbers as Pyneal). Alternatively, if you see a different application listed under COMMAND , it would indicate that there is another active process on your machine that is competing for ports with Pyneal. Fixes Option 1 : Kill the competing process. Once you have identifed which process is occupying the port you are trying to use, you can kill it by typing: kill -9 PID Where PID is the process ID (PID) from the output above Option 2 : Make Pyneal use a differnt Port #. If you do not want to stop the competing process, you can have Pyneal use different port numbers by manually editing your config file: Open your custom config file (or use the default one at pyneal/src/GUIs/pynealSetup/setupConfig.yaml ) change the port number entries to use new ports (note: port numbers can range from 0-65535 but numbers 0-1023 are typically reserved for priveledged system processes) ... dashboardClientPort: 7000 dashboardPort: 7001 pynealScannerPort: 7002 resultsServerPort: 7003 Pyneal Scanner \u00b6 Pyneal \u00b6 Creating Masks \u00b6 My output masks are misaligned \u00b6 In addition to creating the desired masks, the createMask.py tool creates a number of additional output files that can be used to help diagnose issues. Within the mask_transforms directory, check the quality of the following output files for clues: exampleFunc.nii.gz - mean 3D functional image, created by collapsing the input 4D functional image over time hires_brain.nii.gz - skull stripped version of the input anatomical image. If the default skull stripping performs poorly, try to skull strip the anatomical image manually, and then re-run createMask.py with the newly skull stripped image (and make sure to deselect the skull strip? option within the createMask.py GUI). hires_FUNC.nii.gz - the hi-res anatomical transformed to functional space. Problems with this image suggest the hires2func transformation matrix failed. mni_HIRES.nii.z - the MNI standard image transformed to hi-res anatomical space. Problems with this image suggest the mni2hires tranformation matrix failed.","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"","title":"troubleshooting"},{"location":"troubleshooting/#installation","text":"","title":"Installation"},{"location":"troubleshooting/#network-issues","text":"","title":"Network Issues"},{"location":"troubleshooting/#address-already-in-use","text":"You go to launch Pyneal and in the terminal you see an error that reads something like zmq.error.ZMQError: Address already in use Cause : Pyneal is trying to create a socket on a port that is already in use. This could occur if: A) There is another application currently using the same port(s) that Pyneal is trying to use B) Pyneal failed to properly close the port(s) the last time you used it Diagnose 1) Confirm which ports Pyneal is trying to use. By default, Pyneal uses ports in the 5555-5558 range; To verify, check the settings that are printed to the terminal when you run Pyneal, in particular: MainThread - Setting: dashboardClientPort: 5558 MainThread - Setting: dashboardPort: 5557 MainThread - Setting: pynealScannerPort: 5555 MainThread - Setting: resultsServerPort: 5556 2) Next, check which processes are currently using those ports. In a terminal, type: lsof -i :5555-5558 and you will be presented with a list Process IDs (PID column) currently using ports within that range: COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME Python 21115 jeff 14u IPv4 0xb42eb5e0931fdff 0t0 TCP localhost:personal-agent (LISTEN) Python 21115 jeff 17u IPv4 0xb42eb5dfde84dff 0t0 TCP *:freeciv (LISTEN) Python 21115 jeff 24u IPv4 0xb42eb5e0a2ca47f 0t0 TCP localhost:52786->localhost:5557 (ESTABLISHED) Python 21115 jeff 25u IPv4 0xb42eb5e0922647f 0t0 TCP localhost:52787->localhost:5557 (ESTABLISHED) Python 21115 jeff 26u IPv4 0xb42eb5e315700ff 0t0 TCP localhost:52788->localhost:5557 (ESTABLISHED) Python 21115 jeff 30u IPv4 0xb42eb5e095bf0ff 0t0 TCP localhost:52789->localhost:5557 (ESTABLISHED) This output indicates that Python is currently running a process that is occupying port 5557 . Despite the multiple lines, note that there is just a single process ID (PID) represented. In this case, it appears as though Pyneal has failed to properly close the socket on port 5557 the last time you ran it (unless you happen to be running other unrelated Python processes simultaneously that also happen to be using those same port numbers as Pyneal). Alternatively, if you see a different application listed under COMMAND , it would indicate that there is another active process on your machine that is competing for ports with Pyneal. Fixes Option 1 : Kill the competing process. Once you have identifed which process is occupying the port you are trying to use, you can kill it by typing: kill -9 PID Where PID is the process ID (PID) from the output above Option 2 : Make Pyneal use a differnt Port #. If you do not want to stop the competing process, you can have Pyneal use different port numbers by manually editing your config file: Open your custom config file (or use the default one at pyneal/src/GUIs/pynealSetup/setupConfig.yaml ) change the port number entries to use new ports (note: port numbers can range from 0-65535 but numbers 0-1023 are typically reserved for priveledged system processes) ... dashboardClientPort: 7000 dashboardPort: 7001 pynealScannerPort: 7002 resultsServerPort: 7003","title":"Address already in use"},{"location":"troubleshooting/#pyneal-scanner","text":"","title":"Pyneal Scanner"},{"location":"troubleshooting/#pyneal","text":"","title":"Pyneal"},{"location":"troubleshooting/#creating-masks","text":"","title":"Creating Masks"},{"location":"troubleshooting/#my-output-masks-are-misaligned","text":"In addition to creating the desired masks, the createMask.py tool creates a number of additional output files that can be used to help diagnose issues. Within the mask_transforms directory, check the quality of the following output files for clues: exampleFunc.nii.gz - mean 3D functional image, created by collapsing the input 4D functional image over time hires_brain.nii.gz - skull stripped version of the input anatomical image. If the default skull stripping performs poorly, try to skull strip the anatomical image manually, and then re-run createMask.py with the newly skull stripped image (and make sure to deselect the skull strip? option within the createMask.py GUI). hires_FUNC.nii.gz - the hi-res anatomical transformed to functional space. Problems with this image suggest the hires2func transformation matrix failed. mni_HIRES.nii.z - the MNI standard image transformed to hi-res anatomical space. Problems with this image suggest the mni2hires tranformation matrix failed.","title":"My output masks are misaligned"}]}