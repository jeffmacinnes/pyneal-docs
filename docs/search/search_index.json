{
    "docs": [
        {
            "location": "/",
            "text": "Introduction\n\u00b6\n\n\n\n\nPyneal GitHub repository\n\n\nWhat is it?\n\u00b6\n\n\nPyneal\n is an open source software package to support real-time functional magnetic resonance imaging (fMRI). It is entirely Python-based and depends exclusively on free, open source neuroimaging libraries.\n\n\nIt allows users to:\n\n\n\n\naccess functional MRI data in real-time\n\n\ncompute on-going analyses throughout a scan\n\n\nmonitor data quality\n\n\nshare analysis results with remote devices (e.g. send results to an experimental task presenting neurofeedback to participants)\n\n\n\n\nIt currently supports data formats used across 3 major MRI manufacturers: \nGE\n, \nSiemens\n, \nPhilips\n.\n\n\nIn addition to allowing users to compute basic, ROI-based analyses during a scan, \nPyneal\n also provides a simple framework for designing and writing customized analyses that can be computed across the whole brain volume at each timepoint.\n\n\nDesign/Structure\n\u00b6\n\n\nThe software is broken into two separate components: \nPyneal Scanner\n and \nPyneal\n. When first downloaded, \nPyneal Scanner\n is contained in a separate directory within the \nPyneal\n directory\n\n\n\n\n\n\nPyneal Scanner\n: Accesses incoming data, modifies it to match a standardized format, and then sends the data out, one 3D volume at a time, to \nPyneal\n\n\n\n\n\n\nPyneal\n: Listens for incoming 3D volumes from \nPyneal Scanner\n, runs whatever analyses\nyou have specified, and hosts the results on a server, which other downstream components (e.g. an experimental task) can make requests to\n\n\n\n\n\n\nThis design allows the software to easily accommodate the various directory structures and data formats that are found on different scanner models at different institutions around the world. (However, it also means that the steps to install, and run \nPyneal\n can vary from environment to environment).\n\n\nTerms/Definitions\n\u00b6\n\n\nThroughout the documentation specific terms are used to describe the different components of the software, the underlying architecture, and the various processes involved. Despite sincere efforts to keep these terms intuitive, they're probably not in all cases. Please check the \nglossary\n for any unfamiliar terms you come across. (You can also find it under \nReference\n in the lefthand menu.",
            "title": "Introduction"
        },
        {
            "location": "/#introduction",
            "text": "Pyneal GitHub repository",
            "title": "Introduction"
        },
        {
            "location": "/#what-is-it",
            "text": "Pyneal  is an open source software package to support real-time functional magnetic resonance imaging (fMRI). It is entirely Python-based and depends exclusively on free, open source neuroimaging libraries.  It allows users to:   access functional MRI data in real-time  compute on-going analyses throughout a scan  monitor data quality  share analysis results with remote devices (e.g. send results to an experimental task presenting neurofeedback to participants)   It currently supports data formats used across 3 major MRI manufacturers:  GE ,  Siemens ,  Philips .  In addition to allowing users to compute basic, ROI-based analyses during a scan,  Pyneal  also provides a simple framework for designing and writing customized analyses that can be computed across the whole brain volume at each timepoint.",
            "title": "What is it?"
        },
        {
            "location": "/#designstructure",
            "text": "The software is broken into two separate components:  Pyneal Scanner  and  Pyneal . When first downloaded,  Pyneal Scanner  is contained in a separate directory within the  Pyneal  directory    Pyneal Scanner : Accesses incoming data, modifies it to match a standardized format, and then sends the data out, one 3D volume at a time, to  Pyneal    Pyneal : Listens for incoming 3D volumes from  Pyneal Scanner , runs whatever analyses\nyou have specified, and hosts the results on a server, which other downstream components (e.g. an experimental task) can make requests to    This design allows the software to easily accommodate the various directory structures and data formats that are found on different scanner models at different institutions around the world. (However, it also means that the steps to install, and run  Pyneal  can vary from environment to environment).",
            "title": "Design/Structure"
        },
        {
            "location": "/#termsdefinitions",
            "text": "Throughout the documentation specific terms are used to describe the different components of the software, the underlying architecture, and the various processes involved. Despite sincere efforts to keep these terms intuitive, they're probably not in all cases. Please check the  glossary  for any unfamiliar terms you come across. (You can also find it under  Reference  in the lefthand menu.",
            "title": "Terms/Definitions"
        },
        {
            "location": "/installation/",
            "text": "Installation\n\u00b6\n\n\nPyneal is built and tested using \nPython 3.6\n\n\nDownload Python from \nhttps://www.python.org/downloads/\n or via a distribution like \nAnaconda\n\n\nPyneal requires additional libraries beyond the standard library. Instructions below use \npip\n to install these libraries. Verify that you have \npip\n installed:\n\n\n\n\nwhich pip\n\n\n\n\nIf not, download and install pip from \nhttps://pip.pypa.io/en/stable/installing/\n\n\nDownload Pyneal\n\u00b6\n\n\nDownload the \nPyneal repository\n from GitHub, or clone to your local machine:\n\n\n\n\ngit clone https://github.com/jeffmacinnes/pyneal.git\n\n\n\n\nThe installation instructions are broken down by \nPyneal Scanner\n and \nPyneal\n. If you haven't already, read the section on \ndefinitions\n, as those definitions are used throughout these instructions.\n\n\nPyneal-Scanner\n\u00b6\n\n\nThe \npyneal_scanner\n directory needs to be on the \nscanner computer\n. If the \nscanner computer\n is different from the \nanalysis computer\n in your environment, copy the \npyneal_scanner\n directory to the \nscanner computer\n.  \n\n\ndependencies\n\u00b6\n\n\nThe \nscanner computer\n requires additional \npython\n libraries in order to run \nPyneal Scanner\n.\n\n\nYou can attempt to install all required libraries at once by navigating into the \npyneal_scanner\n directory and typing:\n\n\n\n\npip install -r requirements.txt\n\n\n\n\nIf that fails for any reason, you can install manually one at a time:\n\n\n\n\npip install numpy==1.13.1\n\npip install pydicom==1.0.2\n\npip install nibabel==2.1.0\n\npip install pyzmq==16.0.2\n\npip install pyyaml==3.12\n\n\n\n\nThese versions reflect the primary environment in which \nPyneal\n is tested. It is likely that other versions maintain compatibility, but use at your own risk.\n\n\nPyneal\n\u00b6\n\n\nThe \npyneal\n directory needs to be on the \nanalysis computer\n.\n\n\ndependencies\n\u00b6\n\n\nThe \nanalysis computer\n requires additional \npython\n libraries in order to run \nPyneal\n.\n\n\nYou can attempt to install all required libraries at once by navigating into the \npyneal\n directory and typing:\n\n\n\n\npip install -r requirements.txt\n\n\n\n\nIf that fails for any reason, you can install manually one at a time:\n\n\n\n\npip install numpy==1.13.1\n\npip install nibabel==2.1.0\n\npip install nipy==0.4.1\n\npip install pyzmq==16.0.2\n\npip install pyyaml==3.12\n\npip install kivy==1.10.dev0\n\npip install flask==0.12.2\n\npip install flask_socketio==2.9.2\n\npip install eventlet==0.21.0  \n\n\n\n\nThese versions reflect the primary environment in which \nPyneal\n is tested. It is likely that other versions maintain compatibility, but use at your own risk.\n\n\nSome users have reported problems installing the development version of kivy (under Pyneal dependencies). For assistance with this step, and other issues, see \nTroubleshooting\n\n\nAdditional Tools\n\u00b6\n\n\nPyneal\n itself does not require any additional libaries beyond what is listed above. However, there are various tools included that you may find useful during a real-time scan session. For instance, the tool \ncreateMask\n can be used to transform a standard space ROI mask to the subject's functional space, which can then be used as a mask for analysis during a real-time scan.\n\n\nIn order to use these additional tools, make sure you have installed the following:\n\n\n\n\nFSL 5.0",
            "title": "Installation"
        },
        {
            "location": "/installation/#installation",
            "text": "Pyneal is built and tested using  Python 3.6  Download Python from  https://www.python.org/downloads/  or via a distribution like  Anaconda  Pyneal requires additional libraries beyond the standard library. Instructions below use  pip  to install these libraries. Verify that you have  pip  installed:   which pip   If not, download and install pip from  https://pip.pypa.io/en/stable/installing/",
            "title": "Installation"
        },
        {
            "location": "/installation/#download-pyneal",
            "text": "Download the  Pyneal repository  from GitHub, or clone to your local machine:   git clone https://github.com/jeffmacinnes/pyneal.git   The installation instructions are broken down by  Pyneal Scanner  and  Pyneal . If you haven't already, read the section on  definitions , as those definitions are used throughout these instructions.",
            "title": "Download Pyneal"
        },
        {
            "location": "/installation/#pyneal-scanner",
            "text": "The  pyneal_scanner  directory needs to be on the  scanner computer . If the  scanner computer  is different from the  analysis computer  in your environment, copy the  pyneal_scanner  directory to the  scanner computer .",
            "title": "Pyneal-Scanner"
        },
        {
            "location": "/installation/#dependencies",
            "text": "The  scanner computer  requires additional  python  libraries in order to run  Pyneal Scanner .  You can attempt to install all required libraries at once by navigating into the  pyneal_scanner  directory and typing:   pip install -r requirements.txt   If that fails for any reason, you can install manually one at a time:   pip install numpy==1.13.1 \npip install pydicom==1.0.2 \npip install nibabel==2.1.0 \npip install pyzmq==16.0.2 \npip install pyyaml==3.12   These versions reflect the primary environment in which  Pyneal  is tested. It is likely that other versions maintain compatibility, but use at your own risk.",
            "title": "dependencies"
        },
        {
            "location": "/installation/#pyneal",
            "text": "The  pyneal  directory needs to be on the  analysis computer .",
            "title": "Pyneal"
        },
        {
            "location": "/installation/#dependencies_1",
            "text": "The  analysis computer  requires additional  python  libraries in order to run  Pyneal .  You can attempt to install all required libraries at once by navigating into the  pyneal  directory and typing:   pip install -r requirements.txt   If that fails for any reason, you can install manually one at a time:   pip install numpy==1.13.1 \npip install nibabel==2.1.0 \npip install nipy==0.4.1 \npip install pyzmq==16.0.2 \npip install pyyaml==3.12 \npip install kivy==1.10.dev0 \npip install flask==0.12.2 \npip install flask_socketio==2.9.2 \npip install eventlet==0.21.0     These versions reflect the primary environment in which  Pyneal  is tested. It is likely that other versions maintain compatibility, but use at your own risk.  Some users have reported problems installing the development version of kivy (under Pyneal dependencies). For assistance with this step, and other issues, see  Troubleshooting",
            "title": "dependencies"
        },
        {
            "location": "/installation/#additional-tools",
            "text": "Pyneal  itself does not require any additional libaries beyond what is listed above. However, there are various tools included that you may find useful during a real-time scan session. For instance, the tool  createMask  can be used to transform a standard space ROI mask to the subject's functional space, which can then be used as a mask for analysis during a real-time scan.  In order to use these additional tools, make sure you have installed the following:   FSL 5.0",
            "title": "Additional Tools"
        },
        {
            "location": "/setup/",
            "text": "Setup\n\u00b6\n\n\nThe set-up instructions are broken down by \nPyneal Scanner\n and \nPyneal\n. If you haven't already, follow the \ninstallation instructions\n to configure your environment, and read the section on \ndefinitions\n, as those definitions are used throughout these instructions.\n\n\nOnce you have finished setting up \nPyneal Scanner\n and \nPyneal\n, are you ready to begin testing your install using the various \nsimulation tools\n. These tools are also helpful in troubleshooting any issues you may run into during install/setup. \n\n\nPyneal Scanner\n\u00b6\n\n\nCopy the \npyneal_scanner\n directory to the \nscanner computer\n.\n\n\nLaunch \nPyneal Scanner\n from the command line by navigating in to the \npyneal_scanner\n directory and running \npynealScanner.py\n\n\n\n\ncd pyneal_scanner\n\npython pynealScanner.py\n\n\n\n\nPyneal Scanner\n uses a set of configuration parameters that you can modify to fit your environment. These are stored in file named \nscannerConfig.yaml\n in the \npyneal_scanner\n directory.\n\n\nIf you're running \nPyneal Scanner\n for the first time, this file won't exist yet. You can either create this file manually, or wait until \npynealScanner.py\n prompts you to fill in any missing configuration values from the command line. Any values you enter from the command line will be saved in a new \nscannerConfig.yaml\n file.\n\n\nThe \nscannerConfig.yaml\n file allows you to customize \nPyneal Scanner\n to your scanning environment. The file contains just a few parameters stored as \nkey:value\n pairs:\n\n\nscannerBaseDir: /path/to/new/scans\nscannerMake: GE\npynealSocketHost: 127.0.0.1\npynealSocketPort: '9999'\n\n\n\n\nConfiguration Keys\n:\n\n\n\n\n\n\nscannerBaseDir\n: The \nfixed\n portion of the directory path to where new reconstructed images will be appear during a scan. That is, the part that remains constant from scan to scan. Knowing what to set this value to can differ accroding to different scanner manufacturers:\n\n\n\n\n\n\nGE\n: During a scan, new slices dicom files are written to a directory on the scanner console. The path to that directory can be broken apart like \n[scannerBaseDir]/[sessionDir]/[seriesDir]\n, where\n\n\n\n\n[scannerBaseDir]\n: path that remains constant across all scans\n\n\n[sessionDir]\n: directories that can change from session to session, named like \np###/e###\n where the specific \n#\n values are unknown in advance.\n\n\n[seriesDir]\n: series specific directory named like \ns###\n where the specific \n#\n values are unknown in advance. Each new scan during a given exam session will be assigned a unique \ns###\n dir.\n\n\n\n\nYou only need to specify the path to the \nscannerBaseDir\n in the \nscannerConfig.yaml\n file; \nPyneal Scanner\n will automaticaly find the most recently modified session and series directories and monitor for new series directories to appear. When you run \npynealScanner.py\n you will see a printout in the terminal window about the names, sizes, and modification dates of all series directories in the session directory.\n\n\n\n\n\n\nSiemens\n: Siemens scanners can export reconstructed dicom images to a remote directory. The dicom images are mosaic files, one per volume, in which all slices from the volume are arranged in a 2D grid (er, mosaic, if you will). Siemens will export all files from your session to the same directory; the series number associated with each file can be found in the file name. \n\n\n\n\n[scannerBaseDir]\n: path to remote directory that will receive all files throughout the session.\n\n\n\n\n\n\n\n\nPhilips\n: Philips scanners have the option to export reconstructed PAR/REC files to a remote directory. The path to that directory can be broken apart like \n[scannerBaseDir]/[seriesDir]\n, where\n\n\n\n\n[scannerBaseDir]\n: path to remote directory that remains constant across all scans\n\n\n[seriesDir]\n: series specific directory named like \n####\n\n\n\n\n\n\n\n\nYou only need to specify the path to the \nscannerBaseDir\n in the \nscannerConfig.yaml\n file; \nPyneal Scanner\n will monitor for new series directories and/or files to appear.  \n\n\n\n\n\n\nscannerMake\n: Scanner Manufacturer, must be one of \nGE\n, \nSiemens\n, or \nPhilips\n (case sensitive)\n\n\n\n\npynealSocketHost\n: I.P. address of the \nanalysis computer\n running \nPyneal\n. If the analysis and scanner computers are the same, you can use \n127.0.0.1\n, otherwise you must specify an I.P. for the analysis computer that is accessible to remote computers. \n\n\npynealSocketPort\n: The port number over which \nPyneal\n is listening for incoming data.\n\n\n\n\nPyneal\n\u00b6\n\n\nLaunch \nPyneal\n from the command line by navigating in to the \npyneal\n directory and running \npyneal.py\n\n\n\n\ncd pyneal \n\npython pyneal.py\n\n\n\n\nThe \nPyneal\n configuration is set via GUI. When you launch \npyneal.py\n a GUI will appear, allowing you to configure \nPyneal\n to the current experiment\n\n\n\n\n\n\n\n\nCommunication\n:\n\n\n\n\nPyneal Host IP\n: The IP address of the machine running \nPyneal\n (i.e. the \nanalysis machine\n). This is the IP address that \nPyneal Scanner\n will try to connect to, as well as any end user that is making requests for results. Make sure, therefore, that this is an IP address that is accessible to any remote machine that needs it. If you are doing everything locally from the same machine (e.g. testing, running simulations, etc), you can set this to the local host, or loopback address, at \n127.0.0.1\n. However, in all other situations, you'll probably want this to be the unique IP address assigned to the network card in the \nanalysis machine\n. \n\n\nPyneal-Scanner Port\n: The port number over which \nPyneal\n will be listening for incoming data from \nPyneal Scanner\n. Note that this number should match the port number specified in the \npynealSocketPort\n configuration field of the \nPyneal Scanner\n set up.\n\n\nResults Server Port\n: The port number that \nPyneal\n will use to set up the \nResults Server\n. Remote machines that wish to retrieve real-time analysis output during a scan can send requests over this port number. See Formatting Results Server Requests [TODO]\n\n\n\n\n\n\n\n\nMask\n: Path to mask file (Nifti - .nii/.nii.gz) to be used during real-time analysis. Each incoming 3D volume will be masked to remove non-relevant voxels. The mask \nmust\n match the dimensions and orientation of incoming functional data [see \nCreating Masks\n for Real-time Analysis]. The mask will limit which voxels get passed on to the analysis stage. So, for example:\n\n\n\n\nTo calculate the \nAverage\n ROI activation at every timepoint, choose a mask file that represents the target ROI.\n\n\nIf \nWeighted Mask?\n is checked, the voxel values will be used as weights during the analysis.   \n\n\nFor a \nCustom\n analysis that uses the entire brain volume, choose a mask file that represents a whole brain mask [see Creating Masks for Real-time Analysis TODO].\n\n\n\n\n\n\n\n\nPreprocessing\n: Set the number of timepoints for the current scan\n\n\n\n\n\n\nAnalysis\n: Real-time analysis options. The analysis you select will be computed at every timepoint throughout the scan.\n\n\n\n\nAverage\n: Compute the average activation at each timepoint across all voxels within the mask\n\n\nMedian\n: Compute the median activation at each timepoint across all voxels within the mask\n\n\nCustom\n: Choose a custom analysis script. This script will be executed at each new timepoint [see Setting up Custom Analysis Scripts TODO]\n\n\n\n\n\n\n\n\nOutput\n:\n\n\n\n\nChoose an output directory to store logs and results from the current session. The output from each new series will be stored as a subdirectory in this directory, named sequentially like 'pyneal_001'.  \n\n\nLaunch Dashboard\n: Check this box to launch an interactive dashboard that will allow you to monitor the status of the scan once it begins.\n\n\n\n\n\n\n\n\nBehind the scenes, all of the relevant \nPyneal\n configuration settings are stored as \nkey:value\n pairs in a file stored at \npyneal/src/setupConfig.yaml\n. (In fact, the GUI simply reads this file at launch to get the previous configuration options, and then overwrites this file with the current GUI options whenever you click \nsubmit\n).\n\n\npynealHost: 127.0.0.1\npynealScannerPort: 5555\nresultsServerPort: 5556\nmaskFile: /path/to/mask/file.nii.gz\nmaskIsWeighted: false\nnumTimePts: 60\nanalysisChoice: Average\noutputPath: /path/to/store/output\nlaunchDashboard: true\ndashboardPort: 5557\ndashboardClientPort: 5558\n\n\n\n\nConfiguration Keys\n:\n\n\n\n\npynealHost\n:  The IP address of the machine running \nPyneal\n (i.e. the \nanalysis machine\n). This is the IP address that \nPyneal Scanner\n will try to connect to, as well as any end user that is making requests for results.\n\n\npynealScannerPort\n: Port number over which \nPyneal\n will be listening for incoming data\n\n\nresultsServerPort\n: Port number that \nPyneal\n will use to set up the \nResults Server\n\n\nmaskFile\n: Path to mask file (Nifti - .nii/.nii.gz) to be used during real-time analysis\n\n\nmaskIsWeighted\n: Voxel values in mask represent weights [true/false]\n\n\nnumTimePts\n: Number of timepoints in current scan\n\n\nanalysisChoice\n: Real-time analysis options [Average/Median/Path to custom analysis file]\n\n\noutputPath\n: Path to output directory where logs and results will be saved\n\n\nlaunchDashboard\n: Launch dashboard to monitor real-time scan [true/false]\n\n\ndashboardPort\n: Port number over which to launch the dashboard webserver (\nNOTE:\n this key does not appear in the setup GUI)\n\n\ndashboardClientPort\n: Port number that browsers can use to connect to the dashboard (\nNOTE:\n this key does not appear in the setup GUI)\n\n\n\n\nAt the top of the setup GUI you have the option to load a custom settings file. A custom settings should be a \n.yaml\n file with values for one or more of the configuration keys above. By loading a custom settings file, the GUI will be populated with whichever configure keys are included; any non-included keys will get their values from the \nsetupConfig.yaml\n file as normal.\n\n\nThe option allows users to create settings files on a per-project basis, and easily configure \nPyneal\n to match the project demands.",
            "title": "Setup"
        },
        {
            "location": "/setup/#setup",
            "text": "The set-up instructions are broken down by  Pyneal Scanner  and  Pyneal . If you haven't already, follow the  installation instructions  to configure your environment, and read the section on  definitions , as those definitions are used throughout these instructions.  Once you have finished setting up  Pyneal Scanner  and  Pyneal , are you ready to begin testing your install using the various  simulation tools . These tools are also helpful in troubleshooting any issues you may run into during install/setup.",
            "title": "Setup"
        },
        {
            "location": "/setup/#pyneal-scanner",
            "text": "Copy the  pyneal_scanner  directory to the  scanner computer .  Launch  Pyneal Scanner  from the command line by navigating in to the  pyneal_scanner  directory and running  pynealScanner.py   cd pyneal_scanner \npython pynealScanner.py   Pyneal Scanner  uses a set of configuration parameters that you can modify to fit your environment. These are stored in file named  scannerConfig.yaml  in the  pyneal_scanner  directory.  If you're running  Pyneal Scanner  for the first time, this file won't exist yet. You can either create this file manually, or wait until  pynealScanner.py  prompts you to fill in any missing configuration values from the command line. Any values you enter from the command line will be saved in a new  scannerConfig.yaml  file.  The  scannerConfig.yaml  file allows you to customize  Pyneal Scanner  to your scanning environment. The file contains just a few parameters stored as  key:value  pairs:  scannerBaseDir: /path/to/new/scans\nscannerMake: GE\npynealSocketHost: 127.0.0.1\npynealSocketPort: '9999'  Configuration Keys :    scannerBaseDir : The  fixed  portion of the directory path to where new reconstructed images will be appear during a scan. That is, the part that remains constant from scan to scan. Knowing what to set this value to can differ accroding to different scanner manufacturers:    GE : During a scan, new slices dicom files are written to a directory on the scanner console. The path to that directory can be broken apart like  [scannerBaseDir]/[sessionDir]/[seriesDir] , where   [scannerBaseDir] : path that remains constant across all scans  [sessionDir] : directories that can change from session to session, named like  p###/e###  where the specific  #  values are unknown in advance.  [seriesDir] : series specific directory named like  s###  where the specific  #  values are unknown in advance. Each new scan during a given exam session will be assigned a unique  s###  dir.   You only need to specify the path to the  scannerBaseDir  in the  scannerConfig.yaml  file;  Pyneal Scanner  will automaticaly find the most recently modified session and series directories and monitor for new series directories to appear. When you run  pynealScanner.py  you will see a printout in the terminal window about the names, sizes, and modification dates of all series directories in the session directory.    Siemens : Siemens scanners can export reconstructed dicom images to a remote directory. The dicom images are mosaic files, one per volume, in which all slices from the volume are arranged in a 2D grid (er, mosaic, if you will). Siemens will export all files from your session to the same directory; the series number associated with each file can be found in the file name.    [scannerBaseDir] : path to remote directory that will receive all files throughout the session.     Philips : Philips scanners have the option to export reconstructed PAR/REC files to a remote directory. The path to that directory can be broken apart like  [scannerBaseDir]/[seriesDir] , where   [scannerBaseDir] : path to remote directory that remains constant across all scans  [seriesDir] : series specific directory named like  ####     You only need to specify the path to the  scannerBaseDir  in the  scannerConfig.yaml  file;  Pyneal Scanner  will monitor for new series directories and/or files to appear.      scannerMake : Scanner Manufacturer, must be one of  GE ,  Siemens , or  Philips  (case sensitive)   pynealSocketHost : I.P. address of the  analysis computer  running  Pyneal . If the analysis and scanner computers are the same, you can use  127.0.0.1 , otherwise you must specify an I.P. for the analysis computer that is accessible to remote computers.   pynealSocketPort : The port number over which  Pyneal  is listening for incoming data.",
            "title": "Pyneal Scanner"
        },
        {
            "location": "/setup/#pyneal",
            "text": "Launch  Pyneal  from the command line by navigating in to the  pyneal  directory and running  pyneal.py   cd pyneal  \npython pyneal.py   The  Pyneal  configuration is set via GUI. When you launch  pyneal.py  a GUI will appear, allowing you to configure  Pyneal  to the current experiment     Communication :   Pyneal Host IP : The IP address of the machine running  Pyneal  (i.e. the  analysis machine ). This is the IP address that  Pyneal Scanner  will try to connect to, as well as any end user that is making requests for results. Make sure, therefore, that this is an IP address that is accessible to any remote machine that needs it. If you are doing everything locally from the same machine (e.g. testing, running simulations, etc), you can set this to the local host, or loopback address, at  127.0.0.1 . However, in all other situations, you'll probably want this to be the unique IP address assigned to the network card in the  analysis machine .   Pyneal-Scanner Port : The port number over which  Pyneal  will be listening for incoming data from  Pyneal Scanner . Note that this number should match the port number specified in the  pynealSocketPort  configuration field of the  Pyneal Scanner  set up.  Results Server Port : The port number that  Pyneal  will use to set up the  Results Server . Remote machines that wish to retrieve real-time analysis output during a scan can send requests over this port number. See Formatting Results Server Requests [TODO]     Mask : Path to mask file (Nifti - .nii/.nii.gz) to be used during real-time analysis. Each incoming 3D volume will be masked to remove non-relevant voxels. The mask  must  match the dimensions and orientation of incoming functional data [see  Creating Masks  for Real-time Analysis]. The mask will limit which voxels get passed on to the analysis stage. So, for example:   To calculate the  Average  ROI activation at every timepoint, choose a mask file that represents the target ROI.  If  Weighted Mask?  is checked, the voxel values will be used as weights during the analysis.     For a  Custom  analysis that uses the entire brain volume, choose a mask file that represents a whole brain mask [see Creating Masks for Real-time Analysis TODO].     Preprocessing : Set the number of timepoints for the current scan    Analysis : Real-time analysis options. The analysis you select will be computed at every timepoint throughout the scan.   Average : Compute the average activation at each timepoint across all voxels within the mask  Median : Compute the median activation at each timepoint across all voxels within the mask  Custom : Choose a custom analysis script. This script will be executed at each new timepoint [see Setting up Custom Analysis Scripts TODO]     Output :   Choose an output directory to store logs and results from the current session. The output from each new series will be stored as a subdirectory in this directory, named sequentially like 'pyneal_001'.    Launch Dashboard : Check this box to launch an interactive dashboard that will allow you to monitor the status of the scan once it begins.     Behind the scenes, all of the relevant  Pyneal  configuration settings are stored as  key:value  pairs in a file stored at  pyneal/src/setupConfig.yaml . (In fact, the GUI simply reads this file at launch to get the previous configuration options, and then overwrites this file with the current GUI options whenever you click  submit ).  pynealHost: 127.0.0.1\npynealScannerPort: 5555\nresultsServerPort: 5556\nmaskFile: /path/to/mask/file.nii.gz\nmaskIsWeighted: false\nnumTimePts: 60\nanalysisChoice: Average\noutputPath: /path/to/store/output\nlaunchDashboard: true\ndashboardPort: 5557\ndashboardClientPort: 5558  Configuration Keys :   pynealHost :  The IP address of the machine running  Pyneal  (i.e. the  analysis machine ). This is the IP address that  Pyneal Scanner  will try to connect to, as well as any end user that is making requests for results.  pynealScannerPort : Port number over which  Pyneal  will be listening for incoming data  resultsServerPort : Port number that  Pyneal  will use to set up the  Results Server  maskFile : Path to mask file (Nifti - .nii/.nii.gz) to be used during real-time analysis  maskIsWeighted : Voxel values in mask represent weights [true/false]  numTimePts : Number of timepoints in current scan  analysisChoice : Real-time analysis options [Average/Median/Path to custom analysis file]  outputPath : Path to output directory where logs and results will be saved  launchDashboard : Launch dashboard to monitor real-time scan [true/false]  dashboardPort : Port number over which to launch the dashboard webserver ( NOTE:  this key does not appear in the setup GUI)  dashboardClientPort : Port number that browsers can use to connect to the dashboard ( NOTE:  this key does not appear in the setup GUI)   At the top of the setup GUI you have the option to load a custom settings file. A custom settings should be a  .yaml  file with values for one or more of the configuration keys above. By loading a custom settings file, the GUI will be populated with whichever configure keys are included; any non-included keys will get their values from the  setupConfig.yaml  file as normal.  The option allows users to create settings files on a per-project basis, and easily configure  Pyneal  to match the project demands.",
            "title": "Pyneal"
        },
        {
            "location": "/quickOverview/",
            "text": "Quick Overview\n\u00b6\n\n\nThis section will provide a quick overview of running a scan with Pyneal. The aim is to  familiarize you with the interface and commands you would use during a scan session, without getting lost in the details about what is happening underneath the hood. \n\n\nFor a more in-depth discussion of the main components, see \nPyneal Scanner\n and \nPyneal\n.\n\n\nData flow\n\u00b6\n\n\nThis schematic gives a very broad overview of the path that data follows throughout a real-time scan with \nPyneal\n\n\n\n\n\n\nOnce the scan begins, raw images are collected by *\nPyneal Scanner\n, and then converted and reoriented to a standardized format (see \nimage orientation\n for more info). \n\n\nPyneal Scanner\n exports converted 3D volumes to \nPyneal\n.\n\n\nPyneal\n receives 3D volumes, and concatenates them into a 4D volume over time throughout the scan. With every new 3D volume that arrives, \nPyneal\n will \npreprocess\n the volume, and run any specified analyses. \n\n\nThe analysis results for each volume are stored on a separate server, which listens for requests from remote end users or devices throughout the scan (see \nrequesting results\n for more info). \n\n\nAnytime a request is received, the server checks to see if that volume has been processed yet. If so, it returns the results; if not, it sends a message saying that volume has not been processed yet\n\n\n\n\nPrior to the scan...\n\u00b6\n\n\n\n\n\n\nMake sure you have followed the \ninstallation\n and \nsetup\n instructions. \n\n\n\n\n\n\nFigure out the IP address of the machine that is going to be the \nanalysis computer\n running \nPyneal\n. You'll need this address in order to configure \nPyneal Scanner\n, as well as to request any results during the scan itself. This IP address must be accessible from the same network as the \nscanner computer\n (and any \nend user\n computer that will be making requests to \nPyneal\n for results during the scan)\n\n\n\n\n\n\nDetermine the port numbers to use for commmuncation. Pyneal will need to have one available port number dedicated for communication with \nPyneal Scanner\n, and an additional port number dedicated for communication with remote end users or devices. \n\n\n\n\nIf you don't know which port numbers to use, try choosing ones in the range of 1024-49151. If you happen to choose a port number that is already in use, \nPyneal\n will return an error message. In that event, try a different number. \n\n\n\n\n\n\n\n\nOnce you have determined the IP address and port numbers to use with \nPyneal\n on the \nanalysis computer\n, complete the \nset up steps for Pyneal Scanner",
            "title": "Quick Overview"
        },
        {
            "location": "/quickOverview/#quick-overview",
            "text": "This section will provide a quick overview of running a scan with Pyneal. The aim is to  familiarize you with the interface and commands you would use during a scan session, without getting lost in the details about what is happening underneath the hood.   For a more in-depth discussion of the main components, see  Pyneal Scanner  and  Pyneal .",
            "title": "Quick Overview"
        },
        {
            "location": "/quickOverview/#data-flow",
            "text": "This schematic gives a very broad overview of the path that data follows throughout a real-time scan with  Pyneal    Once the scan begins, raw images are collected by * Pyneal Scanner , and then converted and reoriented to a standardized format (see  image orientation  for more info).   Pyneal Scanner  exports converted 3D volumes to  Pyneal .  Pyneal  receives 3D volumes, and concatenates them into a 4D volume over time throughout the scan. With every new 3D volume that arrives,  Pyneal  will  preprocess  the volume, and run any specified analyses.   The analysis results for each volume are stored on a separate server, which listens for requests from remote end users or devices throughout the scan (see  requesting results  for more info).   Anytime a request is received, the server checks to see if that volume has been processed yet. If so, it returns the results; if not, it sends a message saying that volume has not been processed yet",
            "title": "Data flow"
        },
        {
            "location": "/quickOverview/#prior-to-the-scan",
            "text": "Make sure you have followed the  installation  and  setup  instructions.     Figure out the IP address of the machine that is going to be the  analysis computer  running  Pyneal . You'll need this address in order to configure  Pyneal Scanner , as well as to request any results during the scan itself. This IP address must be accessible from the same network as the  scanner computer  (and any  end user  computer that will be making requests to  Pyneal  for results during the scan)    Determine the port numbers to use for commmuncation. Pyneal will need to have one available port number dedicated for communication with  Pyneal Scanner , and an additional port number dedicated for communication with remote end users or devices.    If you don't know which port numbers to use, try choosing ones in the range of 1024-49151. If you happen to choose a port number that is already in use,  Pyneal  will return an error message. In that event, try a different number.      Once you have determined the IP address and port numbers to use with  Pyneal  on the  analysis computer , complete the  set up steps for Pyneal Scanner",
            "title": "Prior to the scan..."
        },
        {
            "location": "/pynealScanner/",
            "text": "Pyneal Scanner\n\u00b6\n\n\nTODO",
            "title": "Pyneal Scanner"
        },
        {
            "location": "/pynealScanner/#pyneal-scanner",
            "text": "TODO",
            "title": "Pyneal Scanner"
        },
        {
            "location": "/pyneal/",
            "text": "Pyneal\n\u00b6\n\n\nBefore a real-time scan\n\u00b6\n\n\nCreating Masks\n\u00b6\n\n\nPyneal requires the user to supply a mask that will specify which voxels to include during the real-time analysis. \n\n\nThis mask can take any form you want, with the caveat that it \nmust\n be in the same space (i.e. voxel size, image resolution, and orientation) as the incoming functional data throughout the real-time scan.\n\n\nExamples:\n\u00b6\n\n\n\n\n\n\nMask from functional ROI\n: You could include a mask that represents voxels with significant task-induced activation from the current subject. To do so, include a quick localizer task at the beginning of your session that you can access offline (for instance, by using the \ngetSeries.py\n tool in \nPyneal Scanner\n) and analyze. Threshold and/or binarize the resulting statistical maps as appropriate, and create a funtional ROI mask file. \n\n\n\n\n\n\nMask from anatomical ROI\n: You can create a subject-specific anatomical ROI mask by transforming a preselected MNI space mask to the participant's functional space. \nPyneal\n includes an automated tool to assist in this process. See \nCreating Masks\n under \nAdditonal Tools\n \n\n\n\n\n\n\nChoosing Analyses\n\u00b6\n\n\nDuring a real-time scan\n\u00b6\n\n\nPyneal Dashboard\n\u00b6\n\n\nRequesting Results\n\u00b6\n\n\nAfter a real-time scan\n\u00b6",
            "title": "Pyneal"
        },
        {
            "location": "/pyneal/#pyneal",
            "text": "",
            "title": "Pyneal"
        },
        {
            "location": "/pyneal/#before-a-real-time-scan",
            "text": "",
            "title": "Before a real-time scan"
        },
        {
            "location": "/pyneal/#creating-masks",
            "text": "Pyneal requires the user to supply a mask that will specify which voxels to include during the real-time analysis.   This mask can take any form you want, with the caveat that it  must  be in the same space (i.e. voxel size, image resolution, and orientation) as the incoming functional data throughout the real-time scan.",
            "title": "Creating Masks"
        },
        {
            "location": "/pyneal/#examples",
            "text": "Mask from functional ROI : You could include a mask that represents voxels with significant task-induced activation from the current subject. To do so, include a quick localizer task at the beginning of your session that you can access offline (for instance, by using the  getSeries.py  tool in  Pyneal Scanner ) and analyze. Threshold and/or binarize the resulting statistical maps as appropriate, and create a funtional ROI mask file.     Mask from anatomical ROI : You can create a subject-specific anatomical ROI mask by transforming a preselected MNI space mask to the participant's functional space.  Pyneal  includes an automated tool to assist in this process. See  Creating Masks  under  Additonal Tools",
            "title": "Examples:"
        },
        {
            "location": "/pyneal/#choosing-analyses",
            "text": "",
            "title": "Choosing Analyses"
        },
        {
            "location": "/pyneal/#during-a-real-time-scan",
            "text": "",
            "title": "During a real-time scan"
        },
        {
            "location": "/pyneal/#pyneal-dashboard",
            "text": "",
            "title": "Pyneal Dashboard"
        },
        {
            "location": "/pyneal/#requesting-results",
            "text": "",
            "title": "Requesting Results"
        },
        {
            "location": "/pyneal/#after-a-real-time-scan",
            "text": "",
            "title": "After a real-time scan"
        },
        {
            "location": "/simulations/",
            "text": "Simulations\n\u00b6\n\n\nOverview\n\u00b6\n\n\nIn order to help with the initial setup, as well as test any analysis scripts and network communications later on, \nPyneal\n includes a suite of simulation tools that mimic various inputs and outputs along the data flow path.\n\n\nThese tools allow you to simulate \nPyneal\n (or \nPyneal Scanner\n) in a modular fashion without having to run the entire pipeline. If you are troubleshooting issues, these tools are immensely helpful.  \n\n\nHere is a diagram highlighting the various simulation tools, and where they enter the data flow pipeline. \n\n\n\n\nDuring an actual real-time scan, data will flow through this diagram from left to right along the blue arrows. \n\n\nSimulation tools are indicated using dashed or dotted vertical lines.\n\n\n\n\n\n\nA dashed line indicates a simulation tool that \ngenerates input\n. In other words, these tools mimic real data as it exists at a particular stage of the pipeline\n\n\n\n\n\n\nA dotted line indicates a simulation tool that \nreceives output\n. In other words, these tools allow you to simulate the \nnext\n stage of the pipeline\n\n\n\n\n\n\nBoth \nPyneal Scanner\n and \nPyneal\n have their own set of simulation tools. \n\n\n\n\n\n\nPyneal Scanner\n simulation tools can be found in \npyneal/pyneal_scanner/simulation\n and are shown in light blue \nbelow\n the real data pipeline in the schematic. See below for more details\n\n\n\n\n\n\nPyneal\n simulation tools can be found in \npyneal/utils/simulation\n and are shown in green \nabove\n the real data pipeline in the schematic. See below for more details\n\n\n\n\n\n\nPyneal Scanner Simulation Tools\n\u00b6\n\n\nThe \nPyneal Scanner\n simulation tools can be found in \npyneal/pyneal_scanner/simulation\n\n\n\n\nScanner Simulators\n: Set of simulation scripts to mimic the behavior of real scanners with real data. \n\n\npynealReceiver_sim.py\n: simulates the behavior of \nPyneal\n (i.e. accepts incoming 3D volumes from \nPyneal Scanner\n)\n\n\n\n\nScanner Simulators\n\u00b6\n\n\nUse Case:\n Testing \nPyneal Scanner\n (and \nanything else\n downstream) with real data.\n\n\n\n\nThis will simulate the appearance of raw data coming off of the scanner. This works by pointing the simulator to a folder containing real scanner data. The simulator will copy the real data to a new directory in a way that mimics the behavior of a real scan, allowing you to test \nPyneal Scanner\n and anything else downstream. \n\n\nThe format of the raw data will vary according to different scanner environments/manufacturers. Accordingly, there are multiple scripts that will simulate different scanner formats:\n\n\nGE\n\u00b6\n\n\nusage\n: \npython GE_sim.py inputDir [-o outputDir -t/--TR TR]\n\n\ninput args\n:  \n\n\n\n\ninputDir: path to directory containing raw slice dicom images. \n\n\n-o outputDir: path to directory where slices will be copied to [default: create new directory named \ns9999\n in the parent directory of the inputDir]\n\n\n-t/--TR TR: set the TR in ms [default: 1000]\n\n\n\n\nGE scanners \n\n\nIn order to run this script, you must have a local directory that contains raw slice dicom files from an actual scan. If you want to fully mimic the data directory structure of GE scanners, you can create a local directory path that follows the pattern \n[baseDir]/p##/e##/s##\n where the slice images are stored in a directory named like \ns###\n, which is nested two levels deep (\np###/e###\n) from the \n[basedir]\n. \n\n\nThis script will copy all of the slices from the inputDir and copy them to the outputDir at a rate that is set by the TR. \n\n\nAfter the script has completed, the outputDir will be deleted. \n\n\nPhilips\n\u00b6\n\n\nusage\n: \npython Philips_sim.py inputDir [--outputDir] [--TR]\n\n\ninput args\n:\n\n\n\n\ninputDir: path to directory containing raw slice dicom images. \n\n\n-o outputDir: path to directory where slices will be copied to [default: create new directory named \n9999\n in the parent directory of the inputDir]\n\n\n-t/--TR TR: set the TR in ms [default: 1000]\n\n\n\n\nPhilips scanners use XTC (eXTernal Control) to output reconstructed volumes to a directory during a scan. The files are written to a designated directory (e.g. XTC_Output), and within that directory, every series is assigned a new directory named sequentially starting with '0000'. For instance, volumes from the 3rd series will be stored like '.../XTC_Output/0002/'. This script will simulate the creation of a new series directory, and copy in PAR/REC files.\n\n\nYou must specify a local path to the inputDir. That is, the directory that already\ncontains a set of reconstructed PAR/REC files for a series (referred to below as \nseriesDir\n). \n\n\n[OPTIONAL]: You can specify the full path to an output directory where the PAR/REC files\nwill be copied to. If you don't specify an output directory, this tool will default\nto creating a new \nseriesDir\n, named '9999' saved in the parent directory of the \nseriesDir\n.\n\n\ne.g. \npython Philips_sim.py /Path/To/My/Existing/Series/0000 --outputDir /Where/I/Want/New/Slice/Data/To/appear\n\n\nif you did not specify an outputDir, new PAR/RECs would be copied to:\n\n\n/Path/To/My/Existing/Series/9999\n\n\n[OPTIONAL]: You can specify the TR at which new PAR/REC data is copied. Default is 1000ms.\n\n\ne.g. \npython GE_sim.py /Path/To/My/Existing/Series/0000 --TR 2000\n\n\nSiemens\n\u00b6\n\n\nusage\n: \npython Siemens_sim.py inputDir seriesNum [--newSeriesNum] [--TR]\n\n\ninput args\n:\n\n\n\n\ninputDir: path to directory containing raw slice dicom images. \n\n\nseriesNum: series number of data that you want to simulate\n\n\n-n/--newSeriesNum: seriesNumber to assign to the new \"simulated\" data\n\n\n-t/--TR TR: set the TR in ms [default: 1000]\n\n\n\n\nSiemens scanners stores reconstructed slices images by taking all of the slices for a single volume, and placing them side-by-side in a larger \"mosaic\" dicom image. A scan will produce one mosaic image per volume, and all mosaic images for all scans across a single session will be stored in the same directory. This script simulates the creation of that directory, and will pass in real mosaic images.\n\n\nYou must specify a local path to the inputDir as well as the series number of the series you want to simulate.\n\n\nThe input dir should be the directory that already contains a set of reconstructed mosaic images. A single session dir will hold all of the mosaic files for all of the scans for a given session. Mosaic files are named like:\n\n\n[session#]_[series#]_[vol#].dcm\n\n\n[OPTIONAL]: You can specify the series number that will be assigned to the \"new\" mosaic images. The default behavior is to assign a series number based on the next sequential number given the existing series. In the example below, the default would be to assign a newSeriesNum as '2', but we are overriding that to assign it as '19'\n\n\ne.g. \npython Siemens_sim.py /Path/To/My/Existing/inputDir 1 --newSeriesNum 19\n\n\n[OPTIONAL]: You can specify the TR at which new slice data is copied. Default is 1000ms, and represents the approximate amount of time it should take to copy over all of the slices for one volume of data.\n\n\ne.g. \npython Siemens_sim.py /Path/To/My/Existing/inputDir 1 --TR 2000\n\n\npynealReceiver_sim.py\n\u00b6\n\n\nUse Case:\n When you want to test \nPyneal Scanner\n without having to actually run \nPyneal\n\n\n\n\nThis simulator will mimic the part of \nPyneal\n that accepts incoming 3D volumes from \nPyneal Scanner\n. This allows you to quickly test sending output with \nPyneal Scanner\n, without having to fully run \nPyneal\n (which entails a lot of extra overhead). \n\n\nusage: \npython pynealReceiver_sim.py\n\n\nThis simulator is hardcoded to be listening for incoming data on port \n5556\n. Make sure \nPyneal Scanner\n is configured to use that same port number for \npynealSocketPort\n (see \nPyneal Scanner Setup\n)\n\n\nPyneal Simulation Tools\n\u00b6",
            "title": "Simulations"
        },
        {
            "location": "/simulations/#simulations",
            "text": "",
            "title": "Simulations"
        },
        {
            "location": "/simulations/#overview",
            "text": "In order to help with the initial setup, as well as test any analysis scripts and network communications later on,  Pyneal  includes a suite of simulation tools that mimic various inputs and outputs along the data flow path.  These tools allow you to simulate  Pyneal  (or  Pyneal Scanner ) in a modular fashion without having to run the entire pipeline. If you are troubleshooting issues, these tools are immensely helpful.    Here is a diagram highlighting the various simulation tools, and where they enter the data flow pipeline.    During an actual real-time scan, data will flow through this diagram from left to right along the blue arrows.   Simulation tools are indicated using dashed or dotted vertical lines.    A dashed line indicates a simulation tool that  generates input . In other words, these tools mimic real data as it exists at a particular stage of the pipeline    A dotted line indicates a simulation tool that  receives output . In other words, these tools allow you to simulate the  next  stage of the pipeline    Both  Pyneal Scanner  and  Pyneal  have their own set of simulation tools.     Pyneal Scanner  simulation tools can be found in  pyneal/pyneal_scanner/simulation  and are shown in light blue  below  the real data pipeline in the schematic. See below for more details    Pyneal  simulation tools can be found in  pyneal/utils/simulation  and are shown in green  above  the real data pipeline in the schematic. See below for more details",
            "title": "Overview"
        },
        {
            "location": "/simulations/#pyneal-scanner-simulation-tools",
            "text": "The  Pyneal Scanner  simulation tools can be found in  pyneal/pyneal_scanner/simulation   Scanner Simulators : Set of simulation scripts to mimic the behavior of real scanners with real data.   pynealReceiver_sim.py : simulates the behavior of  Pyneal  (i.e. accepts incoming 3D volumes from  Pyneal Scanner )",
            "title": "Pyneal Scanner Simulation Tools"
        },
        {
            "location": "/simulations/#scanner-simulators",
            "text": "Use Case:  Testing  Pyneal Scanner  (and  anything else  downstream) with real data.   This will simulate the appearance of raw data coming off of the scanner. This works by pointing the simulator to a folder containing real scanner data. The simulator will copy the real data to a new directory in a way that mimics the behavior of a real scan, allowing you to test  Pyneal Scanner  and anything else downstream.   The format of the raw data will vary according to different scanner environments/manufacturers. Accordingly, there are multiple scripts that will simulate different scanner formats:",
            "title": "Scanner Simulators"
        },
        {
            "location": "/simulations/#ge",
            "text": "usage :  python GE_sim.py inputDir [-o outputDir -t/--TR TR]  input args :     inputDir: path to directory containing raw slice dicom images.   -o outputDir: path to directory where slices will be copied to [default: create new directory named  s9999  in the parent directory of the inputDir]  -t/--TR TR: set the TR in ms [default: 1000]   GE scanners   In order to run this script, you must have a local directory that contains raw slice dicom files from an actual scan. If you want to fully mimic the data directory structure of GE scanners, you can create a local directory path that follows the pattern  [baseDir]/p##/e##/s##  where the slice images are stored in a directory named like  s### , which is nested two levels deep ( p###/e### ) from the  [basedir] .   This script will copy all of the slices from the inputDir and copy them to the outputDir at a rate that is set by the TR.   After the script has completed, the outputDir will be deleted.",
            "title": "GE"
        },
        {
            "location": "/simulations/#philips",
            "text": "usage :  python Philips_sim.py inputDir [--outputDir] [--TR]  input args :   inputDir: path to directory containing raw slice dicom images.   -o outputDir: path to directory where slices will be copied to [default: create new directory named  9999  in the parent directory of the inputDir]  -t/--TR TR: set the TR in ms [default: 1000]   Philips scanners use XTC (eXTernal Control) to output reconstructed volumes to a directory during a scan. The files are written to a designated directory (e.g. XTC_Output), and within that directory, every series is assigned a new directory named sequentially starting with '0000'. For instance, volumes from the 3rd series will be stored like '.../XTC_Output/0002/'. This script will simulate the creation of a new series directory, and copy in PAR/REC files.  You must specify a local path to the inputDir. That is, the directory that already\ncontains a set of reconstructed PAR/REC files for a series (referred to below as  seriesDir ).   [OPTIONAL]: You can specify the full path to an output directory where the PAR/REC files\nwill be copied to. If you don't specify an output directory, this tool will default\nto creating a new  seriesDir , named '9999' saved in the parent directory of the  seriesDir .  e.g.  python Philips_sim.py /Path/To/My/Existing/Series/0000 --outputDir /Where/I/Want/New/Slice/Data/To/appear  if you did not specify an outputDir, new PAR/RECs would be copied to:  /Path/To/My/Existing/Series/9999  [OPTIONAL]: You can specify the TR at which new PAR/REC data is copied. Default is 1000ms.  e.g.  python GE_sim.py /Path/To/My/Existing/Series/0000 --TR 2000",
            "title": "Philips"
        },
        {
            "location": "/simulations/#siemens",
            "text": "usage :  python Siemens_sim.py inputDir seriesNum [--newSeriesNum] [--TR]  input args :   inputDir: path to directory containing raw slice dicom images.   seriesNum: series number of data that you want to simulate  -n/--newSeriesNum: seriesNumber to assign to the new \"simulated\" data  -t/--TR TR: set the TR in ms [default: 1000]   Siemens scanners stores reconstructed slices images by taking all of the slices for a single volume, and placing them side-by-side in a larger \"mosaic\" dicom image. A scan will produce one mosaic image per volume, and all mosaic images for all scans across a single session will be stored in the same directory. This script simulates the creation of that directory, and will pass in real mosaic images.  You must specify a local path to the inputDir as well as the series number of the series you want to simulate.  The input dir should be the directory that already contains a set of reconstructed mosaic images. A single session dir will hold all of the mosaic files for all of the scans for a given session. Mosaic files are named like:  [session#]_[series#]_[vol#].dcm  [OPTIONAL]: You can specify the series number that will be assigned to the \"new\" mosaic images. The default behavior is to assign a series number based on the next sequential number given the existing series. In the example below, the default would be to assign a newSeriesNum as '2', but we are overriding that to assign it as '19'  e.g.  python Siemens_sim.py /Path/To/My/Existing/inputDir 1 --newSeriesNum 19  [OPTIONAL]: You can specify the TR at which new slice data is copied. Default is 1000ms, and represents the approximate amount of time it should take to copy over all of the slices for one volume of data.  e.g.  python Siemens_sim.py /Path/To/My/Existing/inputDir 1 --TR 2000",
            "title": "Siemens"
        },
        {
            "location": "/simulations/#pynealreceiver_simpy",
            "text": "Use Case:  When you want to test  Pyneal Scanner  without having to actually run  Pyneal   This simulator will mimic the part of  Pyneal  that accepts incoming 3D volumes from  Pyneal Scanner . This allows you to quickly test sending output with  Pyneal Scanner , without having to fully run  Pyneal  (which entails a lot of extra overhead).   usage:  python pynealReceiver_sim.py  This simulator is hardcoded to be listening for incoming data on port  5556 . Make sure  Pyneal Scanner  is configured to use that same port number for  pynealSocketPort  (see  Pyneal Scanner Setup )",
            "title": "pynealReceiver_sim.py"
        },
        {
            "location": "/simulations/#pyneal-simulation-tools",
            "text": "",
            "title": "Pyneal Simulation Tools"
        },
        {
            "location": "/createMask/",
            "text": "Creating Masks\n\u00b6\n\n\nPyneal\n requires that you input a mask for use during real-time analysis. This mask must have the same voxel dimensions and image orientation as the incoming functional data.\n\n\nDepending on your real-time analysis needs, one option could be to create a functional ROI by collecting a localizer task run and quickly analyzing it during your scanning session. \n\n\nAlternatively, you may wish to focus your analysis on predefined anatomical ROIs. In this case, you need to transform an anatomical mask from a standard space (like MNI) to match the functional data of your participant in the scanner.  \n\n\nThe \ncreateMask.py\n tool will assist you in quickly creating whole-brain or anatomical masks during a real-time session. \n\n\ncreateMask\n provides you with two mask creation options:\n\n\n\n\n\n\nWhole Brain Mask\n: This option will create a whole brain mask from the functional data you supply. \n\n\n\n\n\n\nTransform mask from MNI space\n: This option will take a mask defined in MNI space and transform it to the dimensions and orientation of the functional data you supply.\n\n\n\n\n\n\nNote:\n Behind the scenes, createMask.py relies on various functions from FSL. Make sure you have installed \nFSL 5.0\n\n\nLaunching createMask\n\u00b6\n\n\nThe createMask tool is found in \npyneal/utils/createMask.py\n\n\nYou can launch the createMask GUI by navigating to the \nutils\n directory via the terminal and running \ncreateMask.py\n with Python\n\n\n\n\ncd utils\n\npython createMask.py\n\n\n\n\n\n\nSpecifying a reference 4D functional file\n\u00b6\n\n\nIn order to create masks, we need to know the voxel size, 3D volume dimensions, and image orientation of the functional data for the current session. The easiest way to get this data is to include a brief (30sec or less) functional scan near the beginning of your session. Use the exact same slice prescriptions and image settings as you plan to use during your real-time scans. \n\n\nAfter the scan has finished, use the \ngetSeries.py\n tool from \nPyneal Scanner\n to convert the images to a 4D nifti file. Note that \ngetSeries.py\n will automatically reorient the output data to RAS+ orientation. Thus, by using this data as our reference functional data we will create a mask that is also in RAS+. This is good since, during a real-time run, \nPyneal\n will be receiving data in RAS+ orientation (see \nimage orientation\n for more info) \n\n\ncreateMask.py\n will create an example 3D functional image for reference by taking the mean across time of the specified 4D functional. \n\n\nDeciding on a mask type\n\u00b6\n\n\nWhole Brain Mask\n\u00b6\n\n\nIf you check \nCreate whole-brain FUNC mask\n, a 3D whole-brain mask will be created using the 4D FUNC file as a reference. Every brain voxel will be labeled \n1\n and every non-brain voxel will be labeled \n0\n.\n\n\nThe output file will be found in \nmask_transforms/FUNC_masks/wholeBrain_FUNC_mask.nii.gz\n\n\nA whole-brain mask is useful in situations where you are using a custom analysis during real-time runs and want access to the entire 3D brain volume (e.g. calculating grand volume mean as a reference value for other steps in your analysis). \n\n\nTransform MNI space mask\n\u00b6\n\n\nMore commonly, your real-time analysis may focus on activation in one or more predefined regions of interest (ROIs). Before beginning your real-time run, you need to create a mask(s) of your desired ROI(s) that match the resolution and orientation of the participant's functional data. \n\n\ncreateMask.py\n offers a way to quickly transform a mask from MNI space to the required functional space. To do so, the following intermediate steps take place:\n\n\n\n\na transformation matrix is created mapping from MNI space to the participant's high-res anatomical image (\nmni2hires.mat\n)\n\n\na transformation matrix is created mapping from the participant's high-resolution anatomical image to the participant's functional data (\nhires2func.mat\n)  \n\n\na 3rd tranformation matrix is created by concatenating the previous two matrices in order to create a transformation mapping from MNI space to functional space (\nmni2func.mat\n) \n\n\n\n\nThe resulting \nmni2func.mat\n matrix is used to transform the specifed MNI-space mask to functional space. \n\n\nSpecify the following input to \ncreateMask.py\n when selecting \nTransform MNI mask to FUNC\n:\n\n\n\n\nhi-res ANAT\n: path to participant's high-resolution anatomical image, collected during the current scanning session\n\n\nMNI-standard\n: path to the MNI standard. This standard must be in the same space as the mask you wish to transform. For instance, if your mask is in MNI space with a resolution of 1mm, you must select the MNI152_T1_1mm standard image. Sample MNI standard images can be found in \npyneal/utils/MNI_templates\n\n\nMNI mask\n: The mask file you wish to transform\n\n\nOutput Prefix:\n: The output prefix that will be prepended to the transformed masks. \n\n\n\n\nOnce you hit \nSubmit\n, \ncreateMask.py\n will go about creating the necessary intermediate tranforms. Once complete, the new masks will open automatically in FSLeyes so that you may confirm that everything completed correctly. \n\n\n\n\nThe new masks (and intermedate files) will be saved to the output directory. \n\n\nOutput files\n\u00b6\n\n\nThe output from \ncreateMask.py\n will be saved to the same directory as the specified reference 4D file. Within that directory, you will find a new directory named \nmask_transforms\n that holds all of the output mask files and transformation matrices from \ncreateMask.py\n\n\nDepending on the type of mask you are creating, you will find some set of the following files:\n\n\n\n\nFUNC_masks/wholeBrain_FUNC_mask.nii.gz\n: whole brain mask in participant functional space\n\n\nFUNC_masks/<outputPrefix>_FUNC_mask.nii.gz\n: binarized version of the transformed MNI mask in participant functional space\n\n\nFUNC_masks/<outputPrefix>_FUNC_weighted.nii.gz\n: non-binarized version of the transformed MNI mask in participant functional space. If the MNI mask you used represents a probabilistic atlas, for instance, those voxel probabilities will be preserved in this file. \n\n\nexampleFunc.nii.gz\n: a 3D functional image created by averaging the input 4D FUNC file\n\n\nhires_brain.nii.gz\n: skull-stripped version of the input hi-res ANAT file\n\n\nhires_FUNC.nii.gz\n: hi-res anatomical image transformed to participant functional space\n\n\nmni_HIRES.nii.gz\n: MNI standard transformed to participant hi-res anatomical space\n\n\nhires2func.mat\n: transformation matrix mapping from hi-res anatomical space to participant functional space\n\n\nmni2hires.mat\n: transformation matrix mapping from MNI space to hi-res anatomical space\n\n\nmni2func.mat\n: transformation matrix mapping from MNI space to participant functional space\n\n\nmaskTransforms.log\n: log file detailing all of the steps that were carried out",
            "title": "Creating Masks"
        },
        {
            "location": "/createMask/#creating-masks",
            "text": "Pyneal  requires that you input a mask for use during real-time analysis. This mask must have the same voxel dimensions and image orientation as the incoming functional data.  Depending on your real-time analysis needs, one option could be to create a functional ROI by collecting a localizer task run and quickly analyzing it during your scanning session.   Alternatively, you may wish to focus your analysis on predefined anatomical ROIs. In this case, you need to transform an anatomical mask from a standard space (like MNI) to match the functional data of your participant in the scanner.    The  createMask.py  tool will assist you in quickly creating whole-brain or anatomical masks during a real-time session.   createMask  provides you with two mask creation options:    Whole Brain Mask : This option will create a whole brain mask from the functional data you supply.     Transform mask from MNI space : This option will take a mask defined in MNI space and transform it to the dimensions and orientation of the functional data you supply.    Note:  Behind the scenes, createMask.py relies on various functions from FSL. Make sure you have installed  FSL 5.0",
            "title": "Creating Masks"
        },
        {
            "location": "/createMask/#launching-createmask",
            "text": "The createMask tool is found in  pyneal/utils/createMask.py  You can launch the createMask GUI by navigating to the  utils  directory via the terminal and running  createMask.py  with Python   cd utils \npython createMask.py",
            "title": "Launching createMask"
        },
        {
            "location": "/createMask/#specifying-a-reference-4d-functional-file",
            "text": "In order to create masks, we need to know the voxel size, 3D volume dimensions, and image orientation of the functional data for the current session. The easiest way to get this data is to include a brief (30sec or less) functional scan near the beginning of your session. Use the exact same slice prescriptions and image settings as you plan to use during your real-time scans.   After the scan has finished, use the  getSeries.py  tool from  Pyneal Scanner  to convert the images to a 4D nifti file. Note that  getSeries.py  will automatically reorient the output data to RAS+ orientation. Thus, by using this data as our reference functional data we will create a mask that is also in RAS+. This is good since, during a real-time run,  Pyneal  will be receiving data in RAS+ orientation (see  image orientation  for more info)   createMask.py  will create an example 3D functional image for reference by taking the mean across time of the specified 4D functional.",
            "title": "Specifying a reference 4D functional file"
        },
        {
            "location": "/createMask/#deciding-on-a-mask-type",
            "text": "",
            "title": "Deciding on a mask type"
        },
        {
            "location": "/createMask/#whole-brain-mask",
            "text": "If you check  Create whole-brain FUNC mask , a 3D whole-brain mask will be created using the 4D FUNC file as a reference. Every brain voxel will be labeled  1  and every non-brain voxel will be labeled  0 .  The output file will be found in  mask_transforms/FUNC_masks/wholeBrain_FUNC_mask.nii.gz  A whole-brain mask is useful in situations where you are using a custom analysis during real-time runs and want access to the entire 3D brain volume (e.g. calculating grand volume mean as a reference value for other steps in your analysis).",
            "title": "Whole Brain Mask"
        },
        {
            "location": "/createMask/#transform-mni-space-mask",
            "text": "More commonly, your real-time analysis may focus on activation in one or more predefined regions of interest (ROIs). Before beginning your real-time run, you need to create a mask(s) of your desired ROI(s) that match the resolution and orientation of the participant's functional data.   createMask.py  offers a way to quickly transform a mask from MNI space to the required functional space. To do so, the following intermediate steps take place:   a transformation matrix is created mapping from MNI space to the participant's high-res anatomical image ( mni2hires.mat )  a transformation matrix is created mapping from the participant's high-resolution anatomical image to the participant's functional data ( hires2func.mat )    a 3rd tranformation matrix is created by concatenating the previous two matrices in order to create a transformation mapping from MNI space to functional space ( mni2func.mat )    The resulting  mni2func.mat  matrix is used to transform the specifed MNI-space mask to functional space.   Specify the following input to  createMask.py  when selecting  Transform MNI mask to FUNC :   hi-res ANAT : path to participant's high-resolution anatomical image, collected during the current scanning session  MNI-standard : path to the MNI standard. This standard must be in the same space as the mask you wish to transform. For instance, if your mask is in MNI space with a resolution of 1mm, you must select the MNI152_T1_1mm standard image. Sample MNI standard images can be found in  pyneal/utils/MNI_templates  MNI mask : The mask file you wish to transform  Output Prefix: : The output prefix that will be prepended to the transformed masks.    Once you hit  Submit ,  createMask.py  will go about creating the necessary intermediate tranforms. Once complete, the new masks will open automatically in FSLeyes so that you may confirm that everything completed correctly.    The new masks (and intermedate files) will be saved to the output directory.",
            "title": "Transform MNI space mask"
        },
        {
            "location": "/createMask/#output-files",
            "text": "The output from  createMask.py  will be saved to the same directory as the specified reference 4D file. Within that directory, you will find a new directory named  mask_transforms  that holds all of the output mask files and transformation matrices from  createMask.py  Depending on the type of mask you are creating, you will find some set of the following files:   FUNC_masks/wholeBrain_FUNC_mask.nii.gz : whole brain mask in participant functional space  FUNC_masks/<outputPrefix>_FUNC_mask.nii.gz : binarized version of the transformed MNI mask in participant functional space  FUNC_masks/<outputPrefix>_FUNC_weighted.nii.gz : non-binarized version of the transformed MNI mask in participant functional space. If the MNI mask you used represents a probabilistic atlas, for instance, those voxel probabilities will be preserved in this file.   exampleFunc.nii.gz : a 3D functional image created by averaging the input 4D FUNC file  hires_brain.nii.gz : skull-stripped version of the input hi-res ANAT file  hires_FUNC.nii.gz : hi-res anatomical image transformed to participant functional space  mni_HIRES.nii.gz : MNI standard transformed to participant hi-res anatomical space  hires2func.mat : transformation matrix mapping from hi-res anatomical space to participant functional space  mni2hires.mat : transformation matrix mapping from MNI space to hi-res anatomical space  mni2func.mat : transformation matrix mapping from MNI space to participant functional space  maskTransforms.log : log file detailing all of the steps that were carried out",
            "title": "Output files"
        },
        {
            "location": "/customAnalysis/",
            "text": "Customized Analyses\n\u00b6\n\n\nTODO",
            "title": "Customized Analyses"
        },
        {
            "location": "/customAnalysis/#customized-analyses",
            "text": "TODO",
            "title": "Customized Analyses"
        },
        {
            "location": "/troubleshooting/",
            "text": "troubleshooting\n\u00b6\n\n\nproblems installing kivy\n\u00b6\n\n\nSome users have reported difficulty installing the \nkivy\n dependency for \nPyneal\n. Kivy is used to create the Pyneal Setup and createMask GUIs, and has its own set of dependencies. If these dependencies don't exist (or they do, but are incompatible versions), using \npip\n to install Kivy can fail. \n\n\nPlease see the \ndetailed Kivy installation instructions\n for help. \n\n\nMake sure to specify the development version of kivy in the 2nd step under \nUsing Homebrew with pip\n: \npip install https://github.com/kivy/kivy/archive/master.zip",
            "title": "Troubleshooting"
        },
        {
            "location": "/troubleshooting/#troubleshooting",
            "text": "",
            "title": "troubleshooting"
        },
        {
            "location": "/troubleshooting/#problems-installing-kivy",
            "text": "Some users have reported difficulty installing the  kivy  dependency for  Pyneal . Kivy is used to create the Pyneal Setup and createMask GUIs, and has its own set of dependencies. If these dependencies don't exist (or they do, but are incompatible versions), using  pip  to install Kivy can fail.   Please see the  detailed Kivy installation instructions  for help.   Make sure to specify the development version of kivy in the 2nd step under  Using Homebrew with pip :  pip install https://github.com/kivy/kivy/archive/master.zip",
            "title": "problems installing kivy"
        },
        {
            "location": "/glossary/",
            "text": "Glossary\n\u00b6\n\n\nComputers\n\u00b6\n\n\nThe documentation refers to computers by their \nfunctional\n role:\n\n\n\n\n\n\nScanner computer\n: The computer where reconstructed images from the scanner appear. In the case of GE scanners, for instance, new slice dicom files appear in a directory on the scanner console. Siemens scanners, on the other hand, may export new images to a directory on a shared network drive. The \nscanner computer\n is simply the computer that has local access to the directory where new images appear\n\n\n\n\n\n\nAnalysis computer\n: The computer that will be running \nPyneal\n. This is the computer on which users will setup their analysis, launch \nPyneal\n, and monitor on-going scans.\n\n\n\n\n\n\nNote that in some cases, the \nsame physical computer\n can play both functional roles. For instance, when working in a Siemens environment, new images from the scanner might be exported to a shared directory that is accessible on the \nanalysis computer\n. In this case, the same machine could be playing the role of both the \nscanner computer\n and the \nanalysis computer\n.\n\n\n\n\nEnd User\n: Generic term for any computer/process that is making a request to \nPyneal\n for results during a scan. For instance, a task presentation computer that is requesting specific feedback values to present to the participant. \n\n\n\n\nAdditional terms used\n\u00b6\n\n\n\n\n\n\nSeries\n: A complete scan representing either a single 3D anatomical image, or a 4D functional image.\n\n\n\n\n\n\nSession\n:  A collection of series collected within the same experimental session. A \nsession\n would typically represent all of the scans collected after the subject is placed in the scanner (e.g. Anatomical, functional series1, functional series2, etc...)",
            "title": "Glossary"
        },
        {
            "location": "/glossary/#glossary",
            "text": "",
            "title": "Glossary"
        },
        {
            "location": "/glossary/#computers",
            "text": "The documentation refers to computers by their  functional  role:    Scanner computer : The computer where reconstructed images from the scanner appear. In the case of GE scanners, for instance, new slice dicom files appear in a directory on the scanner console. Siemens scanners, on the other hand, may export new images to a directory on a shared network drive. The  scanner computer  is simply the computer that has local access to the directory where new images appear    Analysis computer : The computer that will be running  Pyneal . This is the computer on which users will setup their analysis, launch  Pyneal , and monitor on-going scans.    Note that in some cases, the  same physical computer  can play both functional roles. For instance, when working in a Siemens environment, new images from the scanner might be exported to a shared directory that is accessible on the  analysis computer . In this case, the same machine could be playing the role of both the  scanner computer  and the  analysis computer .   End User : Generic term for any computer/process that is making a request to  Pyneal  for results during a scan. For instance, a task presentation computer that is requesting specific feedback values to present to the participant.",
            "title": "Computers"
        },
        {
            "location": "/glossary/#additional-terms-used",
            "text": "Series : A complete scan representing either a single 3D anatomical image, or a 4D functional image.    Session :  A collection of series collected within the same experimental session. A  session  would typically represent all of the scans collected after the subject is placed in the scanner (e.g. Anatomical, functional series1, functional series2, etc...)",
            "title": "Additional terms used"
        },
        {
            "location": "/imageOrientation/",
            "text": "Image Orientation\n\u00b6\n\n\nPyneal uses the RAS+ convention...",
            "title": "Image Orientation"
        },
        {
            "location": "/imageOrientation/#image-orientation",
            "text": "Pyneal uses the RAS+ convention...",
            "title": "Image Orientation"
        }
    ]
}