{
    "docs": [
        {
            "location": "/",
            "text": "Introduction\n\u00b6\n\n\n\n\nPyneal GitHub repository\n\n\nWhat is it?\n\u00b6\n\n\nPyneal\n is an open source software package to support real-time functional magnetic resonance imaging (fMRI). It is entirely Python-based and depends exclusively on free, open source neuroimaging libraries.\n\n\nIt allows users to:\n\n\n\n\naccess functional MRI data in real-time\n\n\ncompute on-going analyses throughout a scan\n\n\nmonitor data quality\n\n\nshare analysis results with remote devices (e.g. send results to an experimental task presenting neurofeedback to participants)\n\n\n\n\nIt currently supports data formats used across 3 major MRI manufacturers: \nGE\n, \nSiemens\n, \nPhilips\n.\n\n\nIn addition to allowing users to compute basic, ROI-based analyses during a scan, \nPyneal\n also provides a simple framework for designing and writing customized analyses that can be computed across the whole brain volume at each timepoint.\n\n\nDesign/Structure\n\u00b6\n\n\nThe software is broken into two separate components: \nPyneal Scanner\n and \nPyneal\n. When first downloaded, \nPyneal Scanner\n is contained in a separate directory within the \nPyneal\n directory\n\n\n\n\n\n\nPyneal Scanner\n: Accesses incoming data, modifies it to match a standardized format, and then sends the data out, one 3D volume at a time, to \nPyneal\n\n\n\n\n\n\nPyneal\n: Listens for incoming 3D volumes from \nPyneal Scanner\n, runs whatever analyses\nyou have specified, and hosts the results on a server, which other downstream components (e.g. an experimental task) can make requests to\n\n\n\n\n\n\nThis design allows the software to easily accommodate the various directory structures and data formats that are found on different scanner models at different institutions around the world. (However, it also means that the steps to install, and setup \nPyneal\n can vary from environment to environment):\n\n\n\n\nInstallation guide\n\n\nSetup guide\n\n\n\n\nTerms/Definitions\n\u00b6\n\n\nThroughout the documentation specific terms are used to describe the different components of the software, the underlying architecture, and the various processes involved. Despite sincere efforts to keep these terms intuitive, they're probably not in all cases. Please check the \nglossary\n for any unfamiliar terms you come across. (You can also find it under \nReference\n in the lefthand menu)",
            "title": "Introduction"
        },
        {
            "location": "/#introduction",
            "text": "Pyneal GitHub repository",
            "title": "Introduction"
        },
        {
            "location": "/#what-is-it",
            "text": "Pyneal  is an open source software package to support real-time functional magnetic resonance imaging (fMRI). It is entirely Python-based and depends exclusively on free, open source neuroimaging libraries.  It allows users to:   access functional MRI data in real-time  compute on-going analyses throughout a scan  monitor data quality  share analysis results with remote devices (e.g. send results to an experimental task presenting neurofeedback to participants)   It currently supports data formats used across 3 major MRI manufacturers:  GE ,  Siemens ,  Philips .  In addition to allowing users to compute basic, ROI-based analyses during a scan,  Pyneal  also provides a simple framework for designing and writing customized analyses that can be computed across the whole brain volume at each timepoint.",
            "title": "What is it?"
        },
        {
            "location": "/#designstructure",
            "text": "The software is broken into two separate components:  Pyneal Scanner  and  Pyneal . When first downloaded,  Pyneal Scanner  is contained in a separate directory within the  Pyneal  directory    Pyneal Scanner : Accesses incoming data, modifies it to match a standardized format, and then sends the data out, one 3D volume at a time, to  Pyneal    Pyneal : Listens for incoming 3D volumes from  Pyneal Scanner , runs whatever analyses\nyou have specified, and hosts the results on a server, which other downstream components (e.g. an experimental task) can make requests to    This design allows the software to easily accommodate the various directory structures and data formats that are found on different scanner models at different institutions around the world. (However, it also means that the steps to install, and setup  Pyneal  can vary from environment to environment):   Installation guide  Setup guide",
            "title": "Design/Structure"
        },
        {
            "location": "/#termsdefinitions",
            "text": "Throughout the documentation specific terms are used to describe the different components of the software, the underlying architecture, and the various processes involved. Despite sincere efforts to keep these terms intuitive, they're probably not in all cases. Please check the  glossary  for any unfamiliar terms you come across. (You can also find it under  Reference  in the lefthand menu)",
            "title": "Terms/Definitions"
        },
        {
            "location": "/installation/",
            "text": "Installation\n\u00b6\n\n\nPyneal is built and tested using \nPython 3.6\n in MacOS 10.13.4\n\n\nDownload Python from \nhttps://www.python.org/downloads/\n or via a distribution like \nAnaconda\n\n\nPyneal requires additional libraries beyond the standard library. Instructions below use \npip\n to install these libraries. Verify that you have \npip\n installed:\n\n\n\n\nwhich pip\n\n\n\n\nIf not, download and install pip from \nhttps://pip.pypa.io/en/stable/installing/\n\n\nDownload Pyneal\n\u00b6\n\n\nDownload the \nPyneal repository\n from GitHub, or clone the repository to your local machine:\n\n\n\n\ngit clone https://github.com/jeffmacinnes/pyneal.git\n\n\n\n\nThe installation instructions are broken down by \nPyneal Scanner\n and \nPyneal\n. If you haven't already, read the section on \ndefinitions\n, as those definitions are used throughout these instructions.\n\n\nPyneal-Scanner\n\u00b6\n\n\nThe \npyneal_scanner\n directory needs to be on the \nscanner computer\n. If the \nscanner computer\n is different from the \nanalysis computer\n in your environment, copy the \npyneal_scanner\n directory to the \nscanner computer\n.  \n\n\ndependencies\n\u00b6\n\n\nThe \nscanner computer\n requires additional \npython\n libraries in order to run \nPyneal Scanner\n.\n\n\nYou can attempt to install all required libraries at once by navigating into the \npyneal_scanner\n directory and typing:\n\n\n\n\npip install -r requirements.txt\n\n\n\n\nIf that fails for any reason, you can install manually one at a time:\n\n\n\n\npip install numpy==1.13.1\n\npip install pydicom==1.0.2\n\npip install nibabel==2.1.0\n\npip install pyzmq==16.0.2\n\npip install pyyaml==3.12\n\n\n\n\nThese versions reflect the primary environment in which \nPyneal\n is tested. It is likely that other versions maintain compatibility, but use at your own risk.\n\n\nPyneal\n\u00b6\n\n\nThe \npyneal\n directory needs to be on the \nanalysis computer\n.\n\n\ndependencies\n\u00b6\n\n\nThe \nanalysis computer\n requires additional \npython\n libraries in order to run \nPyneal\n.\n\n\nYou can attempt to install all required libraries at once by navigating into the \npyneal\n directory and typing:\n\n\n\n\npip install -r requirements.txt\n\n\n\n\nIf that fails for any reason, you can install manually one at a time:\n\n\n\n\npip install numpy==1.13.1\n\npip install scipy==1.1.1\n\npip install nibabel==2.1.0\n\npip install nipy==0.4.1\n\npip install pyzmq==16.0.2\n\npip install pyyaml==3.12\n\npip install flask==0.12.2\n\npip install flask_socketio==2.9.2\n\npip install eventlet==0.21.0  \n\n\n\n\nThese versions reflect the primary environment in which \nPyneal\n is tested. It is likely that other versions maintain compatibility, but use at your own risk.\n\n\nIn addition, each \nPyneal\n session is setup with the help of a GUI, based on the \nKivy\n package. In order to get this to work, you need to install certain Kivy libraries.\n\n\nFirst, make sure you have the latest version of Xcode command line tools installed:\n\n\n\n\nxcode-select --install \n\n\n\n\nNext, installed the libraries for Kivy: \n\n\n[Option 1] Using Homebrew\n\u00b6\n\n\n\n\nbrew install pkg-config sdl2 sdl2_image sdl2_ttf sdl2_mixer gstreamer\n\n\n\n\n[Option 2] Using MacPorts\n\u00b6\n\n\n\n\nport install libsdl2 libsdl2_image libsdl2_ttf libsdl2_mixer\n\n\n\n\nNow, install development version of kivy:\n\n\n\n\npip install Cython==0.26.1\n\npip install https://github.com/kivy/kivy/archive/master.zip\n\n\n\n\nSome users have reported problems installing the development version of kivy . For assistance with this step, and other issues, see \nTroubleshooting\n: Installing Kivy\n\n\nAdditional Tools\n\u00b6\n\n\nPyneal\n itself does not require any additional libaries beyond what is listed above. However, there are various tools included that you may find useful during a real-time scan session. For instance, the tool \ncreateMask\n can be used to transform a standard space ROI mask to the subject's functional space, which can then be used as a mask for analysis during a real-time scan.\n\n\nIn order to use these additional tools, make sure you have installed the following:\n\n\n\n\nFSL 5.0",
            "title": "Installation"
        },
        {
            "location": "/installation/#installation",
            "text": "Pyneal is built and tested using  Python 3.6  in MacOS 10.13.4  Download Python from  https://www.python.org/downloads/  or via a distribution like  Anaconda  Pyneal requires additional libraries beyond the standard library. Instructions below use  pip  to install these libraries. Verify that you have  pip  installed:   which pip   If not, download and install pip from  https://pip.pypa.io/en/stable/installing/",
            "title": "Installation"
        },
        {
            "location": "/installation/#download-pyneal",
            "text": "Download the  Pyneal repository  from GitHub, or clone the repository to your local machine:   git clone https://github.com/jeffmacinnes/pyneal.git   The installation instructions are broken down by  Pyneal Scanner  and  Pyneal . If you haven't already, read the section on  definitions , as those definitions are used throughout these instructions.",
            "title": "Download Pyneal"
        },
        {
            "location": "/installation/#pyneal-scanner",
            "text": "The  pyneal_scanner  directory needs to be on the  scanner computer . If the  scanner computer  is different from the  analysis computer  in your environment, copy the  pyneal_scanner  directory to the  scanner computer .",
            "title": "Pyneal-Scanner"
        },
        {
            "location": "/installation/#dependencies",
            "text": "The  scanner computer  requires additional  python  libraries in order to run  Pyneal Scanner .  You can attempt to install all required libraries at once by navigating into the  pyneal_scanner  directory and typing:   pip install -r requirements.txt   If that fails for any reason, you can install manually one at a time:   pip install numpy==1.13.1 \npip install pydicom==1.0.2 \npip install nibabel==2.1.0 \npip install pyzmq==16.0.2 \npip install pyyaml==3.12   These versions reflect the primary environment in which  Pyneal  is tested. It is likely that other versions maintain compatibility, but use at your own risk.",
            "title": "dependencies"
        },
        {
            "location": "/installation/#pyneal",
            "text": "The  pyneal  directory needs to be on the  analysis computer .",
            "title": "Pyneal"
        },
        {
            "location": "/installation/#dependencies_1",
            "text": "The  analysis computer  requires additional  python  libraries in order to run  Pyneal .  You can attempt to install all required libraries at once by navigating into the  pyneal  directory and typing:   pip install -r requirements.txt   If that fails for any reason, you can install manually one at a time:   pip install numpy==1.13.1 \npip install scipy==1.1.1 \npip install nibabel==2.1.0 \npip install nipy==0.4.1 \npip install pyzmq==16.0.2 \npip install pyyaml==3.12 \npip install flask==0.12.2 \npip install flask_socketio==2.9.2 \npip install eventlet==0.21.0     These versions reflect the primary environment in which  Pyneal  is tested. It is likely that other versions maintain compatibility, but use at your own risk.  In addition, each  Pyneal  session is setup with the help of a GUI, based on the  Kivy  package. In order to get this to work, you need to install certain Kivy libraries.  First, make sure you have the latest version of Xcode command line tools installed:   xcode-select --install    Next, installed the libraries for Kivy:",
            "title": "dependencies"
        },
        {
            "location": "/installation/#option-1-using-homebrew",
            "text": "brew install pkg-config sdl2 sdl2_image sdl2_ttf sdl2_mixer gstreamer",
            "title": "[Option 1] Using Homebrew"
        },
        {
            "location": "/installation/#option-2-using-macports",
            "text": "port install libsdl2 libsdl2_image libsdl2_ttf libsdl2_mixer   Now, install development version of kivy:   pip install Cython==0.26.1 \npip install https://github.com/kivy/kivy/archive/master.zip   Some users have reported problems installing the development version of kivy . For assistance with this step, and other issues, see  Troubleshooting : Installing Kivy",
            "title": "[Option 2] Using MacPorts"
        },
        {
            "location": "/installation/#additional-tools",
            "text": "Pyneal  itself does not require any additional libaries beyond what is listed above. However, there are various tools included that you may find useful during a real-time scan session. For instance, the tool  createMask  can be used to transform a standard space ROI mask to the subject's functional space, which can then be used as a mask for analysis during a real-time scan.  In order to use these additional tools, make sure you have installed the following:   FSL 5.0",
            "title": "Additional Tools"
        },
        {
            "location": "/setup/",
            "text": "Setup\n\u00b6\n\n\nThe set-up instructions are broken down by \nPyneal Scanner\n and \nPyneal\n. If you haven't already, follow the \ninstallation instructions\n to configure your environment, and read the section on \ndefinitions\n, as those definitions are used throughout these instructions.\n\n\nAfter you have finished setting up \nPyneal Scanner\n and \nPyneal\n using the instructions below, you can verify your install using various \nsimulation tools\n. These tools are helpful in troubleshooting any issues you may run into during install/setup.\n\n\n\n\nSetting up your network\n\u00b6\n\n\nPyneal\n communicates with other components in the pipeline, like \nPyneal Scanner\n and any \nEnd User\n, via TCP/IP sockets. These are network communication portals very similar to how a web browser communicates with websites hosted on remote servers. \n\n\nFor this type of commnunication, it's useful to think of one end as the \nserver\n, listening for and responding to requests from remote \nclients\n. Clients connect to the server by specifying the server's IP address and a specific port number. \n\n\nIn our case, \nPyneal\n (running on the \nanalysis computer\n) is always playing the role of the \nserver\n. The IP address you use for \nPyneal\n will depend on how the rest of your environment is set up:\n\n\n\n\n\n\nIf all components are running on the same machine, you can use the generic loopback IP address \n127.0.0.1\n. Put another way, you can use this address if and only if \nPyneal Scanner\n and \nPyneal\n and any \nEnd User\n that requests data are all running from the same physical machine. This might be the case, for instance, if you are testing/debugging certain steps of your analysis (see \nsimulation tools\n)\n\n\n\n\n\n\nIn all other cases, you have to figure out the IP address assigned to the \nanalysis computer\n running \nPyneal\n. \n\n\n\n\n\n\nPyneal\n will use one available port number for communication with \nPyneal Scanner\n, and an additional port number dedicated for communication with remote end users or devices. You can manually specify the port number to use when setting up \nPyneal\n \n\n\nIf you don't know which port numbers to use, check with a network administrator, or simply try choosing ones in the range of 1024-49151. If you happen to choose a port number that is unavailable, \nPyneal\n will return an error message. In that event, try a different number. \n\n\nPyneal Scanner\n\u00b6\n\n\nWhen you download \nPyneal\n everything is contained in the root \npyneal\n directory. \n\n\nFrom the \npyneal\n directory, copy the \npyneal_scanner\n directory to a new location on the \nscanner computer\n.\n\n\nOn the \nscanner computer\n, launch \nPyneal Scanner\n from the command line by navigating to the \npyneal_scanner\n directory and running \npynealScanner.py\n\n\n\n\ncd pyneal_scanner\n\npython pynealScanner.py\n\n\n\n\nPyneal Scanner\n uses a set of configuration parameters that you can modify to fit your environment. These are stored in file named \nscannerConfig.yaml\n in the \npyneal_scanner\n directory.\n\n\nIf you're running \nPyneal Scanner\n for the first time, this file won't exist yet. You can either create this file manually, or wait until \npynealScanner.py\n prompts you to fill in any missing configuration values from the command line. Any values you enter from the command line will be saved in a new \nscannerConfig.yaml\n file.\n\n\nThe \nscannerConfig.yaml\n file allows you to customize \nPyneal Scanner\n to your scanning environment. The file contains just a few parameters stored as \nkey:value\n pairs:\n\n\nscannerBaseDir: /path/to/new/scans\nscannerMake: GE\npynealSocketHost: 127.0.0.1\npynealSocketPort: '9999'\n\n\n\n\nConfiguration Keys\n:\n\n\n\n\n\n\nscannerBaseDir\n: The \nfixed\n portion of the directory path to where new reconstructed images will be appear during a scan. That is, the part that remains constant from scan to scan. Knowing what to set this value to can differ according to different scanner manufacturers:\n\n\n\n\n\n\nGE\n: During a scan, new slices dicom files are written to a directory on the scanner console. The path to that directory can be broken apart like \n[scannerBaseDir]/[sessionDir]/[seriesDir]\n, where\n\n\n\n\n[scannerBaseDir]\n: path that remains constant across all scans\n\n\n[sessionDir]\n: directories that can change from session to session, named like \np###/e###\n where the specific \n#\n values are unknown in advance.\n\n\n[seriesDir]\n: series specific directory named like \ns###\n where the specific \n#\n values are unknown in advance. Each new scan during a given exam session will be assigned a unique \ns###\n dir.\n\n\n\n\nYou only need to specify the path to the \nscannerBaseDir\n in the \nscannerConfig.yaml\n file; \nPyneal Scanner\n will automaticaly find the most recently modified session and series directories and monitor for new series directories to appear. When you run \npynealScanner.py\n you will see a printout in the terminal window about the names, sizes, and modification dates of all series directories in the session directory.\n\n\n\n\n\n\nSiemens\n: Siemens scanners can export reconstructed dicom images to a remote directory. The dicom images are mosaic files, one per volume, in which all slices from the volume are arranged in a 2D grid (or, mosaic, if you will). Siemens will export all files from all series during your session to the same directory, which we'll refer to as the \nscannerBaseDir\n. Each mosaic file follows a naming pattern that indicates the series number and volume number of the data contained within. The full path to a given mosaic file will look like \n[scannerBaseDir]/[session#]_[series#]_[volume#].dcm\n, where\n\n\n\n\n[scannerBaseDir]\n: path to remote directory that will receive all files throughout the session.  \n\n\n[session#]\n: 3 characters representing the current session number, \ne.g. session 1: \n001\n\n\n[series#]\n: 6 characters representing the current series number, \ne.g. series 5: \n000005\n\n\n[volume#]\n: 6 characters represenitng the current volume number, \ne.g. volume 4: \n000004\n \n\n\n\n\n\n\n\n\nPhilips\n: Philips scanners have the option to export reconstructed PAR/REC files to a remote directory. The path to that directory can be broken apart like \n[scannerBaseDir]/[seriesDir]\n, where\n\n\n\n\n[scannerBaseDir]\n: path to remote directory that remains constant across all scans\n\n\n[seriesDir]\n: series specific directory named like \n####\n\n\n\n\n\n\n\n\nYou only need to specify the path to the \nscannerBaseDir\n in the \nscannerConfig.yaml\n file; \nPyneal Scanner\n will monitor for new series directories and/or files to appear.  \n\n\n\n\n\n\nscannerMake\n: Scanner Manufacturer, must be one of \nGE\n, \nSiemens\n, or \nPhilips\n (case sensitive)\n\n\n\n\npynealSocketHost\n: I.P. address of the \nanalysis computer\n running \nPyneal\n. If the analysis and scanner computers are the same, you can use \n127.0.0.1\n, otherwise you must specify an I.P. for the analysis computer that is accessible to remote computers. \n\n\npynealSocketPort\n: The port number over which \nPyneal\n is listening for incoming data.\n\n\n\n\nPyneal\n\u00b6\n\n\nLaunch \nPyneal\n from the command line by navigating in to the \npyneal\n directory and running \npyneal.py\n\n\n\n\ncd pyneal \n\npython pyneal.py\n\n\n\n\nThe \nPyneal\n configuration is set via GUI. When you launch \npyneal.py\n a GUI will appear, allowing you to configure \nPyneal\n to the current experiment\n\n\n\n\n\n\n\n\nCommunication\n:\n\n\n\n\nPyneal Host IP\n: The IP address of the machine running \nPyneal\n (i.e. the \nanalysis machine\n). This is the IP address that \nPyneal Scanner\n will try to connect to, as well as any end user that is making requests for results. Make sure, therefore, that this is an IP address that is accessible to any remote machine that needs it. If you are doing everything locally from the same machine (e.g. testing, running simulations, etc), you can set this to the local host, or loopback address, at \n127.0.0.1\n. However, in all other situations, you'll probably want this to be the unique IP address assigned to the network card in the \nanalysis machine\n. \n\n\nPyneal-Scanner Port\n: The port number over which \nPyneal\n will be listening for incoming data from \nPyneal Scanner\n. Note that this number should match the port number specified in the \npynealSocketPort\n configuration field of the \nPyneal Scanner\n set up.\n\n\nResults Server Port\n: The port number that \nPyneal\n will use to set up the \nResults Server\n. Remote machines that wish to retrieve real-time analysis output during a scan can send requests over this port number. See \nRequesting Results\n\n\n\n\n\n\n\n\nMask\n: Path to mask file (Nifti - .nii/.nii.gz) to be used during real-time analysis. Each incoming 3D volume will be masked to remove non-relevant voxels. The mask \nmust\n match the dimensions and orientation of incoming functional data (see \nCreating Masks\n for Real-time Analysis). The mask will limit which voxels get passed on to the analysis stage. So, for example:\n\n\n\n\nTo calculate the \nAverage\n ROI activation at every timepoint, choose a mask file that represents the target ROI.\n\n\nIf \nWeighted Mask?\n is checked, the voxel values will be used as weights during the analysis.   \n\n\nFor a \nCustom\n analysis that uses the entire brain volume, choose a mask file that represents a whole brain mask (see \nCreating Masks\n for Real-time Analysis).\n\n\n\n\n\n\n\n\nPreprocessing\n: Set the number of timepoints for the current scan\n\n\n\n\n\n\nAnalysis\n: Real-time analysis options. The analysis you select will be computed at every timepoint throughout the scan.\n\n\n\n\nAverage\n: Compute the average activation at each timepoint across all voxels within the mask\n\n\nMedian\n: Compute the median activation at each timepoint across all voxels within the mask\n\n\nCustom\n: Choose a custom analysis script. This script will be executed at each new timepoint (see \nCustom Analysis Scripts\n)\n\n\n\n\n\n\n\n\nOutput\n:\n\n\n\n\nChoose an output directory to store logs and results from the current session. The output from each new series will be stored as a subdirectory in this directory, named sequentially like 'pyneal_001'.  \n\n\nLaunch Dashboard\n: Check this box to launch an interactive dashboard that will allow you to monitor the status of the scan once it begins.\n\n\n\n\n\n\n\n\nBehind the scenes, all of the relevant \nPyneal\n configuration settings are stored as \nkey:value\n pairs in a file stored at \npyneal/src/setupConfig.yaml\n. (In fact, the GUI simply reads this file at launch to get the previous configuration options, and then overwrites this file with the current GUI options whenever you click \nsubmit\n).\n\n\npynealHost: 127.0.0.1\npynealScannerPort: 5555\nresultsServerPort: 5556\nmaskFile: /path/to/mask/file.nii.gz\nmaskIsWeighted: false\nnumTimePts: 60\nanalysisChoice: Average\noutputPath: /path/to/store/output\nlaunchDashboard: true\ndashboardPort: 5557\ndashboardClientPort: 5558\n\n\n\n\nConfiguration Keys\n:\n\n\n\n\npynealHost\n:  The IP address of the machine running \nPyneal\n (i.e. the \nanalysis machine\n). This is the IP address that \nPyneal Scanner\n will try to connect to, as well as any end user that is making requests for results.\n\n\npynealScannerPort\n: Port number over which \nPyneal\n will be listening for incoming data\n\n\nresultsServerPort\n: Port number that \nPyneal\n will use to set up the \nResults Server\n\n\nmaskFile\n: Path to mask file (Nifti - .nii/.nii.gz) to be used during real-time analysis\n\n\nmaskIsWeighted\n: Voxel values in mask represent weights [true/false]\n\n\nnumTimePts\n: Number of timepoints in current scan\n\n\nanalysisChoice\n: Real-time analysis options [Average/Median/Path to custom analysis file]\n\n\noutputPath\n: Path to output directory where logs and results will be saved\n\n\nlaunchDashboard\n: Launch dashboard to monitor real-time scan [true/false]\n\n\ndashboardPort\n: Port number over which to launch the dashboard webserver (\nNOTE:\n this key does not appear in the setup GUI)\n\n\ndashboardClientPort\n: Port number that browsers can use to connect to the dashboard (\nNOTE:\n this key does not appear in the setup GUI)\n\n\n\n\nAt the top of the setup GUI you have the option to load a custom settings file. A custom settings should be a \n.yaml\n file with values for one or more of the configuration keys above. By loading a custom settings file, the GUI will be populated with whichever configure keys are included; any non-included keys will get their values from the \nsetupConfig.yaml\n file as normal.\n\n\nThe option allows users to create settings files on a per-project basis, and easily configure \nPyneal\n to match the project demands.",
            "title": "Setup"
        },
        {
            "location": "/setup/#setup",
            "text": "The set-up instructions are broken down by  Pyneal Scanner  and  Pyneal . If you haven't already, follow the  installation instructions  to configure your environment, and read the section on  definitions , as those definitions are used throughout these instructions.  After you have finished setting up  Pyneal Scanner  and  Pyneal  using the instructions below, you can verify your install using various  simulation tools . These tools are helpful in troubleshooting any issues you may run into during install/setup.",
            "title": "Setup"
        },
        {
            "location": "/setup/#setting-up-your-network",
            "text": "Pyneal  communicates with other components in the pipeline, like  Pyneal Scanner  and any  End User , via TCP/IP sockets. These are network communication portals very similar to how a web browser communicates with websites hosted on remote servers.   For this type of commnunication, it's useful to think of one end as the  server , listening for and responding to requests from remote  clients . Clients connect to the server by specifying the server's IP address and a specific port number.   In our case,  Pyneal  (running on the  analysis computer ) is always playing the role of the  server . The IP address you use for  Pyneal  will depend on how the rest of your environment is set up:    If all components are running on the same machine, you can use the generic loopback IP address  127.0.0.1 . Put another way, you can use this address if and only if  Pyneal Scanner  and  Pyneal  and any  End User  that requests data are all running from the same physical machine. This might be the case, for instance, if you are testing/debugging certain steps of your analysis (see  simulation tools )    In all other cases, you have to figure out the IP address assigned to the  analysis computer  running  Pyneal .     Pyneal  will use one available port number for communication with  Pyneal Scanner , and an additional port number dedicated for communication with remote end users or devices. You can manually specify the port number to use when setting up  Pyneal    If you don't know which port numbers to use, check with a network administrator, or simply try choosing ones in the range of 1024-49151. If you happen to choose a port number that is unavailable,  Pyneal  will return an error message. In that event, try a different number.",
            "title": "Setting up your network"
        },
        {
            "location": "/setup/#pyneal-scanner",
            "text": "When you download  Pyneal  everything is contained in the root  pyneal  directory.   From the  pyneal  directory, copy the  pyneal_scanner  directory to a new location on the  scanner computer .  On the  scanner computer , launch  Pyneal Scanner  from the command line by navigating to the  pyneal_scanner  directory and running  pynealScanner.py   cd pyneal_scanner \npython pynealScanner.py   Pyneal Scanner  uses a set of configuration parameters that you can modify to fit your environment. These are stored in file named  scannerConfig.yaml  in the  pyneal_scanner  directory.  If you're running  Pyneal Scanner  for the first time, this file won't exist yet. You can either create this file manually, or wait until  pynealScanner.py  prompts you to fill in any missing configuration values from the command line. Any values you enter from the command line will be saved in a new  scannerConfig.yaml  file.  The  scannerConfig.yaml  file allows you to customize  Pyneal Scanner  to your scanning environment. The file contains just a few parameters stored as  key:value  pairs:  scannerBaseDir: /path/to/new/scans\nscannerMake: GE\npynealSocketHost: 127.0.0.1\npynealSocketPort: '9999'  Configuration Keys :    scannerBaseDir : The  fixed  portion of the directory path to where new reconstructed images will be appear during a scan. That is, the part that remains constant from scan to scan. Knowing what to set this value to can differ according to different scanner manufacturers:    GE : During a scan, new slices dicom files are written to a directory on the scanner console. The path to that directory can be broken apart like  [scannerBaseDir]/[sessionDir]/[seriesDir] , where   [scannerBaseDir] : path that remains constant across all scans  [sessionDir] : directories that can change from session to session, named like  p###/e###  where the specific  #  values are unknown in advance.  [seriesDir] : series specific directory named like  s###  where the specific  #  values are unknown in advance. Each new scan during a given exam session will be assigned a unique  s###  dir.   You only need to specify the path to the  scannerBaseDir  in the  scannerConfig.yaml  file;  Pyneal Scanner  will automaticaly find the most recently modified session and series directories and monitor for new series directories to appear. When you run  pynealScanner.py  you will see a printout in the terminal window about the names, sizes, and modification dates of all series directories in the session directory.    Siemens : Siemens scanners can export reconstructed dicom images to a remote directory. The dicom images are mosaic files, one per volume, in which all slices from the volume are arranged in a 2D grid (or, mosaic, if you will). Siemens will export all files from all series during your session to the same directory, which we'll refer to as the  scannerBaseDir . Each mosaic file follows a naming pattern that indicates the series number and volume number of the data contained within. The full path to a given mosaic file will look like  [scannerBaseDir]/[session#]_[series#]_[volume#].dcm , where   [scannerBaseDir] : path to remote directory that will receive all files throughout the session.    [session#] : 3 characters representing the current session number,  e.g. session 1:  001  [series#] : 6 characters representing the current series number,  e.g. series 5:  000005  [volume#] : 6 characters represenitng the current volume number,  e.g. volume 4:  000004       Philips : Philips scanners have the option to export reconstructed PAR/REC files to a remote directory. The path to that directory can be broken apart like  [scannerBaseDir]/[seriesDir] , where   [scannerBaseDir] : path to remote directory that remains constant across all scans  [seriesDir] : series specific directory named like  ####     You only need to specify the path to the  scannerBaseDir  in the  scannerConfig.yaml  file;  Pyneal Scanner  will monitor for new series directories and/or files to appear.      scannerMake : Scanner Manufacturer, must be one of  GE ,  Siemens , or  Philips  (case sensitive)   pynealSocketHost : I.P. address of the  analysis computer  running  Pyneal . If the analysis and scanner computers are the same, you can use  127.0.0.1 , otherwise you must specify an I.P. for the analysis computer that is accessible to remote computers.   pynealSocketPort : The port number over which  Pyneal  is listening for incoming data.",
            "title": "Pyneal Scanner"
        },
        {
            "location": "/setup/#pyneal",
            "text": "Launch  Pyneal  from the command line by navigating in to the  pyneal  directory and running  pyneal.py   cd pyneal  \npython pyneal.py   The  Pyneal  configuration is set via GUI. When you launch  pyneal.py  a GUI will appear, allowing you to configure  Pyneal  to the current experiment     Communication :   Pyneal Host IP : The IP address of the machine running  Pyneal  (i.e. the  analysis machine ). This is the IP address that  Pyneal Scanner  will try to connect to, as well as any end user that is making requests for results. Make sure, therefore, that this is an IP address that is accessible to any remote machine that needs it. If you are doing everything locally from the same machine (e.g. testing, running simulations, etc), you can set this to the local host, or loopback address, at  127.0.0.1 . However, in all other situations, you'll probably want this to be the unique IP address assigned to the network card in the  analysis machine .   Pyneal-Scanner Port : The port number over which  Pyneal  will be listening for incoming data from  Pyneal Scanner . Note that this number should match the port number specified in the  pynealSocketPort  configuration field of the  Pyneal Scanner  set up.  Results Server Port : The port number that  Pyneal  will use to set up the  Results Server . Remote machines that wish to retrieve real-time analysis output during a scan can send requests over this port number. See  Requesting Results     Mask : Path to mask file (Nifti - .nii/.nii.gz) to be used during real-time analysis. Each incoming 3D volume will be masked to remove non-relevant voxels. The mask  must  match the dimensions and orientation of incoming functional data (see  Creating Masks  for Real-time Analysis). The mask will limit which voxels get passed on to the analysis stage. So, for example:   To calculate the  Average  ROI activation at every timepoint, choose a mask file that represents the target ROI.  If  Weighted Mask?  is checked, the voxel values will be used as weights during the analysis.     For a  Custom  analysis that uses the entire brain volume, choose a mask file that represents a whole brain mask (see  Creating Masks  for Real-time Analysis).     Preprocessing : Set the number of timepoints for the current scan    Analysis : Real-time analysis options. The analysis you select will be computed at every timepoint throughout the scan.   Average : Compute the average activation at each timepoint across all voxels within the mask  Median : Compute the median activation at each timepoint across all voxels within the mask  Custom : Choose a custom analysis script. This script will be executed at each new timepoint (see  Custom Analysis Scripts )     Output :   Choose an output directory to store logs and results from the current session. The output from each new series will be stored as a subdirectory in this directory, named sequentially like 'pyneal_001'.    Launch Dashboard : Check this box to launch an interactive dashboard that will allow you to monitor the status of the scan once it begins.     Behind the scenes, all of the relevant  Pyneal  configuration settings are stored as  key:value  pairs in a file stored at  pyneal/src/setupConfig.yaml . (In fact, the GUI simply reads this file at launch to get the previous configuration options, and then overwrites this file with the current GUI options whenever you click  submit ).  pynealHost: 127.0.0.1\npynealScannerPort: 5555\nresultsServerPort: 5556\nmaskFile: /path/to/mask/file.nii.gz\nmaskIsWeighted: false\nnumTimePts: 60\nanalysisChoice: Average\noutputPath: /path/to/store/output\nlaunchDashboard: true\ndashboardPort: 5557\ndashboardClientPort: 5558  Configuration Keys :   pynealHost :  The IP address of the machine running  Pyneal  (i.e. the  analysis machine ). This is the IP address that  Pyneal Scanner  will try to connect to, as well as any end user that is making requests for results.  pynealScannerPort : Port number over which  Pyneal  will be listening for incoming data  resultsServerPort : Port number that  Pyneal  will use to set up the  Results Server  maskFile : Path to mask file (Nifti - .nii/.nii.gz) to be used during real-time analysis  maskIsWeighted : Voxel values in mask represent weights [true/false]  numTimePts : Number of timepoints in current scan  analysisChoice : Real-time analysis options [Average/Median/Path to custom analysis file]  outputPath : Path to output directory where logs and results will be saved  launchDashboard : Launch dashboard to monitor real-time scan [true/false]  dashboardPort : Port number over which to launch the dashboard webserver ( NOTE:  this key does not appear in the setup GUI)  dashboardClientPort : Port number that browsers can use to connect to the dashboard ( NOTE:  this key does not appear in the setup GUI)   At the top of the setup GUI you have the option to load a custom settings file. A custom settings should be a  .yaml  file with values for one or more of the configuration keys above. By loading a custom settings file, the GUI will be populated with whichever configure keys are included; any non-included keys will get their values from the  setupConfig.yaml  file as normal.  The option allows users to create settings files on a per-project basis, and easily configure  Pyneal  to match the project demands.",
            "title": "Pyneal"
        },
        {
            "location": "/dataflow/",
            "text": "This schematic gives a very broad overview of the path that data follows throughout a real-time scan with \nPyneal\n\n\n\n\n\n\nOnce the scan begins, raw images are collected by \nPyneal Scanner\n, and then converted and reoriented to a standardized format (see \nimage orientation\n for more info). \n\n\nPyneal Scanner\n exports converted 3D volumes to \nPyneal\n.\n\n\nPyneal\n receives 3D volumes, and concatenates them into a 4D volume over time throughout the scan. With every new 3D volume that arrives, \nPyneal\n will preprocess the volume, and run any specified analyses. \n\n\nThe analysis results for each volume are stored on a separate server, which listens for requests from remote end users or devices throughout the scan (see \nrequesting results\n for more info). \n\n\nAnytime a request is received, the server checks to see if that volume has been processed yet. If so, it returns the results; if not, it sends a message saying that volume has not been processed yet",
            "title": "Data Flow"
        },
        {
            "location": "/pynealScanner/",
            "text": "Pyneal Scanner\n\u00b6\n\n\n\n\nFirst step, make sure you've followed the instructions at \nsetup: Pyneal Scanner\n to configure \nPyneal Scanner\n to your environment. \n\n\nBasic Usage\n\u00b6\n\n\nTo launch \nPyneal Scanner\n from the \nscanner computer\n, open a terminal and navigate to the \npyneal_scanner\n directory. From the \npyneal_scanner\n directory, type:\n\n\n\n\npython pynealScanner.py\n\n\n\n\nIf you have set up \nPyneal Scanner\n correctly, you will see a print out of your settings, info about any existing series directories in the \nscannerBaseDir\n path, and a message that \nPyneal Scanner\n is attempting to connect to \nPyneal\n over the specified \npynealSocket\n:\n\n\n\n\n===============\n\nSCANNER SETTINGS:\n\npynealSocketHost: 127.0.0.1\n\npynealSocketPort: 5555\n\nscannerBaseDir: /path/to/scanner/baseDir\n\nscannerMake: GE  \n\n============   \n\nSession Dir:\n\n/path/to/scanner/baseDir/p1/e666\n\nSeries Dirs:\n\n      s1923    23.6 MB    5 min, 13 s ago\n\n      s1925    26.2 MB    1 min, 10 s ago  \n\nMainThread -  Connecting to pynealSocket...  \n\n\n\n\nOnce you launch \nPyneal\n on the \nanalysis computer\n, you will see a confirmation that \nPyneal Scanner\n has connected to \nPyneal\n, and is now waiting for new data to arrive from the scanner:\n\n\n\n\nMainThread -  pynealSocket connected\n\nMainThread -  Waiting for new seriesDir...\n\n\n\n\nHow it works\n\u00b6\n\n\nBehind the scenes, \nPyneal Scanner\n is running two separate threads. One thread is dedicated to monitoring the specifed directory for new data to appear. Whenever new data arrives, it places it in a queue. The 2nd thread is responsible for pulling data off of that queue, preprocessing it to convert to a standardized format, and then sending the reformatted data to \nPyneal\n over a socket connection (defined by \npynealSocketHost\n and \npynealSocketPort\n in the configuration file). \n\n\nDepending on which type of scanner you are using, the directory structure for where new data will appear, and the format that it will appear in, can differ drastically. \nPyneal Scanner\n comes with utilities designed to handle the directory structures and formats of 3 different scanner manufacturers: \nGE\n, \nPhilips\n, and \nSiemens\n. \n\n\nDirectory structures and data formats by scanner make\n\u00b6\n\n\nPyneal Scanner\n is designed to handle the standard data formats used across the 3 dominant scanner manufacturers, \nGE\n, \nPhilips\n, and \nSiemens\n. This section will provide details on the directory structures and data formats across each in order to help make sure you configure \nPyneal Scanner\n correctly. \n\n\nGE\n\u00b6\n\n\n\n\n\n\nexpected data format\n: dicom files, one file per slice. Each dicom file must contain the following tags:\n\n\n\n\nColumns\n\n\nImagesInAcquisition\n\n\nImageOrientationPatient\n\n\nImagePositionPatient\n \n\n\nInStackPositionNumber\n\n\nInstanceNumber\n\n\nMRAcquisitionType\n\n\nNumberOfTemporalPositions\n\n\nPixelSpacing\n\n\nRows\n\n\nSliceThickness\n\n\n\n\n\n\n\n\nexpected directory structure\n: new dicom files are written to a directory on the scanner console. The path to that directory can be broken apart as:\n\n\n\n\n\n\n[scannerBaseDir]/[sessionDir]/[seriesDir]\n, where\n\n\n\n\n[scannerBaseDir]\n: path that remains constant across all scans\n\n\n[sessionDir]\n: directories that can change from session to session, named like \np###/e###\n where the specific \n#\n values are unknown in advance.\n\n\n[seriesDir]\n: series specific directory named like \ns###\n where the specific \n#\n values are unknown in advance. Each new scan during a given exam session will be assigned a unique \ns###\n dir.\n\n\n\n\nTo figure out the \nsessionDir\n and \nseriesDir\n for the current scan session, see the \nlistSeries\n command below.\n\n\n\n\n\n\n\n\n\n\nPhilips\n\u00b6\n\n\n\n\n\n\nexpected data format\n: new PAR/REC file pairs, where each file pair represents a 3D volume. \n\n\n\n\n\n\nexpected directory structure\n: Philips scanners have the option to export reconstructed PAR/REC files to a remote directory. The path to that directory can be broken apart as\n\n\n\n\n\n\n[scannerBaseDir]/[seriesDir]\n, where  \n\n\n\n\n\n\n[scannerBaseDir]\n: path to remote directory that remains constant across all scans\n\n\n\n\n\n\n[seriesDir]\n: series specific directory named like \n0###\n, where the directory name is a 4-character number (zero padded as necessary) that increases sequentially with each new series. There is a unique series directory for each scan. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSiemens\n\u00b6\n\n\n\n\n\n\nexpected data format\n: dicom mosaic files, where each file represents all slices from a 3D volume, arranged in mosaic format. File names are expected to follow a pattern like \n###_######_######.dcm\n, where the 2nd field represents the series number, and the 3rd field represents the volume number. \n\n\n\n\n\n\nexpected directory structure\n:  Siemens scanners have the option to export reconstructed dicom mosaic files to a remote directory. The path to that directory can be refered to as\n\n\n\n\n[scannerBaseDir]\n\n\n\n\nThe \n[scannerBaseDir]\n will contain all of the volume files for  \nall series\n in a given scan session. \n\n\n\n\n\n\nSending data to Pyneal\n\u00b6\n\n\nDuring a scan, \nPyneal Scanner\n will automatically send data to \nPyneal\n over a socket connection (defined by \npynealSocketHost\n and \npynealSocketPort\n in the configuration file). \n\n\nRegardless of how the data is formatted coming off of the scanner (see \nDirectory structures and data formats by scanner make\n above), \nPyneal Scanner\n will convert everything to a standardized format before sending to \nPyneal\n. \n\n\nSpecifically, \nPyneal Scanner\n will send data as 3D volumes. Each transmission actually takes place in 2 waves:  \n\n\n\n\n\n\nFirst, a JSON header that contains metadata about the current volume, including fields for:\n\n\n\n\nvolIdx\n - volume index (0-based) of the current volume\n\n\ndtype\n - datatype of the volume array\n\n\nshape\n - dimensions of the volume array\n\n\naffine\n - affine transformation that will convert the volume array to RAS+ orientation (see \nImage Orientation\n for more info)\n\n\n\n\n\n\n\n\nSecond, the data array for the current volume. \n\n\n\n\n\n\nPyneal\n will use information in the header message to rebuild the volume array, and carry out all subsequent preprocessing and analysis steps. \n\n\nAdditional commands\n\u00b6\n\n\nThe \npyneal_scanner\n directory also contains a couple of other commands that may be useful during a real-time session\n\n\nlistSeries\n\u00b6\n\n\n\n\nlocation: \npyneal_scanner/listSeries.py\n\n\nusage: \npython listSeries.py\n\n\n\n\nlistSeries.py\n will print to the screen a list of all of the series for the current session. Each series will include information like the relevant paths, directory/file sizes, and creation dates. In the case of GE scanners, this will also report the \np###/e###\n parent directories (i.e. the \nsessionDir\n) of new series directories. \n\n\ngetSeries\n\u00b6\n\n\n\n\nlocation: \npyneal_scanner/getSeries.py\n\n\nusage: \npython getSeries.py\n\n\n\n\ngetSeries.py\n will build a nifti file from a selected series from the current session. When called, it will print a list of all series for the current session, and prompt you to select one. You will also be prompted to specify an 'output prefix' that will be used to name the output file.  \n\n\nYou can select series that correspond to either 3D structural series or 4D functional series. The selected series will be converted to a single nifti file, and saved as:\n\n\npyneal_scanner/data/<output prefix>_<seriesName>.nii.gz\n\n\nThis tool is useful if you need to retrieve data during a session (for example, a localizer run that will be analyzed to create ROIs for the real-time runs).",
            "title": "Pyneal Scanner"
        },
        {
            "location": "/pynealScanner/#pyneal-scanner",
            "text": "First step, make sure you've followed the instructions at  setup: Pyneal Scanner  to configure  Pyneal Scanner  to your environment.",
            "title": "Pyneal Scanner"
        },
        {
            "location": "/pynealScanner/#basic-usage",
            "text": "To launch  Pyneal Scanner  from the  scanner computer , open a terminal and navigate to the  pyneal_scanner  directory. From the  pyneal_scanner  directory, type:   python pynealScanner.py   If you have set up  Pyneal Scanner  correctly, you will see a print out of your settings, info about any existing series directories in the  scannerBaseDir  path, and a message that  Pyneal Scanner  is attempting to connect to  Pyneal  over the specified  pynealSocket :   =============== \nSCANNER SETTINGS: \npynealSocketHost: 127.0.0.1 \npynealSocketPort: 5555 \nscannerBaseDir: /path/to/scanner/baseDir \nscannerMake: GE   \n============    \nSession Dir: \n/path/to/scanner/baseDir/p1/e666 \nSeries Dirs: \n      s1923    23.6 MB    5 min, 13 s ago \n      s1925    26.2 MB    1 min, 10 s ago   \nMainThread -  Connecting to pynealSocket...     Once you launch  Pyneal  on the  analysis computer , you will see a confirmation that  Pyneal Scanner  has connected to  Pyneal , and is now waiting for new data to arrive from the scanner:   MainThread -  pynealSocket connected \nMainThread -  Waiting for new seriesDir...",
            "title": "Basic Usage"
        },
        {
            "location": "/pynealScanner/#how-it-works",
            "text": "Behind the scenes,  Pyneal Scanner  is running two separate threads. One thread is dedicated to monitoring the specifed directory for new data to appear. Whenever new data arrives, it places it in a queue. The 2nd thread is responsible for pulling data off of that queue, preprocessing it to convert to a standardized format, and then sending the reformatted data to  Pyneal  over a socket connection (defined by  pynealSocketHost  and  pynealSocketPort  in the configuration file).   Depending on which type of scanner you are using, the directory structure for where new data will appear, and the format that it will appear in, can differ drastically.  Pyneal Scanner  comes with utilities designed to handle the directory structures and formats of 3 different scanner manufacturers:  GE ,  Philips , and  Siemens .",
            "title": "How it works"
        },
        {
            "location": "/pynealScanner/#directory-structures-and-data-formats-by-scanner-make",
            "text": "Pyneal Scanner  is designed to handle the standard data formats used across the 3 dominant scanner manufacturers,  GE ,  Philips , and  Siemens . This section will provide details on the directory structures and data formats across each in order to help make sure you configure  Pyneal Scanner  correctly.",
            "title": "Directory structures and data formats by scanner make"
        },
        {
            "location": "/pynealScanner/#ge",
            "text": "expected data format : dicom files, one file per slice. Each dicom file must contain the following tags:   Columns  ImagesInAcquisition  ImageOrientationPatient  ImagePositionPatient    InStackPositionNumber  InstanceNumber  MRAcquisitionType  NumberOfTemporalPositions  PixelSpacing  Rows  SliceThickness     expected directory structure : new dicom files are written to a directory on the scanner console. The path to that directory can be broken apart as:    [scannerBaseDir]/[sessionDir]/[seriesDir] , where   [scannerBaseDir] : path that remains constant across all scans  [sessionDir] : directories that can change from session to session, named like  p###/e###  where the specific  #  values are unknown in advance.  [seriesDir] : series specific directory named like  s###  where the specific  #  values are unknown in advance. Each new scan during a given exam session will be assigned a unique  s###  dir.   To figure out the  sessionDir  and  seriesDir  for the current scan session, see the  listSeries  command below.",
            "title": "GE"
        },
        {
            "location": "/pynealScanner/#philips",
            "text": "expected data format : new PAR/REC file pairs, where each file pair represents a 3D volume.     expected directory structure : Philips scanners have the option to export reconstructed PAR/REC files to a remote directory. The path to that directory can be broken apart as    [scannerBaseDir]/[seriesDir] , where      [scannerBaseDir] : path to remote directory that remains constant across all scans    [seriesDir] : series specific directory named like  0### , where the directory name is a 4-character number (zero padded as necessary) that increases sequentially with each new series. There is a unique series directory for each scan.",
            "title": "Philips"
        },
        {
            "location": "/pynealScanner/#siemens",
            "text": "expected data format : dicom mosaic files, where each file represents all slices from a 3D volume, arranged in mosaic format. File names are expected to follow a pattern like  ###_######_######.dcm , where the 2nd field represents the series number, and the 3rd field represents the volume number.     expected directory structure :  Siemens scanners have the option to export reconstructed dicom mosaic files to a remote directory. The path to that directory can be refered to as   [scannerBaseDir]   The  [scannerBaseDir]  will contain all of the volume files for   all series  in a given scan session.",
            "title": "Siemens"
        },
        {
            "location": "/pynealScanner/#sending-data-to-pyneal",
            "text": "During a scan,  Pyneal Scanner  will automatically send data to  Pyneal  over a socket connection (defined by  pynealSocketHost  and  pynealSocketPort  in the configuration file).   Regardless of how the data is formatted coming off of the scanner (see  Directory structures and data formats by scanner make  above),  Pyneal Scanner  will convert everything to a standardized format before sending to  Pyneal .   Specifically,  Pyneal Scanner  will send data as 3D volumes. Each transmission actually takes place in 2 waves:      First, a JSON header that contains metadata about the current volume, including fields for:   volIdx  - volume index (0-based) of the current volume  dtype  - datatype of the volume array  shape  - dimensions of the volume array  affine  - affine transformation that will convert the volume array to RAS+ orientation (see  Image Orientation  for more info)     Second, the data array for the current volume.     Pyneal  will use information in the header message to rebuild the volume array, and carry out all subsequent preprocessing and analysis steps.",
            "title": "Sending data to Pyneal"
        },
        {
            "location": "/pynealScanner/#additional-commands",
            "text": "The  pyneal_scanner  directory also contains a couple of other commands that may be useful during a real-time session",
            "title": "Additional commands"
        },
        {
            "location": "/pynealScanner/#listseries",
            "text": "location:  pyneal_scanner/listSeries.py  usage:  python listSeries.py   listSeries.py  will print to the screen a list of all of the series for the current session. Each series will include information like the relevant paths, directory/file sizes, and creation dates. In the case of GE scanners, this will also report the  p###/e###  parent directories (i.e. the  sessionDir ) of new series directories.",
            "title": "listSeries"
        },
        {
            "location": "/pynealScanner/#getseries",
            "text": "location:  pyneal_scanner/getSeries.py  usage:  python getSeries.py   getSeries.py  will build a nifti file from a selected series from the current session. When called, it will print a list of all series for the current session, and prompt you to select one. You will also be prompted to specify an 'output prefix' that will be used to name the output file.    You can select series that correspond to either 3D structural series or 4D functional series. The selected series will be converted to a single nifti file, and saved as:  pyneal_scanner/data/<output prefix>_<seriesName>.nii.gz  This tool is useful if you need to retrieve data during a session (for example, a localizer run that will be analyzed to create ROIs for the real-time runs).",
            "title": "getSeries"
        },
        {
            "location": "/pyneal/",
            "text": "Pyneal\n\u00b6\n\n\n\n\nFirst step, make sure you've followed the instructions at \nsetup: Pyneal\n to configure \nPyneal\n to your environment. \n\n\nBasic Usage\n\u00b6\n\n\nTo launch \nPyneal\n from the \nanalysis computer\n, open a terminal and navigate to the \npyneal\n directory. From there, type:\n\n\n\n\npython pyneal.py\n\n\n\n\nThis will launch a GUI that will allow you to set up \nPyneal\n for a particular real-time scan. Once you hit submit, a dashboard will appear (if selected in the GUI) that allows you to monitor the progress of your scan. Additional log messages will appear in the terminal throughout the scan. \n\n\nSee below for a more detailed description of how to \nprepare for a real-time scan\n, what's going on \nduring a real-time scan\n, and what type of data is available \nafter a real-time scan\n \n\n\nPreparing for a real-time scan\n\u00b6\n\n\nNetwork settings\n\u00b6\n\n\nBy this point, if you have followed the \nsetup\n instructions for both \nPyneal Scanner\n and \nPyneal\n you will have delegated one machine to be the \nscanner computer\n and one machine to be the \nanalysis computer\n. It is imperative that \nPyneal Scanner\n and \nPyneal\n can communicate with one another during a scan. That is, the \nscanner computer\n must be able to connect to the \nanalysis computer\n over an available network port. \n\n\nDifferent scanning environments will have different configurations (see \nsetup: setting up your network\n for more details). Regardless of your setup, make sure you know the IP address you will use for \nPyneal\n, as well as the port numbers to use for communication with \nPyneal Scanner\n and any remote \nEnd User\n.  \n\n\nCreating Masks\n\u00b6\n\n\nPyneal requires the user to supply a mask that will specify which voxels to include during the real-time analysis. \n\n\nThis mask can take any form you want, with the caveat that it \nmust\n be in the same space (i.e. voxel size, slice dimensions, and orientation) as the incoming functional data throughout the real-time scan. One way to ensure this would to collect a short localizer scan at the beginning of the session that has the desired scan parameters, and use this data to create/register/align your mask for the subsequent real-time runs. \n\n\nExamples:\n\n\n\n\n\n\nMask from functional ROI\n: You could include a mask that represents voxels with significant task-induced activation from the current subject. To do so, include a quick localizer task at the beginning of your session that you can access offline (for instance, by using the \ngetSeries.py\n tool in \nPyneal Scanner\n) and analyze. Threshold and/or binarize the resulting statistical maps as appropriate, and create a funtional ROI mask file. \n\n\n\n\n\n\nMask from anatomical ROI\n: You can create a subject-specific anatomical ROI mask by transforming a preselected MNI space mask to the participant's functional space. \nPyneal\n includes an automated tool to assist in this process. See \nAdditional Tools: Creating Masks\n. Your chosen source MNI mask can be a binary anatomical mask or a weighted probablistic mask. When you load the functional space mask into \nPyneal\n you will have the option of preserving voxel weights. \n\n\n\n\n\n\nChoosing Analyses\n\u00b6\n\n\nPrior to beginning a real-time project, determine what type of analysis is most appropriate to your project, and whether the built-in analysis routines will suffice or whether it'd be more appropriate to use a custom analysis script. \n\n\nPyneal\n has built-in analysis tools that can compute simple descriptive summaries (e.g. mean, median) from a single ROI. However, by using a custom analysis script, you can develop unique and complex analyses, targeting one or more ROIs, that will execute on every incoming volume during the scan. \n\n\nSee \nAdditional Tools: Customized Analyses\n\n\nRunning a real-time scan\n\u00b6\n\n\nTo launch \nPyneal\n from the \nanalysis computer\n, open the command line and navigate to the \npyneal\n directory. From the \npyneal\n directory, type:\n\n\n\n\npython pyneal.py\n\n\n\n\nThe GUI will appear, allowing you to enter the appropriate settings for your environment/session:\n\n\nSet-up GUI\n\u00b6\n\n\n\n\nLaunching the GUI will load the settings from previous run. For running multiple scans in the same session, you may not need to change any settings after the first scan. \n\n\nIf you \ndo\n need to change settings, you can do so manually via each field in the GUI, or you can click \nLoad Settings\n to load a custom \n.yaml\n configuration file. A custom settings file must contain one or more of the required configuration key:value pairs; see \nSetup: Pyneal\n for more details on the \nConfiguration Keys\n. Any configuration keys \nnot\n specified in the custom settings file will be set using default values.   \n\n\nThe GUI presents a number of options that can be customized to your project/enviroment:\n\n\nCommunication\n\u00b6\n\n\n\n\nThe \nCommunication\n panel is where you specify the network settings for communication between \nPyneal Scanner\n, \nPyneal\n, and any remote \nEnd User\n. \n\n\n\n\nPyneal Host IP\n: The IP address of the machine running \nPyneal\n (i.e. the \nanalysis machine\n). This is the IP address that \nPyneal Scanner\n will try to connect to, as well as any remote \nEnd User\n that is making requests for results.  \n\n\nPyneal-Scanner Port\n: The port number over which \nPyneal\n will be listening for incoming data from \nPyneal Scanner\n. \n\n\nResults Server Port\n: The port number that \nPyneal\n will use to set up the \nResults Server\n. Remote machines that wish to retrieve real-time analysis output during a scan can send requests over this port number. \n\n\n\n\nMask\n\u00b6\n\n\n\n\nSpecify the path to mask file (Nifti - .nii/.nii.gz) to be used during real-time analysis. During the analysis stage, each incoming 3D volume will be masked to remove non-relevant voxels. The mask \nmust\n match the dimensions and orientation of incoming functional data (see \nCreating Masks\n for Real-time Analysis).\n\n\n\n\nIf \nWeighted Mask?\n is checked, the voxel values will be used as weights and passed along to the analysis stage.\n\n\nFor a \nCustom\n analysis in which you want to use 2 or more ROIs, you should set your custom analysis script to load the desired ROIs. In that situation, you should choose a mask file here that represents a whole brain mask (see \nCreating Masks\n for Real-time Analysis). \n\n\n\n\nPreprocessing\n\u00b6\n\n\n\n\nSpecify how many timepoints will be in the upcoming series. The other dimensions of the dataset (i.e. slice dimensions, number of slices per vol) will be determined automatically from the incoming data. \n\n\nAnalysis\n\u00b6\n\n\n\n\nChoose the analyses you want to carry out during the real-time run\n\n\n\n\nAverage\n: Built-in analysis routine. Compute the mean activation over all voxels in the \nMask\n specified above. The results will be stored as a dictionary under the key name \naverage\n. If the \nWeighted Mask?\n option is selected on the \nMask\n panel, a \nweighted\n average will be calculated, using voxel values as weights. In this case, the results will be stored in a dictionary under the key name \nweightedAverage\n. \n\n\nMedian\n: Built-in analysis routine. Compute the median activation value over all voxels in the \nMask\n specifed above. The results will be stored in a dictionary under the key name \nmedian\n. If the \nWeighted Mask?\n option is selected on the \nMask\n panel, a \nweighted\n mean will be calculated, using voxel values as weights. (see \nweightedstats\n for algorithm). In this case, the results will be stored in a dictionary under the key name \nweightedMedian\n. \n\n\nCustom\n: Load a custom analysis script. The analysis algorithms specified in the script will be executed on every incoming timepoint during the scan. How the results get stored in the results dictionary throughout a scan is up to your particular script (see \nCustom Analysis Scripts\n)\n\n\n\n\nOutput\n\u00b6\n\n\n\n\nSpecify a path to an output directory for the current \nsession\n. Within this output directory, the results and log files for each new series will be written to unique subdirectories, starting with \npyneal_001\n for the first series and named sequentially thereafter. \n\n\n\n\nLaunch Dashboard?\n: Option for whether to present a dashboard during the real-time scan or not. If selected, the dashboard will launch automatically upon submission. However, if you happen to close it for any reason, you can access it by pointing a web browser to \n127.0.0.1:5558\n (Note: \n5558\n is the \ndashboardClientPort\n number. To confirm the correct port, check the settings that are printed to the terminal once you hit \nSubmit\n from the setup GUI (see \nCommand line output\n below). For more information on using the Dashboard, see \nDashboard\n below). \n\n\n\n\nCommand line output\n\u00b6\n\n\nOnce you hit submit, the command line will print a message showing you where log files for the current series will be stored, as well as all of the configuration settings for this series:\n\n\n\n\nLogs written to: /path/to/outputDir/pyneal_001/pynealLog.log    \n\nMainThread -  Setting: analysisChoice: Average\n\nMainThread -  Setting: dashboardClientPort: 5558\n\nMainThread -  Setting: dashboardPort: 5557\n\nMainThread -  Setting: launchDashboard: True \n\nMainThread -  Setting: maskFile: /path/to/maskFile.nii.gz \n\nMainThread -  Setting: maskIsWeighted: False\n\nMainThread -  Setting: numTimepts: 60\n\nMainThread -  Setting: outputPath: /path/to/outputDir  \n\nMainThread -  Setting: pynealHost: 127.0.0.1\n\nMainThread -  Setting: pynealScannerPort: 5555\n\nMainThread -  Setting: resultsServerPort: 5556\n\nMainThread -  Setting: seriesOutputDir: /path/to/outputDir/pyneal_001  \n\n\n\n\nAt the end of the message, you'll see a status indicator for the various subcomponents of \nPyneal\n:\n\n\n\n\n\n\nMainThread -  ScanReceiver Server alive and listening....\n\nWaiting for connection from pyneal_scanner\n\nMainThread -  Results Server alive and listening....  \n\n\n\n\nIf everything is working properly, it'll say that both the \nScanReceiver Server\n and \nResults Server\n are alive and listening. (for more information about what these components are doing, see \nPyneal Subcomponents\n below). \n\n\nYou should also see a message indicating that \nPyneal\n is waiting to connect to \nPyneal Scanner\n. Once you launch \nPyneal Scanner\n, this message will update to:\n\n\n\n\nReceived message:  hello from pyneal_scanner  \n\n\n\n\nThroughout the scan, the terminal will update with status and log messages reporting on-going processes. In addition to the command line output, you can monitor the status of the scan from the web-based dashboard. \n\n\nDashboard\n\u00b6\n\n\n\n\nThe dashboard will launch automatically, but if you happen to close the window you can relaunch it at any time during the scan by opening a webbrowser and entering the URL \n127.0.0.1:<dashboardClientPort>\n, where \n<dashboardClientPort>\n can be found from series configuration settings that are printed to the command line. For example, using the settings from above, the URL would be: \n127.0.0.1:5558\n\n\nThe top of the dashboard contains a progress bar indicating the % completed of the current scan, as well as additional settings and details. Lower down, the dashboard contains:\n\n\nHead Motion Plot\n\u00b6\n\n\n\n\nPlot displaying head motion throughout the scan. Head motion is expressed in both absolute displacement (\nabs\n, dark blue) from a fixed reference volume (typically the 4th volume in the series), as well as relative displacement (\nrel\n, light blue) relative to the previous volume. \n\n\nHead motion estimates are based on \nhistogram registration\n algorithms, and are applied to fMRI data using a similar approach as found in \nhttps://github.com/cni/rtfmri/blob/master/rtfmri/analyzers.py\n\n\nProcessing Time Plot\n\u00b6\n\n\n\n\nPlot displaying the processing time per volume throughout a scan. You can use this plot to verify that your analyses are successfully keeping pace with the TR of data collection.\n\n\nPyneal Scanner Log\n\u00b6\n\n\n\n\nSimple log message area indicating incoming volumes from \nPyneal Scanner\n as they arrive. \n\n\nResults Server Log\n\u00b6\n\n\n\n\nA log window allowing you to monitor communication between \nPyneal\n (specifically, the results server) and any remote \nEnd User\n. Each request for results sent from an \nEnd User\n will appear on the right half of the log window, along with a blue circle and details as to which volume the results are requested from. \n\n\nThe response from the results server will be shown immediately below each request, left-aligned within the log window. \n\n\n\n\n\n\nIf the requested results are found, the status circle will be maroon, and you will see the JSON message that was returned to the \nEnd User\n. The JSON message will contain a key:value pair indicating the requested results were found (\n\"foundResults\":true\n), as well as other key:value pairs containing the results themselves. \n\n\n\n\n\n\nIf the requested results are not found (for instance, if the requested volume has not arrived and been analyzed yet), the status circle will be grey, and you will see a returned JSON message with a single key:value pair indicating that the results were not found (\n\"foundResults\":false\n)\n\n\n\n\n\n\nFor more info, see \nsending requests\n and \nparsing responses\n\n\nAfter a real-time scan\n\u00b6\n\n\nAfter the scan has completed, all output files will be found in a unique subdirectory for each scan. Subdirectories will appear within the \nOutput Directory\n that was specified in the \nPyneal\n setup GUI. Subdirectories follow the naming convention \npyneal_###\n, staring with \npyneal_001\n for the first scan, and named sequentially thereafter.\n\n\nNote:\n you can find the full path to the unique series output directory in the command line output for this series:\n\n\n\n\nMainThread -  Setting: seriesOutputDir: /path/to/outputDir/pyneal_001  \n\n\n\n\nThe series output directory has the following structure:\n\n\n<seriesOutputDir>\n        \u2514\u2500\u2500 pyneal_001\n            \u251c\u2500\u2500 pynealLog.log\n            \u251c\u2500\u2500 receivedFunc.nii.gz\n            \u2514\u2500\u2500 results.json\n\n\n\n\nEach series will contain the following output files:\n\n\n\n\npynealLog.log\n - detailed log messages from the current series\n\n\nresults.json\n - JSON formatted file containg all of the analysis results from the current series. (see below on \nInterpreting the results file\n for more info) \n\n\nreceivedFunc.nii.gz\n - nifti formatted 4D file containing the series data itself, as received by \nPyneal\n, from the current series  \n\n\n\n\nInterpreting the results file\n\u00b6\n\n\nThe results from the analyses computed in real-time will be stored in the output directory in a file named \nresults.json\n\n\nThis file will have an entry for every volume in the series, and each entry will contain a nested JSON object that has all of the results for that particular volume. For instance, if the real-time analysis is calculating the average signal within the mask, the results file would look like:\n\n\n{\n\"0\":\n    {\"average\": 2149.81},\n\"1\":\n    {\"average\": 2234.32},\n\"2\":\n    {\"average\": 1981.45},\n.\n.\n.\n}\n\n\n\n\nNote that the top-level keys are volume indices that use a 0-based index. \n\n\nIn the above example, we're computing a single result on every volume (i.e. \"average\"). However, if you are using a custom analysis script that is computing multple results on every volume, the same idea holds, and you'll see all of those results for each volume. For instance, if you have a custom analysis script that is computing the mean activation separately in 3 ROIs, the results may look like:\n\n\n{\n\"0\":\n    {\n    \"roi1_average\": 2149.81, \n    \"roi2_average\": 2519.11, \n    \"roi3_average\": 2543.61\n    },\n\"1\":\n    {\n    \"roi1_average\": 1884.51, \n    \"roi2_average\": 2341.43, \n    \"roi3_average\": 2253.67\n    },\n\"2\":\n    {\n    \"roi1_average\": 2001.76, \n    \"roi2_average\": 2214.23, \n    \"roi3_average\": 2877.17\n    },\n.\n.\n.\n}\n\n\n\n\nPyneal subcomponents\n\u00b6\n\n\n\n\nUnder the hood, \nPyneal\n uses multiple threads to manage the various subcomponents and handle communication with remote components efficiently. This section will provide a brief overview of relevant threads in order to better understand how \nPyneal\n works, and help with interpreting the content \npynealLog.log\n output files. \n\n\nMainThread\n\u00b6\n\n\nThe \nMainThread\n of \nPyneal\n can be thought of as the backbone, coordinating the various subcomponents and running the main analysis. The \nMainThread\n presents the setup GUI, initializes \nPyneal\n based on the user-specified settings, and launches the various subthreads. \n\n\nOnce the scan begins, the \nMainThread\n iterates through each expected volume in the series. It checks in with the \nscanReceiver\n to see which volumes have arrived. As soon as each volume is available, it will run the specified analyses, and send the results to the \nresultsServer\n. \n\n\nscanReceiver\n\u00b6\n\n\nThe \nscanReceiver\n runs on \nThread-1\n. Once the \nscanReceiver\n is launched by the \nMainThread\n, it opens a socket connection to \nPyneal Scanner\n and waits for the scan to begin. \n\n\nOnce the scan begins, \nPyneal Scanner\n sends reformatted 3D volumes (and header information) over the socket connection. The \nscanReceiver\n receives this data, converts the byte stream into an array, and adds this data to the 4D matrix for the series (using the header information to determine the appropriate volume index).  \n\n\nresultsServer\n\u00b6\n\n\nThe \nresultsServer\n runs on \nThread-2\n. During a scan, the \nresultsServer\n will listen for incoming requests from a remote \nEnd User\n. Each time a request is received, the \nresultsServer\n will check to see if the requested volume has arrived and been analyzed. If so, it will return a response containing the results for that volume. If not, it will return a response indicating that it could not find results for that volume. \n\n\nFor more info, see \nsending requests\n and \nparsing responses",
            "title": "Pyneal"
        },
        {
            "location": "/pyneal/#pyneal",
            "text": "First step, make sure you've followed the instructions at  setup: Pyneal  to configure  Pyneal  to your environment.",
            "title": "Pyneal"
        },
        {
            "location": "/pyneal/#basic-usage",
            "text": "To launch  Pyneal  from the  analysis computer , open a terminal and navigate to the  pyneal  directory. From there, type:   python pyneal.py   This will launch a GUI that will allow you to set up  Pyneal  for a particular real-time scan. Once you hit submit, a dashboard will appear (if selected in the GUI) that allows you to monitor the progress of your scan. Additional log messages will appear in the terminal throughout the scan.   See below for a more detailed description of how to  prepare for a real-time scan , what's going on  during a real-time scan , and what type of data is available  after a real-time scan",
            "title": "Basic Usage"
        },
        {
            "location": "/pyneal/#preparing-for-a-real-time-scan",
            "text": "",
            "title": "Preparing for a real-time scan"
        },
        {
            "location": "/pyneal/#network-settings",
            "text": "By this point, if you have followed the  setup  instructions for both  Pyneal Scanner  and  Pyneal  you will have delegated one machine to be the  scanner computer  and one machine to be the  analysis computer . It is imperative that  Pyneal Scanner  and  Pyneal  can communicate with one another during a scan. That is, the  scanner computer  must be able to connect to the  analysis computer  over an available network port.   Different scanning environments will have different configurations (see  setup: setting up your network  for more details). Regardless of your setup, make sure you know the IP address you will use for  Pyneal , as well as the port numbers to use for communication with  Pyneal Scanner  and any remote  End User .",
            "title": "Network settings"
        },
        {
            "location": "/pyneal/#creating-masks",
            "text": "Pyneal requires the user to supply a mask that will specify which voxels to include during the real-time analysis.   This mask can take any form you want, with the caveat that it  must  be in the same space (i.e. voxel size, slice dimensions, and orientation) as the incoming functional data throughout the real-time scan. One way to ensure this would to collect a short localizer scan at the beginning of the session that has the desired scan parameters, and use this data to create/register/align your mask for the subsequent real-time runs.   Examples:    Mask from functional ROI : You could include a mask that represents voxels with significant task-induced activation from the current subject. To do so, include a quick localizer task at the beginning of your session that you can access offline (for instance, by using the  getSeries.py  tool in  Pyneal Scanner ) and analyze. Threshold and/or binarize the resulting statistical maps as appropriate, and create a funtional ROI mask file.     Mask from anatomical ROI : You can create a subject-specific anatomical ROI mask by transforming a preselected MNI space mask to the participant's functional space.  Pyneal  includes an automated tool to assist in this process. See  Additional Tools: Creating Masks . Your chosen source MNI mask can be a binary anatomical mask or a weighted probablistic mask. When you load the functional space mask into  Pyneal  you will have the option of preserving voxel weights.",
            "title": "Creating Masks"
        },
        {
            "location": "/pyneal/#choosing-analyses",
            "text": "Prior to beginning a real-time project, determine what type of analysis is most appropriate to your project, and whether the built-in analysis routines will suffice or whether it'd be more appropriate to use a custom analysis script.   Pyneal  has built-in analysis tools that can compute simple descriptive summaries (e.g. mean, median) from a single ROI. However, by using a custom analysis script, you can develop unique and complex analyses, targeting one or more ROIs, that will execute on every incoming volume during the scan.   See  Additional Tools: Customized Analyses",
            "title": "Choosing Analyses"
        },
        {
            "location": "/pyneal/#running-a-real-time-scan",
            "text": "To launch  Pyneal  from the  analysis computer , open the command line and navigate to the  pyneal  directory. From the  pyneal  directory, type:   python pyneal.py   The GUI will appear, allowing you to enter the appropriate settings for your environment/session:",
            "title": "Running a real-time scan"
        },
        {
            "location": "/pyneal/#set-up-gui",
            "text": "Launching the GUI will load the settings from previous run. For running multiple scans in the same session, you may not need to change any settings after the first scan.   If you  do  need to change settings, you can do so manually via each field in the GUI, or you can click  Load Settings  to load a custom  .yaml  configuration file. A custom settings file must contain one or more of the required configuration key:value pairs; see  Setup: Pyneal  for more details on the  Configuration Keys . Any configuration keys  not  specified in the custom settings file will be set using default values.     The GUI presents a number of options that can be customized to your project/enviroment:",
            "title": "Set-up GUI"
        },
        {
            "location": "/pyneal/#communication",
            "text": "The  Communication  panel is where you specify the network settings for communication between  Pyneal Scanner ,  Pyneal , and any remote  End User .    Pyneal Host IP : The IP address of the machine running  Pyneal  (i.e. the  analysis machine ). This is the IP address that  Pyneal Scanner  will try to connect to, as well as any remote  End User  that is making requests for results.    Pyneal-Scanner Port : The port number over which  Pyneal  will be listening for incoming data from  Pyneal Scanner .   Results Server Port : The port number that  Pyneal  will use to set up the  Results Server . Remote machines that wish to retrieve real-time analysis output during a scan can send requests over this port number.",
            "title": "Communication"
        },
        {
            "location": "/pyneal/#mask",
            "text": "Specify the path to mask file (Nifti - .nii/.nii.gz) to be used during real-time analysis. During the analysis stage, each incoming 3D volume will be masked to remove non-relevant voxels. The mask  must  match the dimensions and orientation of incoming functional data (see  Creating Masks  for Real-time Analysis).   If  Weighted Mask?  is checked, the voxel values will be used as weights and passed along to the analysis stage.  For a  Custom  analysis in which you want to use 2 or more ROIs, you should set your custom analysis script to load the desired ROIs. In that situation, you should choose a mask file here that represents a whole brain mask (see  Creating Masks  for Real-time Analysis).",
            "title": "Mask"
        },
        {
            "location": "/pyneal/#preprocessing",
            "text": "Specify how many timepoints will be in the upcoming series. The other dimensions of the dataset (i.e. slice dimensions, number of slices per vol) will be determined automatically from the incoming data.",
            "title": "Preprocessing"
        },
        {
            "location": "/pyneal/#analysis",
            "text": "Choose the analyses you want to carry out during the real-time run   Average : Built-in analysis routine. Compute the mean activation over all voxels in the  Mask  specified above. The results will be stored as a dictionary under the key name  average . If the  Weighted Mask?  option is selected on the  Mask  panel, a  weighted  average will be calculated, using voxel values as weights. In this case, the results will be stored in a dictionary under the key name  weightedAverage .   Median : Built-in analysis routine. Compute the median activation value over all voxels in the  Mask  specifed above. The results will be stored in a dictionary under the key name  median . If the  Weighted Mask?  option is selected on the  Mask  panel, a  weighted  mean will be calculated, using voxel values as weights. (see  weightedstats  for algorithm). In this case, the results will be stored in a dictionary under the key name  weightedMedian .   Custom : Load a custom analysis script. The analysis algorithms specified in the script will be executed on every incoming timepoint during the scan. How the results get stored in the results dictionary throughout a scan is up to your particular script (see  Custom Analysis Scripts )",
            "title": "Analysis"
        },
        {
            "location": "/pyneal/#output",
            "text": "Specify a path to an output directory for the current  session . Within this output directory, the results and log files for each new series will be written to unique subdirectories, starting with  pyneal_001  for the first series and named sequentially thereafter.    Launch Dashboard? : Option for whether to present a dashboard during the real-time scan or not. If selected, the dashboard will launch automatically upon submission. However, if you happen to close it for any reason, you can access it by pointing a web browser to  127.0.0.1:5558  (Note:  5558  is the  dashboardClientPort  number. To confirm the correct port, check the settings that are printed to the terminal once you hit  Submit  from the setup GUI (see  Command line output  below). For more information on using the Dashboard, see  Dashboard  below).",
            "title": "Output"
        },
        {
            "location": "/pyneal/#command-line-output",
            "text": "Once you hit submit, the command line will print a message showing you where log files for the current series will be stored, as well as all of the configuration settings for this series:   Logs written to: /path/to/outputDir/pyneal_001/pynealLog.log     \nMainThread -  Setting: analysisChoice: Average \nMainThread -  Setting: dashboardClientPort: 5558 \nMainThread -  Setting: dashboardPort: 5557 \nMainThread -  Setting: launchDashboard: True  \nMainThread -  Setting: maskFile: /path/to/maskFile.nii.gz  \nMainThread -  Setting: maskIsWeighted: False \nMainThread -  Setting: numTimepts: 60 \nMainThread -  Setting: outputPath: /path/to/outputDir   \nMainThread -  Setting: pynealHost: 127.0.0.1 \nMainThread -  Setting: pynealScannerPort: 5555 \nMainThread -  Setting: resultsServerPort: 5556 \nMainThread -  Setting: seriesOutputDir: /path/to/outputDir/pyneal_001     At the end of the message, you'll see a status indicator for the various subcomponents of  Pyneal :    MainThread -  ScanReceiver Server alive and listening.... \nWaiting for connection from pyneal_scanner \nMainThread -  Results Server alive and listening....     If everything is working properly, it'll say that both the  ScanReceiver Server  and  Results Server  are alive and listening. (for more information about what these components are doing, see  Pyneal Subcomponents  below).   You should also see a message indicating that  Pyneal  is waiting to connect to  Pyneal Scanner . Once you launch  Pyneal Scanner , this message will update to:   Received message:  hello from pyneal_scanner     Throughout the scan, the terminal will update with status and log messages reporting on-going processes. In addition to the command line output, you can monitor the status of the scan from the web-based dashboard.",
            "title": "Command line output"
        },
        {
            "location": "/pyneal/#dashboard",
            "text": "The dashboard will launch automatically, but if you happen to close the window you can relaunch it at any time during the scan by opening a webbrowser and entering the URL  127.0.0.1:<dashboardClientPort> , where  <dashboardClientPort>  can be found from series configuration settings that are printed to the command line. For example, using the settings from above, the URL would be:  127.0.0.1:5558  The top of the dashboard contains a progress bar indicating the % completed of the current scan, as well as additional settings and details. Lower down, the dashboard contains:",
            "title": "Dashboard"
        },
        {
            "location": "/pyneal/#head-motion-plot",
            "text": "Plot displaying head motion throughout the scan. Head motion is expressed in both absolute displacement ( abs , dark blue) from a fixed reference volume (typically the 4th volume in the series), as well as relative displacement ( rel , light blue) relative to the previous volume.   Head motion estimates are based on  histogram registration  algorithms, and are applied to fMRI data using a similar approach as found in  https://github.com/cni/rtfmri/blob/master/rtfmri/analyzers.py",
            "title": "Head Motion Plot"
        },
        {
            "location": "/pyneal/#processing-time-plot",
            "text": "Plot displaying the processing time per volume throughout a scan. You can use this plot to verify that your analyses are successfully keeping pace with the TR of data collection.",
            "title": "Processing Time Plot"
        },
        {
            "location": "/pyneal/#pyneal-scanner-log",
            "text": "Simple log message area indicating incoming volumes from  Pyneal Scanner  as they arrive.",
            "title": "Pyneal Scanner Log"
        },
        {
            "location": "/pyneal/#results-server-log",
            "text": "A log window allowing you to monitor communication between  Pyneal  (specifically, the results server) and any remote  End User . Each request for results sent from an  End User  will appear on the right half of the log window, along with a blue circle and details as to which volume the results are requested from.   The response from the results server will be shown immediately below each request, left-aligned within the log window.     If the requested results are found, the status circle will be maroon, and you will see the JSON message that was returned to the  End User . The JSON message will contain a key:value pair indicating the requested results were found ( \"foundResults\":true ), as well as other key:value pairs containing the results themselves.     If the requested results are not found (for instance, if the requested volume has not arrived and been analyzed yet), the status circle will be grey, and you will see a returned JSON message with a single key:value pair indicating that the results were not found ( \"foundResults\":false )    For more info, see  sending requests  and  parsing responses",
            "title": "Results Server Log"
        },
        {
            "location": "/pyneal/#after-a-real-time-scan",
            "text": "After the scan has completed, all output files will be found in a unique subdirectory for each scan. Subdirectories will appear within the  Output Directory  that was specified in the  Pyneal  setup GUI. Subdirectories follow the naming convention  pyneal_### , staring with  pyneal_001  for the first scan, and named sequentially thereafter.  Note:  you can find the full path to the unique series output directory in the command line output for this series:   MainThread -  Setting: seriesOutputDir: /path/to/outputDir/pyneal_001     The series output directory has the following structure:  <seriesOutputDir>\n        \u2514\u2500\u2500 pyneal_001\n            \u251c\u2500\u2500 pynealLog.log\n            \u251c\u2500\u2500 receivedFunc.nii.gz\n            \u2514\u2500\u2500 results.json  Each series will contain the following output files:   pynealLog.log  - detailed log messages from the current series  results.json  - JSON formatted file containg all of the analysis results from the current series. (see below on  Interpreting the results file  for more info)   receivedFunc.nii.gz  - nifti formatted 4D file containing the series data itself, as received by  Pyneal , from the current series",
            "title": "After a real-time scan"
        },
        {
            "location": "/pyneal/#interpreting-the-results-file",
            "text": "The results from the analyses computed in real-time will be stored in the output directory in a file named  results.json  This file will have an entry for every volume in the series, and each entry will contain a nested JSON object that has all of the results for that particular volume. For instance, if the real-time analysis is calculating the average signal within the mask, the results file would look like:  {\n\"0\":\n    {\"average\": 2149.81},\n\"1\":\n    {\"average\": 2234.32},\n\"2\":\n    {\"average\": 1981.45},\n.\n.\n.\n}  Note that the top-level keys are volume indices that use a 0-based index.   In the above example, we're computing a single result on every volume (i.e. \"average\"). However, if you are using a custom analysis script that is computing multple results on every volume, the same idea holds, and you'll see all of those results for each volume. For instance, if you have a custom analysis script that is computing the mean activation separately in 3 ROIs, the results may look like:  {\n\"0\":\n    {\n    \"roi1_average\": 2149.81, \n    \"roi2_average\": 2519.11, \n    \"roi3_average\": 2543.61\n    },\n\"1\":\n    {\n    \"roi1_average\": 1884.51, \n    \"roi2_average\": 2341.43, \n    \"roi3_average\": 2253.67\n    },\n\"2\":\n    {\n    \"roi1_average\": 2001.76, \n    \"roi2_average\": 2214.23, \n    \"roi3_average\": 2877.17\n    },\n.\n.\n.\n}",
            "title": "Interpreting the results file"
        },
        {
            "location": "/pyneal/#pyneal-subcomponents",
            "text": "Under the hood,  Pyneal  uses multiple threads to manage the various subcomponents and handle communication with remote components efficiently. This section will provide a brief overview of relevant threads in order to better understand how  Pyneal  works, and help with interpreting the content  pynealLog.log  output files.",
            "title": "Pyneal subcomponents"
        },
        {
            "location": "/pyneal/#mainthread",
            "text": "The  MainThread  of  Pyneal  can be thought of as the backbone, coordinating the various subcomponents and running the main analysis. The  MainThread  presents the setup GUI, initializes  Pyneal  based on the user-specified settings, and launches the various subthreads.   Once the scan begins, the  MainThread  iterates through each expected volume in the series. It checks in with the  scanReceiver  to see which volumes have arrived. As soon as each volume is available, it will run the specified analyses, and send the results to the  resultsServer .",
            "title": "MainThread"
        },
        {
            "location": "/pyneal/#scanreceiver",
            "text": "The  scanReceiver  runs on  Thread-1 . Once the  scanReceiver  is launched by the  MainThread , it opens a socket connection to  Pyneal Scanner  and waits for the scan to begin.   Once the scan begins,  Pyneal Scanner  sends reformatted 3D volumes (and header information) over the socket connection. The  scanReceiver  receives this data, converts the byte stream into an array, and adds this data to the 4D matrix for the series (using the header information to determine the appropriate volume index).",
            "title": "scanReceiver"
        },
        {
            "location": "/pyneal/#resultsserver",
            "text": "The  resultsServer  runs on  Thread-2 . During a scan, the  resultsServer  will listen for incoming requests from a remote  End User . Each time a request is received, the  resultsServer  will check to see if the requested volume has arrived and been analyzed. If so, it will return a response containing the results for that volume. If not, it will return a response indicating that it could not find results for that volume.   For more info, see  sending requests  and  parsing responses",
            "title": "resultsServer"
        },
        {
            "location": "/endUser/",
            "text": "We refer to \nany\n component that requests results from \nPyneal\n during a scan as an \nEnd User\n. For instance, a potential \nEnd User\n could be task presentation software that periodically makes requests for analysis results in order to update a neurofeedback display for the participant. \n\n\nSending requests\n\u00b6\n\n\n\n\nSending a request to \nPyneal\n for the results from a specific volume simply requires you to establish a connection to \nPyneal\n and send the index value of the volume you'd like to request (0-based index). The volume index should be formatted as a 4-character string, with zero-padded as needed. For instance, to request the results from the 9th volume (i.e. index 8), the request would be formatted as \n0008\n. \n\n\nHere is an example, written in \npython\n for how you might \nsend\n a request for the 9th volume:\n\n\nimport socket\n\n# socket configs\nhost = '127.0.0.1'  # Pyneal address\nport = 5556     # results server port number\n\n# connect to the results server of Pyneal\nclientSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nclientSocket.connect((host, port))\n\n# format request for the 9th volume (index 8).\nrequest = '0008'\n\n# send the request\nclientSocket.send(request.encode())\n\n\n\n\nThis approach can be incorporated into any \nEnd User\n application (e.g. an experimental task) to request specific results throughout a scan. \n\n\nParsing Responses\n\u00b6\n\n\n\n\nContinuing from the previous section, once the results server on \nPyneal\n \nreceives\n a request for volume index \n0008\n, it will check to see if that volume has arrived and been analyzed yet.\n\n\n\n\n\n\nIf the volume \nhas not\n arrived, the response will be a JSON message that contains a single key:value pair: \n\"foundResults\":False\n\n\n\n\n\n\nIf the volume \nhas\n arrived, the response will be a JSON message that contains the key:value pair \n\"foundResults\":True\n as well all of the results key:value pairs for that volume. For instance, if the real-time analysis is set to compute the average activation with the selected mask, the response message for volume \n0008\n may look like \n{'foundResults': True, 'average':2432}\n. If you are using a custom analysis script that computes multiple results on each volume, all of those results will appear in the response message. For instance, if you have a custom analysis script that is computing the mean activation separately in 3 ROIs, the response message may look like \n{'foundResults': True, \"roi1_average\": 2149.81, \"roi2_average\": 2519.11, \"roi3_average\": 2543.61}\n\n\n\n\n\n\nSince the length of the response message can vary depending on A) whether the results were found or not, and B) the number of results that are being returned, the response itself will get sent to the remote \nEnd User\n in 2 waves:\n\n\n1) First, a header that simply reports the number of characters in the upcoming response message. \n\n\n2) The response message itself. \n\n\nThis way, the \nEnd User\n can know precisely how many bytes to read from the socket connection. \n\n\nFor reference, here is the code that the results server uses to send responses:\n\n\ndef sendResults(self, connection, results):\n    \"\"\"\n    Format the results dict to a json string, and send results to the client.\n    Message will be sent in 2 waves: first a header indicating the msg length,\n    and then the message itself\n    \"\"\"\n    # format as json string and then convert to bytes\n    formattedMsg = json.dumps(results).encode()\n\n    # build then send header with info about msg length\n    hdr = '{:d}\\n'.format(len(formattedMsg))\n    connection.send(hdr.encode())\n\n    # send results as formatted message\n    connection.sendall(formattedMsg)\n    self.logger.debug('Sent result: {}'.format(formattedMsg))\n\n\n\n\nExample Responses\n\u00b6\n\n\nHere are some example of what the JSON responses might look like using different analysis options. \n\n\n\n\n\n\nResults were not found\n: The \nEnd User\n requested a volume that has not arrived or been analyzed yet:\n\n\n{'foundResults': False}\n\n\n\n\n\n\nPyneal Built-in Analysis Options\n\u00b6\n\n\n\n\n\n\nAverage\n (from GUI): compute the average signal within the specified mask:\n\n\n{'foundResults': True, 'average':2432}\n\n\n\n\n\n\nWeighted Average\n (from GUI): compute the weighted average within the specified mask, using mask voxels values as weights (\"Weighted Mask?\" is checked in GUI):\n\n\n{'foundResults': True, 'weightedAverage':2432}\n\n\n\n\n\n\nMedian\n (from GUI): compute the median signal within the specified mask:\n\n\n{'foundResults': True, 'median':2432}\n\n\n\n\n\n\nWeighted Median\n (from GUI): compute the weighted median within the specified mask, using mask voxel values as weights (\"Weighted Mask?\" is checked in GUI):\n\n\n{'foundResults': True, 'weightedMedian':2432}\n\n\n\n\n\n\nUsing Custom Analyses\n\u00b6\n\n\nThe JSON responses from custom analyses will vary based on your custom analysis script. At a minimum, all responses will contain the \n'foundResults'\n entry. \n\n\nFor instance, if you have a custom analysis script that is computing the mean activation separately in 3 ROIs, the response message may look like:\n\n\n\n\n{'foundResults': True, \"roi1_average\": 2149.81, \"roi2_average\": 2519.11, \"roi3_average\": 2543.61}",
            "title": "End User"
        },
        {
            "location": "/endUser/#sending-requests",
            "text": "Sending a request to  Pyneal  for the results from a specific volume simply requires you to establish a connection to  Pyneal  and send the index value of the volume you'd like to request (0-based index). The volume index should be formatted as a 4-character string, with zero-padded as needed. For instance, to request the results from the 9th volume (i.e. index 8), the request would be formatted as  0008 .   Here is an example, written in  python  for how you might  send  a request for the 9th volume:  import socket\n\n# socket configs\nhost = '127.0.0.1'  # Pyneal address\nport = 5556     # results server port number\n\n# connect to the results server of Pyneal\nclientSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nclientSocket.connect((host, port))\n\n# format request for the 9th volume (index 8).\nrequest = '0008'\n\n# send the request\nclientSocket.send(request.encode())  This approach can be incorporated into any  End User  application (e.g. an experimental task) to request specific results throughout a scan.",
            "title": "Sending requests"
        },
        {
            "location": "/endUser/#parsing-responses",
            "text": "Continuing from the previous section, once the results server on  Pyneal   receives  a request for volume index  0008 , it will check to see if that volume has arrived and been analyzed yet.    If the volume  has not  arrived, the response will be a JSON message that contains a single key:value pair:  \"foundResults\":False    If the volume  has  arrived, the response will be a JSON message that contains the key:value pair  \"foundResults\":True  as well all of the results key:value pairs for that volume. For instance, if the real-time analysis is set to compute the average activation with the selected mask, the response message for volume  0008  may look like  {'foundResults': True, 'average':2432} . If you are using a custom analysis script that computes multiple results on each volume, all of those results will appear in the response message. For instance, if you have a custom analysis script that is computing the mean activation separately in 3 ROIs, the response message may look like  {'foundResults': True, \"roi1_average\": 2149.81, \"roi2_average\": 2519.11, \"roi3_average\": 2543.61}    Since the length of the response message can vary depending on A) whether the results were found or not, and B) the number of results that are being returned, the response itself will get sent to the remote  End User  in 2 waves:  1) First, a header that simply reports the number of characters in the upcoming response message.   2) The response message itself.   This way, the  End User  can know precisely how many bytes to read from the socket connection.   For reference, here is the code that the results server uses to send responses:  def sendResults(self, connection, results):\n    \"\"\"\n    Format the results dict to a json string, and send results to the client.\n    Message will be sent in 2 waves: first a header indicating the msg length,\n    and then the message itself\n    \"\"\"\n    # format as json string and then convert to bytes\n    formattedMsg = json.dumps(results).encode()\n\n    # build then send header with info about msg length\n    hdr = '{:d}\\n'.format(len(formattedMsg))\n    connection.send(hdr.encode())\n\n    # send results as formatted message\n    connection.sendall(formattedMsg)\n    self.logger.debug('Sent result: {}'.format(formattedMsg))",
            "title": "Parsing Responses"
        },
        {
            "location": "/endUser/#example-responses",
            "text": "Here are some example of what the JSON responses might look like using different analysis options.     Results were not found : The  End User  requested a volume that has not arrived or been analyzed yet:  {'foundResults': False}",
            "title": "Example Responses"
        },
        {
            "location": "/endUser/#pyneal-built-in-analysis-options",
            "text": "Average  (from GUI): compute the average signal within the specified mask:  {'foundResults': True, 'average':2432}    Weighted Average  (from GUI): compute the weighted average within the specified mask, using mask voxels values as weights (\"Weighted Mask?\" is checked in GUI):  {'foundResults': True, 'weightedAverage':2432}    Median  (from GUI): compute the median signal within the specified mask:  {'foundResults': True, 'median':2432}    Weighted Median  (from GUI): compute the weighted median within the specified mask, using mask voxel values as weights (\"Weighted Mask?\" is checked in GUI):  {'foundResults': True, 'weightedMedian':2432}",
            "title": "Pyneal Built-in Analysis Options"
        },
        {
            "location": "/endUser/#using-custom-analyses",
            "text": "The JSON responses from custom analyses will vary based on your custom analysis script. At a minimum, all responses will contain the  'foundResults'  entry.   For instance, if you have a custom analysis script that is computing the mean activation separately in 3 ROIs, the response message may look like:   {'foundResults': True, \"roi1_average\": 2149.81, \"roi2_average\": 2519.11, \"roi3_average\": 2543.61}",
            "title": "Using Custom Analyses"
        },
        {
            "location": "/simulations/",
            "text": "Simulations\n\u00b6\n\n\nOverview\n\u00b6\n\n\nIn order to help with the initial setup, as well as test any analysis scripts and network communications later on, \nPyneal\n includes a suite of simulation tools that mimic various inputs and outputs along the data flow path.\n\n\nThese tools allow you to simulate \nPyneal\n (or \nPyneal Scanner\n) in a modular fashion without having to run the entire pipeline. If you are troubleshooting issues, these tools are immensely helpful.  \n\n\nHere is a diagram highlighting the various simulation tools, and where they enter the data flow pipeline. \n\n\n\n\nDuring an actual real-time scan, data will flow through this diagram from left to right along the blue arrows. \n\n\nSimulation tools are indicated using dashed or dotted vertical lines.\n\n\n\n\n\n\nA dashed line indicates a simulation tool that \ngenerates input\n. In other words, these tools mimic real data as it exists at a particular stage of the pipeline\n\n\n\n\n\n\nA dotted line indicates a simulation tool that \nreceives output\n. In other words, these tools allow you to simulate the \nnext\n stage of the pipeline\n\n\n\n\n\n\nBoth \nPyneal Scanner\n and \nPyneal\n have their own set of simulation tools. \n\n\n\n\n\n\nPyneal Scanner\n simulation tools can be found in \npyneal/pyneal_scanner/simulation\n and are shown in light blue \nbelow\n the real data pipeline in the schematic. See below for more details\n\n\n\n\n\n\nPyneal\n simulation tools can be found in \npyneal/utils/simulation\n and are shown in green \nabove\n the real data pipeline in the schematic. See below for more details\n\n\n\n\n\n\nPyneal Scanner Simulation Tools\n\u00b6\n\n\nThe \nPyneal Scanner\n simulation tools can be found in \npyneal/pyneal_scanner/simulation\n\n\n\n\nScanner Simulators\n: Set of simulation scripts to mimic the behavior of real scanners with real data. \n\n\npynealReceiver_sim.py\n: simulates the behavior of \nPyneal\n (i.e. accepts incoming 3D volumes from \nPyneal Scanner\n)\n\n\n\n\nScanner Simulators\n\u00b6\n\n\nUse Case:\n Testing \nPyneal Scanner\n (and \nanything else\n downstream) with real data.\n\n\n\n\nThis will simulate the appearance of raw data coming off of the scanner. This works by pointing the simulator to a folder containing real scanner data. The simulator will copy the real data to a new directory in a way that mimics the behavior of a real scan, allowing you to test \nPyneal Scanner\n and anything else downstream. \n\n\nThe format of the raw data will vary according to different scanner environments/manufacturers. Accordingly, there are multiple scripts that will simulate different scanner formats:\n\n\nGE\n\u00b6\n\n\nlocation\n: \npyneal/pyneal_scanner/simulation/scannerSimulators/GE_sim.py\n\n\nusage\n: \npython GE_sim.py inputDir [--outputDir] [--TR]\n\n\ninput args\n:  \n\n\n\n\ninputDir: path to directory containing raw slice dicom images. \n\n\n-o outputDir: path to directory where slices will be copied to [default: create new directory named \ns9999\n in the parent directory of the inputDir]\n\n\n-t/--TR TR: set the TR in ms [default: 1000]\n\n\n\n\nIn order to run this script, you must have a local directory that contains raw slice dicom files from an actual scan. If you want to fully mimic the data directory structure of GE scanners, you can create a local directory path that follows the pattern \n[baseDir]/p##/e##/s##\n where the slice images are stored in a directory named like \ns###\n, which is nested two levels deep (\np###/e###\n) from the \n[basedir]\n. \n\n\nThis script will copy all of the slices from the inputDir and copy them to the outputDir at a rate that is set by the TR. \n\n\nAfter the script has completed, the outputDir will be deleted. \n\n\nPhilips\n\u00b6\n\n\nlocation\n: \npyneal/pyneal_scanner/simulation/scannerSimulators/Philips_sim.py\n\n\nusage\n: \npython Philips_sim.py inputDir [--outputDir] [--TR]\n\n\ninput args\n:\n\n\n\n\ninputDir: path to directory containing raw slice dicom images. \n\n\n-o outputDir: path to directory where slices will be copied to [default: create new directory named \n9999\n in the parent directory of the inputDir]\n\n\n-t/--TR TR: set the TR in ms [default: 1000]\n\n\n\n\nPhilips scanners use XTC (eXTernal Control) to output reconstructed volumes to a directory during a scan. The files are written to a designated directory (e.g. XTC_Output), and within that directory, every series is assigned a new directory named sequentially starting with '0000'. For instance, volumes from the 3rd series will be stored like '.../XTC_Output/0002/'. This script will simulate the creation of a new series directory, and copy in PAR/REC files.\n\n\nYou must specify a local path to the inputDir. That is, the directory that already\ncontains a set of reconstructed PAR/REC files for a series (referred to below as \nseriesDir\n). \n\n\n[OPTIONAL]: You can specify the full path to an output directory where the PAR/REC files\nwill be copied to. If you don't specify an output directory, this tool will default\nto creating a new \nseriesDir\n, named '9999' saved in the parent directory of the \nseriesDir\n.\n\n\n\n\npython Philips_sim.py /Path/To/My/Existing/Series/0000 --outputDir /Where/I/Want/New/Slice/Data/To/appear\n\n\n\n\nif you did not specify an outputDir, new PAR/RECs would be copied to:\n\n\n/Path/To/My/Existing/Series/9999\n\n\n[OPTIONAL]: You can specify the TR at which new PAR/REC data is copied. Default is 1000ms.\n\n\n\n\npython Philips_sim.py /Path/To/My/Existing/Series/0000 --TR 2000\n\n\n\n\nSiemens\n\u00b6\n\n\nlocation\n: \npyneal/pyneal_scanner/simulation/scannerSimulators/Siemens_sim.py\n\n\nusage\n: \npython Siemens_sim.py inputDir seriesNum [--newSeriesNum] [--TR]\n\n\ninput args\n:\n\n\n\n\ninputDir: path to directory containing raw slice dicom images. \n\n\nseriesNum: series number of data that you want to simulate\n\n\n-n/--newSeriesNum: seriesNumber to assign to the new \"simulated\" data\n\n\n-t/--TR: set the TR in ms [default: 1000]\n\n\n\n\nSiemens scanners stores reconstructed slices images by taking all of the slices for a single volume, and placing them side-by-side in a larger \"mosaic\" dicom image. A scan will produce one mosaic image per volume, and all mosaic images for all scans across a single session will be stored in the same directory. This script simulates the creation of that directory, and will pass in real mosaic images.\n\n\nYou must specify a local path to the inputDir as well as the series number of the series you want to simulate.\n\n\nThe input dir should be the directory that already contains a set of reconstructed mosaic images. A single session dir will hold all of the mosaic files for all of the scans for a given session. Mosaic files are named like:\n\n\n[session#]_[series#]_[vol#].dcm\n\n\n[OPTIONAL]: You can specify the series number that will be assigned to the \"new\" mosaic images. The default behavior is to assign a series number based on the next sequential number given the existing series. In the example below, the default would be to assign a newSeriesNum as '2', but we are overriding that to assign it as '19'\n\n\n\n\npython Siemens_sim.py /Path/To/My/Existing/inputDir 1 --newSeriesNum 19\n\n\n\n\n[OPTIONAL]: You can specify the TR at which new slice data is copied. Default is 1000ms, and represents the approximate amount of time it should take to copy over all of the slices for one volume of data.\n\n\n\n\npython Siemens_sim.py /Path/To/My/Existing/inputDir 1 --TR 2000\n\n\n\n\npynealReceiver_sim.py\n\u00b6\n\n\nUse Case:\n When you want to test \nPyneal Scanner\n without having to actually run \nPyneal\n\n\n\n\nThis simulator will mimic the part of \nPyneal\n that accepts incoming 3D volumes from \nPyneal Scanner\n. This allows you to quickly test sending output with \nPyneal Scanner\n, without having to fully run \nPyneal\n (which entails a lot of extra overhead). You can (and should) run \npynealReceiver_sim.py\n from the \nScanner Computer\n. \n\n\nlocation\n: \npyneal/pyneal_scanner/simulation/pynealReceiver_sim.py\n\n\nusage\n: \npython pynealReceiver_sim.py [--port] [--nVols]\n\n\ninput args\n:\n\n\n\n\n-p/--port: port number to listen on for incoming data [default: 5556]\n\n\n-n/--nVols: number of 3D volumes to expect from \nPyneal Scanner\n [default: 60]\n\n\n\n\nMake sure \nPyneal Scanner\n is configured to use the same port number for \npynealSocketPort\n (see \nPyneal Scanner Setup\n)\n\n\nAfter the scan is complete and all of the data has arrived, this will save the received 4D volume as a nifti image at  \npyneal/pyneal_scanner/simulation/receivedImg.nii.gz\n\n\nPyneal Simulation Tools\n\u00b6\n\n\nThe \nPyneal\n simulation tools can be found in \npyneal/utils/simulation\n\n\n\n\npynealScanner_sim.py\n: simulate the behavior of \nPyneal Scanner\n (i.e. sends 3D vols to Pyneal) \n\n\npynealResults_sim.py\n: simulate the results server of \nPyneal\n (i.e. launches a server that stores fake results that can receive and respond to messages from the \nEnd User\n)\n\n\nendUser_sim.py\n: simulate the behavior of an \nEnd User\n (i.e. sends request to \nPyneal\n for results from a specific volume, then waits for response)\n\n\n\n\npynealScanner_sim.py\n\u00b6\n\n\nUse Case:\n When you want to test \nPyneal\n without having to actually run \nPyneal Scanner\n\n\n\n\nlocation\n: \npyneal/utils/simulation/pynealScanner_sim.py\n\n\nusage\n: \npython pynealScanner_sim.py [--filePath] [--random] [--dims] [--TR] [--sockethost] [--socketport]\n\n\ninput args\n:\n\n\n\n\n-f/--filePath: path to 4D nifti image that you want to use as the \"scan\" data\n\n\n-r/--random: flag to generate random data instead of using a pre-existing nifti image \n\n\n-d/--dims: desired dimensions of randomly generated dataset [default: 64 64 18 60] \n\n\n-t/--TR: set the TR in ms [default: 1000]\n\n\n-sh/--sockethost: IP address Pyneal host [default: 127.0.0.1]\n\n\n-sp/--socketport: port number to send 3D volumes over to Pyneal [default: 5555]\n\n\n\n\nThis tool will simulate the behavior of \nPyneal Scanner\n. During a real scan, pynealScanner will send data to pyneal over a socket connection. Each tranmission comes in 2 phases: first a json header with metadata about the volume, then the volume itself. This tool will send data in that same format, using either a pre-existing 4D nifti image, or randomly generated data.\n\n\nYou can either supply real 4D image data:\n\n\n\n\npython pynealScanner_sim.py --filePath /path/to/my/data.nii.gz\n\n\n\n\nor use the tool to generate a dataset of random values\n\n\n\n\npython pynealScanner_sim.py --random --dims 64 64 32 100 \n\n\n\n\n[OPTIONAL]: You can specify the TR at which 3D vols are sent to \nPyneal\n. Default is 1000ms.\n\n\n\n\npython pynealScanner_sim.py --filePath /path/to/my/data.nii.gz --TR 2000\n\n\n\n\n[OPTIONAL]: You can set the socketHost and socketPort used for communication with \nPyneal\n. Default host is \n127.0.0.1\n, which allows you to run this tool alongside \nPyneal\n on the same computer. Default socket port number is \n5555\n. You must make sure that \nPyneal\n is configured to be listening for incoming data on this port number (see \nPyneal Set Up\n)\n\n\npynealResults_sim.py\n\u00b6\n\n\nUse Case:\n When you want to test an \nEnd User\n without having to actually run \nPyneal\n (or anything else further upstream)\n\n\n\n\nlocation\n: \npyneal/utils/simulation/pynealResults_sim.py\n\n\nusage\n: \npython pynealResults_sim.py [--TR] [--sockethost] [--socketport]\n\n\ninput args\n:\n\n\n\n\n-t/--TR: set the TR in ms [default: 1000]\n\n\n-sh/--sockethost: IP address Pyneal host [default: 127.0.0.1]\n\n\n-sp/--socketport: port number to send 3D volumes over to Pyneal [default: 5556]\n\n\n\n\nThis tool will launch a server that listen in for requests for results from a remote \nEnd User\n (e.g. a task presentation machine). This tools behaves exactly the same way as the results server component of Pyneal, allowing you to test the \nEnd User\n behavior.\n\n\nIn this case the results that are returned are from a made up dataset generated each time the tool is called. There are 500 volumes in the generated dataset, and each volume has an associated \"Average\" result that is a random value drawn from a normal distribution (mean: 2400, stdDev: 15). Results for each volume will be available on the simulated results server at a rate set by the TR. For instance, with a 1000ms TR, it will take 500s for all of the results to appear. \n\n\nWhile this simulated results server is running, it will listen for requests from an \nEnd User\n. With each request that appears, it will check to see if the result from the requested volume has appeared yet. If it has, it will send back a message that looks something like:\n\n\n{foundResults: True, Average: #####}\n\n\nIf not, the response message will simply be:\n\n\n{foundResults: False}\n\n\nFor more information on formatting requests and interpretting responses, see \nrequesting results\n)\n\n\nendUser_sim.py\n\u00b6\n\n\nUse Case:\n When you want to test sending requests to \nPyneal\n without having to actually run a real \nEnd User\n \n\n\n\n\nlocation\n: \npyneal/utils/simulation/endUser_sim.py\n\n\nusage\n: \npython pynealResults_sim.py [volIdx]\n\n\ninput args\n:\n\n\n\n\nvolIdx: the index of the volume you'd like to request results from [default: 0000]. Note: volume indices are 0-based\n\n\n\n\nThis tool will simulate and demo how an \nEnd User\n may request results from \nPyneal\n\nduring a real-time scan.\n\n\nIn a neurofeedback context, for example, the end-user may be the software that is controlling the experimental task. In this case, anytime the task wants to present feedback to the participant, it must request the output of the real-time analysis for a specific set of timepoints (or volumes).\n\n\nThis is an example of how requests should be formatted and sent to \nPyneal\n. Requests are made on a per-volume basis, and each request should take the form of a 4-character string representing the desired volume index (using a 0-based index). For example, to request the first volume in the series, the string would be '0000'; to request the 25th volume in the series the string would be '0024', and so on...\n\n\nFor more information on formatting requests and interpretting responses, see \nrequesting results\n and \nparsing responses",
            "title": "Simulations"
        },
        {
            "location": "/simulations/#simulations",
            "text": "",
            "title": "Simulations"
        },
        {
            "location": "/simulations/#overview",
            "text": "In order to help with the initial setup, as well as test any analysis scripts and network communications later on,  Pyneal  includes a suite of simulation tools that mimic various inputs and outputs along the data flow path.  These tools allow you to simulate  Pyneal  (or  Pyneal Scanner ) in a modular fashion without having to run the entire pipeline. If you are troubleshooting issues, these tools are immensely helpful.    Here is a diagram highlighting the various simulation tools, and where they enter the data flow pipeline.    During an actual real-time scan, data will flow through this diagram from left to right along the blue arrows.   Simulation tools are indicated using dashed or dotted vertical lines.    A dashed line indicates a simulation tool that  generates input . In other words, these tools mimic real data as it exists at a particular stage of the pipeline    A dotted line indicates a simulation tool that  receives output . In other words, these tools allow you to simulate the  next  stage of the pipeline    Both  Pyneal Scanner  and  Pyneal  have their own set of simulation tools.     Pyneal Scanner  simulation tools can be found in  pyneal/pyneal_scanner/simulation  and are shown in light blue  below  the real data pipeline in the schematic. See below for more details    Pyneal  simulation tools can be found in  pyneal/utils/simulation  and are shown in green  above  the real data pipeline in the schematic. See below for more details",
            "title": "Overview"
        },
        {
            "location": "/simulations/#pyneal-scanner-simulation-tools",
            "text": "The  Pyneal Scanner  simulation tools can be found in  pyneal/pyneal_scanner/simulation   Scanner Simulators : Set of simulation scripts to mimic the behavior of real scanners with real data.   pynealReceiver_sim.py : simulates the behavior of  Pyneal  (i.e. accepts incoming 3D volumes from  Pyneal Scanner )",
            "title": "Pyneal Scanner Simulation Tools"
        },
        {
            "location": "/simulations/#scanner-simulators",
            "text": "Use Case:  Testing  Pyneal Scanner  (and  anything else  downstream) with real data.   This will simulate the appearance of raw data coming off of the scanner. This works by pointing the simulator to a folder containing real scanner data. The simulator will copy the real data to a new directory in a way that mimics the behavior of a real scan, allowing you to test  Pyneal Scanner  and anything else downstream.   The format of the raw data will vary according to different scanner environments/manufacturers. Accordingly, there are multiple scripts that will simulate different scanner formats:",
            "title": "Scanner Simulators"
        },
        {
            "location": "/simulations/#ge",
            "text": "location :  pyneal/pyneal_scanner/simulation/scannerSimulators/GE_sim.py  usage :  python GE_sim.py inputDir [--outputDir] [--TR]  input args :     inputDir: path to directory containing raw slice dicom images.   -o outputDir: path to directory where slices will be copied to [default: create new directory named  s9999  in the parent directory of the inputDir]  -t/--TR TR: set the TR in ms [default: 1000]   In order to run this script, you must have a local directory that contains raw slice dicom files from an actual scan. If you want to fully mimic the data directory structure of GE scanners, you can create a local directory path that follows the pattern  [baseDir]/p##/e##/s##  where the slice images are stored in a directory named like  s### , which is nested two levels deep ( p###/e### ) from the  [basedir] .   This script will copy all of the slices from the inputDir and copy them to the outputDir at a rate that is set by the TR.   After the script has completed, the outputDir will be deleted.",
            "title": "GE"
        },
        {
            "location": "/simulations/#philips",
            "text": "location :  pyneal/pyneal_scanner/simulation/scannerSimulators/Philips_sim.py  usage :  python Philips_sim.py inputDir [--outputDir] [--TR]  input args :   inputDir: path to directory containing raw slice dicom images.   -o outputDir: path to directory where slices will be copied to [default: create new directory named  9999  in the parent directory of the inputDir]  -t/--TR TR: set the TR in ms [default: 1000]   Philips scanners use XTC (eXTernal Control) to output reconstructed volumes to a directory during a scan. The files are written to a designated directory (e.g. XTC_Output), and within that directory, every series is assigned a new directory named sequentially starting with '0000'. For instance, volumes from the 3rd series will be stored like '.../XTC_Output/0002/'. This script will simulate the creation of a new series directory, and copy in PAR/REC files.  You must specify a local path to the inputDir. That is, the directory that already\ncontains a set of reconstructed PAR/REC files for a series (referred to below as  seriesDir ).   [OPTIONAL]: You can specify the full path to an output directory where the PAR/REC files\nwill be copied to. If you don't specify an output directory, this tool will default\nto creating a new  seriesDir , named '9999' saved in the parent directory of the  seriesDir .   python Philips_sim.py /Path/To/My/Existing/Series/0000 --outputDir /Where/I/Want/New/Slice/Data/To/appear   if you did not specify an outputDir, new PAR/RECs would be copied to:  /Path/To/My/Existing/Series/9999  [OPTIONAL]: You can specify the TR at which new PAR/REC data is copied. Default is 1000ms.   python Philips_sim.py /Path/To/My/Existing/Series/0000 --TR 2000",
            "title": "Philips"
        },
        {
            "location": "/simulations/#siemens",
            "text": "location :  pyneal/pyneal_scanner/simulation/scannerSimulators/Siemens_sim.py  usage :  python Siemens_sim.py inputDir seriesNum [--newSeriesNum] [--TR]  input args :   inputDir: path to directory containing raw slice dicom images.   seriesNum: series number of data that you want to simulate  -n/--newSeriesNum: seriesNumber to assign to the new \"simulated\" data  -t/--TR: set the TR in ms [default: 1000]   Siemens scanners stores reconstructed slices images by taking all of the slices for a single volume, and placing them side-by-side in a larger \"mosaic\" dicom image. A scan will produce one mosaic image per volume, and all mosaic images for all scans across a single session will be stored in the same directory. This script simulates the creation of that directory, and will pass in real mosaic images.  You must specify a local path to the inputDir as well as the series number of the series you want to simulate.  The input dir should be the directory that already contains a set of reconstructed mosaic images. A single session dir will hold all of the mosaic files for all of the scans for a given session. Mosaic files are named like:  [session#]_[series#]_[vol#].dcm  [OPTIONAL]: You can specify the series number that will be assigned to the \"new\" mosaic images. The default behavior is to assign a series number based on the next sequential number given the existing series. In the example below, the default would be to assign a newSeriesNum as '2', but we are overriding that to assign it as '19'   python Siemens_sim.py /Path/To/My/Existing/inputDir 1 --newSeriesNum 19   [OPTIONAL]: You can specify the TR at which new slice data is copied. Default is 1000ms, and represents the approximate amount of time it should take to copy over all of the slices for one volume of data.   python Siemens_sim.py /Path/To/My/Existing/inputDir 1 --TR 2000",
            "title": "Siemens"
        },
        {
            "location": "/simulations/#pynealreceiver_simpy",
            "text": "Use Case:  When you want to test  Pyneal Scanner  without having to actually run  Pyneal   This simulator will mimic the part of  Pyneal  that accepts incoming 3D volumes from  Pyneal Scanner . This allows you to quickly test sending output with  Pyneal Scanner , without having to fully run  Pyneal  (which entails a lot of extra overhead). You can (and should) run  pynealReceiver_sim.py  from the  Scanner Computer .   location :  pyneal/pyneal_scanner/simulation/pynealReceiver_sim.py  usage :  python pynealReceiver_sim.py [--port] [--nVols]  input args :   -p/--port: port number to listen on for incoming data [default: 5556]  -n/--nVols: number of 3D volumes to expect from  Pyneal Scanner  [default: 60]   Make sure  Pyneal Scanner  is configured to use the same port number for  pynealSocketPort  (see  Pyneal Scanner Setup )  After the scan is complete and all of the data has arrived, this will save the received 4D volume as a nifti image at   pyneal/pyneal_scanner/simulation/receivedImg.nii.gz",
            "title": "pynealReceiver_sim.py"
        },
        {
            "location": "/simulations/#pyneal-simulation-tools",
            "text": "The  Pyneal  simulation tools can be found in  pyneal/utils/simulation   pynealScanner_sim.py : simulate the behavior of  Pyneal Scanner  (i.e. sends 3D vols to Pyneal)   pynealResults_sim.py : simulate the results server of  Pyneal  (i.e. launches a server that stores fake results that can receive and respond to messages from the  End User )  endUser_sim.py : simulate the behavior of an  End User  (i.e. sends request to  Pyneal  for results from a specific volume, then waits for response)",
            "title": "Pyneal Simulation Tools"
        },
        {
            "location": "/simulations/#pynealscanner_simpy",
            "text": "Use Case:  When you want to test  Pyneal  without having to actually run  Pyneal Scanner   location :  pyneal/utils/simulation/pynealScanner_sim.py  usage :  python pynealScanner_sim.py [--filePath] [--random] [--dims] [--TR] [--sockethost] [--socketport]  input args :   -f/--filePath: path to 4D nifti image that you want to use as the \"scan\" data  -r/--random: flag to generate random data instead of using a pre-existing nifti image   -d/--dims: desired dimensions of randomly generated dataset [default: 64 64 18 60]   -t/--TR: set the TR in ms [default: 1000]  -sh/--sockethost: IP address Pyneal host [default: 127.0.0.1]  -sp/--socketport: port number to send 3D volumes over to Pyneal [default: 5555]   This tool will simulate the behavior of  Pyneal Scanner . During a real scan, pynealScanner will send data to pyneal over a socket connection. Each tranmission comes in 2 phases: first a json header with metadata about the volume, then the volume itself. This tool will send data in that same format, using either a pre-existing 4D nifti image, or randomly generated data.  You can either supply real 4D image data:   python pynealScanner_sim.py --filePath /path/to/my/data.nii.gz   or use the tool to generate a dataset of random values   python pynealScanner_sim.py --random --dims 64 64 32 100    [OPTIONAL]: You can specify the TR at which 3D vols are sent to  Pyneal . Default is 1000ms.   python pynealScanner_sim.py --filePath /path/to/my/data.nii.gz --TR 2000   [OPTIONAL]: You can set the socketHost and socketPort used for communication with  Pyneal . Default host is  127.0.0.1 , which allows you to run this tool alongside  Pyneal  on the same computer. Default socket port number is  5555 . You must make sure that  Pyneal  is configured to be listening for incoming data on this port number (see  Pyneal Set Up )",
            "title": "pynealScanner_sim.py"
        },
        {
            "location": "/simulations/#pynealresults_simpy",
            "text": "Use Case:  When you want to test an  End User  without having to actually run  Pyneal  (or anything else further upstream)   location :  pyneal/utils/simulation/pynealResults_sim.py  usage :  python pynealResults_sim.py [--TR] [--sockethost] [--socketport]  input args :   -t/--TR: set the TR in ms [default: 1000]  -sh/--sockethost: IP address Pyneal host [default: 127.0.0.1]  -sp/--socketport: port number to send 3D volumes over to Pyneal [default: 5556]   This tool will launch a server that listen in for requests for results from a remote  End User  (e.g. a task presentation machine). This tools behaves exactly the same way as the results server component of Pyneal, allowing you to test the  End User  behavior.  In this case the results that are returned are from a made up dataset generated each time the tool is called. There are 500 volumes in the generated dataset, and each volume has an associated \"Average\" result that is a random value drawn from a normal distribution (mean: 2400, stdDev: 15). Results for each volume will be available on the simulated results server at a rate set by the TR. For instance, with a 1000ms TR, it will take 500s for all of the results to appear.   While this simulated results server is running, it will listen for requests from an  End User . With each request that appears, it will check to see if the result from the requested volume has appeared yet. If it has, it will send back a message that looks something like:  {foundResults: True, Average: #####}  If not, the response message will simply be:  {foundResults: False}  For more information on formatting requests and interpretting responses, see  requesting results )",
            "title": "pynealResults_sim.py"
        },
        {
            "location": "/simulations/#enduser_simpy",
            "text": "Use Case:  When you want to test sending requests to  Pyneal  without having to actually run a real  End User     location :  pyneal/utils/simulation/endUser_sim.py  usage :  python pynealResults_sim.py [volIdx]  input args :   volIdx: the index of the volume you'd like to request results from [default: 0000]. Note: volume indices are 0-based   This tool will simulate and demo how an  End User  may request results from  Pyneal \nduring a real-time scan.  In a neurofeedback context, for example, the end-user may be the software that is controlling the experimental task. In this case, anytime the task wants to present feedback to the participant, it must request the output of the real-time analysis for a specific set of timepoints (or volumes).  This is an example of how requests should be formatted and sent to  Pyneal . Requests are made on a per-volume basis, and each request should take the form of a 4-character string representing the desired volume index (using a 0-based index). For example, to request the first volume in the series, the string would be '0000'; to request the 25th volume in the series the string would be '0024', and so on...  For more information on formatting requests and interpretting responses, see  requesting results  and  parsing responses",
            "title": "endUser_sim.py"
        },
        {
            "location": "/createMask/",
            "text": "Creating Masks\n\u00b6\n\n\nPyneal\n requires that you input a mask for use during real-time analysis. This mask must have the same voxel dimensions and image orientation as the incoming functional data.\n\n\nDepending on your real-time analysis needs, one option could be to create a functional ROI by collecting a localizer task run and quickly analyzing it during your scanning session. \n\n\nAlternatively, you may wish to focus your analysis on predefined anatomical ROIs. In this case, you need to transform an anatomical mask from a standard space (like MNI) to match the functional data of your participant in the scanner.  \n\n\nThe \ncreateMask.py\n tool will assist you in quickly creating whole-brain or anatomical masks during a real-time session. \n\n\ncreateMask\n provides you with two mask creation options:\n\n\n\n\n\n\nWhole Brain Mask\n: This option will create a whole brain mask from the functional data you supply. \n\n\n\n\n\n\nTransform mask from MNI space\n: This option will take a mask defined in MNI space and transform it to the dimensions and orientation of the functional data you supply.\n\n\n\n\n\n\nNote:\n Behind the scenes, createMask.py relies on various functions from FSL. Make sure you have installed \nFSL 5.0\n\n\nLaunching createMask\n\u00b6\n\n\nThe createMask tool is found in \npyneal/utils/createMask.py\n\n\nYou can launch the createMask GUI by navigating to the \nutils\n directory via the terminal and running \ncreateMask.py\n with Python\n\n\n\n\ncd utils\n\npython createMask.py\n\n\n\n\n\n\nSpecifying a reference 4D functional file\n\u00b6\n\n\nIn order to create masks, we need to know the voxel size, 3D volume dimensions, and image orientation of the functional data for the current session. The easiest way to get this data is to include a brief (30sec or less) functional scan near the beginning of your session. Use the exact same slice prescriptions and image settings as you plan to use during your real-time scans. \n\n\nAfter the scan has finished, use the \ngetSeries.py\n tool from \nPyneal Scanner\n to convert the images to a 4D nifti file. Note that \ngetSeries.py\n will automatically reorient the output data to RAS+ orientation. Thus, by using this data as our reference functional data we will create a mask that is also in RAS+. This is good since, during a real-time run, \nPyneal\n will be receiving data in RAS+ orientation (see \nimage orientation\n for more info) \n\n\ncreateMask.py\n will create an example 3D functional image for reference by taking the mean across time of the specified 4D functional. \n\n\nDeciding on a mask type\n\u00b6\n\n\nWhole Brain Mask\n\u00b6\n\n\nIf you check \nCreate whole-brain FUNC mask\n, a 3D whole-brain mask will be created using the 4D FUNC file as a reference. Every brain voxel will be labeled \n1\n and every non-brain voxel will be labeled \n0\n.\n\n\nThe output file will be found in \nmask_transforms/FUNC_masks/wholeBrain_FUNC_mask.nii.gz\n\n\nA whole-brain mask is useful in situations where you are using a custom analysis during real-time runs and want access to the entire 3D brain volume (e.g. calculating grand volume mean as a reference value for other steps in your analysis). \n\n\nTransform MNI space mask\n\u00b6\n\n\nMore commonly, your real-time analysis may focus on activation in one or more predefined regions of interest (ROIs). Before beginning your real-time run, you need to create a mask(s) of your desired ROI(s) that match the resolution and orientation of the participant's functional data. \n\n\ncreateMask.py\n offers a way to quickly transform a mask from MNI space to the required functional space. To do so, the following intermediate steps take place:\n\n\n\n\na transformation matrix is created mapping from MNI space to the participant's high-res anatomical image (\nmni2hires.mat\n)\n\n\na transformation matrix is created mapping from the participant's high-resolution anatomical image to the participant's functional data (\nhires2func.mat\n)  \n\n\na 3rd tranformation matrix is created by concatenating the previous two matrices in order to create a transformation mapping from MNI space to functional space (\nmni2func.mat\n) \n\n\n\n\nThe resulting \nmni2func.mat\n matrix is used to transform the specifed MNI-space mask to functional space. \n\n\nSpecify the following input to \ncreateMask.py\n when selecting \nTransform MNI mask to FUNC\n:\n\n\n\n\nhi-res ANAT\n: path to participant's high-resolution anatomical image, collected during the current scanning session\n\n\nif the anatomical image has not been skull stripped yet, check \nSkull Strip?\n. If you have already manually skull stripped the anatomical image, make sure this box is deselected. \n\n\n\n\n\n\nMNI-standard\n: path to the MNI standard. This standard must be in the same space as the mask you wish to transform. For instance, if your mask is in MNI space with a resolution of 1mm, you must select the MNI152_T1_1mm standard image. Sample MNI standard images can be found in \npyneal/utils/MNI_templates\n\n\nMNI mask\n: The mask file you wish to transform\n\n\nOutput Prefix:\n: The output prefix that will be prepended to the transformed masks. \n\n\n\n\nOnce you hit \nSubmit\n, \ncreateMask.py\n will go about creating the necessary intermediate tranforms. Once complete, the new masks will open automatically in FSLeyes so that you may confirm that everything completed correctly. \n\n\n\n\nThe new masks (and intermedate files) will be saved to the output directory. \n\n\nOutput files\n\u00b6\n\n\nThe output from \ncreateMask.py\n will be saved to the same directory as the specified reference 4D file. Within that directory, you will find a new directory named \nmask_transforms\n that holds all of the output mask files and transformation matrices from \ncreateMask.py\n\n\nDepending on the type of mask you are creating, you will find some set of the following files:\n\n\n\n\nFUNC_masks/wholeBrain_FUNC_mask.nii.gz\n: whole brain mask in participant functional space\n\n\nFUNC_masks/<outputPrefix>_FUNC_mask.nii.gz\n: binarized version of the transformed MNI mask in participant functional space\n\n\nFUNC_masks/<outputPrefix>_FUNC_weighted.nii.gz\n: non-binarized version of the transformed MNI mask in participant functional space. If the MNI mask you used represents a probabilistic atlas, for instance, those voxel probabilities will be preserved in this file. \n\n\nexampleFunc.nii.gz\n: a 3D functional image created by averaging the input 4D FUNC file\n\n\nhires_brain.nii.gz\n: skull-stripped version of the input hi-res ANAT file\n\n\nhires_FUNC.nii.gz\n: hi-res anatomical image transformed to participant functional space\n\n\nmni_HIRES.nii.gz\n: MNI standard transformed to participant hi-res anatomical space\n\n\nhires2func.mat\n: transformation matrix mapping from hi-res anatomical space to participant functional space\n\n\nmni2hires.mat\n: transformation matrix mapping from MNI space to hi-res anatomical space\n\n\nmni2func.mat\n: transformation matrix mapping from MNI space to participant functional space\n\n\nmaskTransforms.log\n: log file detailing all of the steps that were carried out",
            "title": "Creating Masks"
        },
        {
            "location": "/createMask/#creating-masks",
            "text": "Pyneal  requires that you input a mask for use during real-time analysis. This mask must have the same voxel dimensions and image orientation as the incoming functional data.  Depending on your real-time analysis needs, one option could be to create a functional ROI by collecting a localizer task run and quickly analyzing it during your scanning session.   Alternatively, you may wish to focus your analysis on predefined anatomical ROIs. In this case, you need to transform an anatomical mask from a standard space (like MNI) to match the functional data of your participant in the scanner.    The  createMask.py  tool will assist you in quickly creating whole-brain or anatomical masks during a real-time session.   createMask  provides you with two mask creation options:    Whole Brain Mask : This option will create a whole brain mask from the functional data you supply.     Transform mask from MNI space : This option will take a mask defined in MNI space and transform it to the dimensions and orientation of the functional data you supply.    Note:  Behind the scenes, createMask.py relies on various functions from FSL. Make sure you have installed  FSL 5.0",
            "title": "Creating Masks"
        },
        {
            "location": "/createMask/#launching-createmask",
            "text": "The createMask tool is found in  pyneal/utils/createMask.py  You can launch the createMask GUI by navigating to the  utils  directory via the terminal and running  createMask.py  with Python   cd utils \npython createMask.py",
            "title": "Launching createMask"
        },
        {
            "location": "/createMask/#specifying-a-reference-4d-functional-file",
            "text": "In order to create masks, we need to know the voxel size, 3D volume dimensions, and image orientation of the functional data for the current session. The easiest way to get this data is to include a brief (30sec or less) functional scan near the beginning of your session. Use the exact same slice prescriptions and image settings as you plan to use during your real-time scans.   After the scan has finished, use the  getSeries.py  tool from  Pyneal Scanner  to convert the images to a 4D nifti file. Note that  getSeries.py  will automatically reorient the output data to RAS+ orientation. Thus, by using this data as our reference functional data we will create a mask that is also in RAS+. This is good since, during a real-time run,  Pyneal  will be receiving data in RAS+ orientation (see  image orientation  for more info)   createMask.py  will create an example 3D functional image for reference by taking the mean across time of the specified 4D functional.",
            "title": "Specifying a reference 4D functional file"
        },
        {
            "location": "/createMask/#deciding-on-a-mask-type",
            "text": "",
            "title": "Deciding on a mask type"
        },
        {
            "location": "/createMask/#whole-brain-mask",
            "text": "If you check  Create whole-brain FUNC mask , a 3D whole-brain mask will be created using the 4D FUNC file as a reference. Every brain voxel will be labeled  1  and every non-brain voxel will be labeled  0 .  The output file will be found in  mask_transforms/FUNC_masks/wholeBrain_FUNC_mask.nii.gz  A whole-brain mask is useful in situations where you are using a custom analysis during real-time runs and want access to the entire 3D brain volume (e.g. calculating grand volume mean as a reference value for other steps in your analysis).",
            "title": "Whole Brain Mask"
        },
        {
            "location": "/createMask/#transform-mni-space-mask",
            "text": "More commonly, your real-time analysis may focus on activation in one or more predefined regions of interest (ROIs). Before beginning your real-time run, you need to create a mask(s) of your desired ROI(s) that match the resolution and orientation of the participant's functional data.   createMask.py  offers a way to quickly transform a mask from MNI space to the required functional space. To do so, the following intermediate steps take place:   a transformation matrix is created mapping from MNI space to the participant's high-res anatomical image ( mni2hires.mat )  a transformation matrix is created mapping from the participant's high-resolution anatomical image to the participant's functional data ( hires2func.mat )    a 3rd tranformation matrix is created by concatenating the previous two matrices in order to create a transformation mapping from MNI space to functional space ( mni2func.mat )    The resulting  mni2func.mat  matrix is used to transform the specifed MNI-space mask to functional space.   Specify the following input to  createMask.py  when selecting  Transform MNI mask to FUNC :   hi-res ANAT : path to participant's high-resolution anatomical image, collected during the current scanning session  if the anatomical image has not been skull stripped yet, check  Skull Strip? . If you have already manually skull stripped the anatomical image, make sure this box is deselected.     MNI-standard : path to the MNI standard. This standard must be in the same space as the mask you wish to transform. For instance, if your mask is in MNI space with a resolution of 1mm, you must select the MNI152_T1_1mm standard image. Sample MNI standard images can be found in  pyneal/utils/MNI_templates  MNI mask : The mask file you wish to transform  Output Prefix: : The output prefix that will be prepended to the transformed masks.    Once you hit  Submit ,  createMask.py  will go about creating the necessary intermediate tranforms. Once complete, the new masks will open automatically in FSLeyes so that you may confirm that everything completed correctly.    The new masks (and intermedate files) will be saved to the output directory.",
            "title": "Transform MNI space mask"
        },
        {
            "location": "/createMask/#output-files",
            "text": "The output from  createMask.py  will be saved to the same directory as the specified reference 4D file. Within that directory, you will find a new directory named  mask_transforms  that holds all of the output mask files and transformation matrices from  createMask.py  Depending on the type of mask you are creating, you will find some set of the following files:   FUNC_masks/wholeBrain_FUNC_mask.nii.gz : whole brain mask in participant functional space  FUNC_masks/<outputPrefix>_FUNC_mask.nii.gz : binarized version of the transformed MNI mask in participant functional space  FUNC_masks/<outputPrefix>_FUNC_weighted.nii.gz : non-binarized version of the transformed MNI mask in participant functional space. If the MNI mask you used represents a probabilistic atlas, for instance, those voxel probabilities will be preserved in this file.   exampleFunc.nii.gz : a 3D functional image created by averaging the input 4D FUNC file  hires_brain.nii.gz : skull-stripped version of the input hi-res ANAT file  hires_FUNC.nii.gz : hi-res anatomical image transformed to participant functional space  mni_HIRES.nii.gz : MNI standard transformed to participant hi-res anatomical space  hires2func.mat : transformation matrix mapping from hi-res anatomical space to participant functional space  mni2hires.mat : transformation matrix mapping from MNI space to hi-res anatomical space  mni2func.mat : transformation matrix mapping from MNI space to participant functional space  maskTransforms.log : log file detailing all of the steps that were carried out",
            "title": "Output files"
        },
        {
            "location": "/customAnalysis/",
            "text": "Customized Analyses\n\u00b6\n\n\nOne of \nPyneal's\n most powerful features is its ability to run customized analyses during a real-time scan. This means you can design your own analyses to fit your unique experimental needs, and \nPyneal\n will execute those analyses on every new timepoint and store the results. \n\n\nTo take advantage of this feature, you write a custom analysis script (in \npython\n), and select the \nCustom\n button in the Analysis pane of the GUI:\n\n\n\n\nCustom Analysis Script\n\u00b6\n\n\nWhile custom analyses offer a lot of flexibility, there are a couple of important constraints that need to be included in the script to ensure it can be integrated into the typical \nPyneal\n data flow. \n\n\nThe best way to ensure these constraints are met is to base your script off of the template file included with \nPyneal\n. You can find this template in \n\n\npyneal/utils/customAnalyses/customAnalysisTemplate.py\n\n\nOr, you can simply copy the text here:\n\n\nimport sys\nimport os\nfrom os.path import join\nimport logging\n\nimport numpy as np\nimport nibabel as nib\n\n\nclass CustomAnalysis:\n    \"\"\" Custom Analysis Module\n\n    This class contains all of the methods needed for setting up and executing\n    customized analyses in Pyneal during a real-time scan\n\n    \"\"\"\n    def __init__(self, maskFile, weightMask, numTimepts):\n        \"\"\" Initialize the class\n\n        Everything in the `__init__` method will be executed BEFORE the scan\n        begins. This is a place to run any necessary setup code.\n\n        The `__init__` method provides a number of inputs from the setup GUI\n        that can be used to help set up a customized analyses. You are free to\n        use or ignore these inputs as needed.\n\n        Parameters\n        ----------\n        maskFile : string\n            full path to the mask file specified in the Pyneal setup GUI\n        weightMask : boolean\n            flag indicating whether the \"weight mask?\" option in setup GUI was\n            checked.\n        numTimepts : int\n            number of timepts in the run, as specified in the setup GUI\n\n        \"\"\"\n        # Load masks and weights, and create an within-class reference to\n        # each for use in later methods.\n        mask_img = nib.load(maskFile)\n        if weightMask is True:\n            self.weights = mask_img.get_data().copy()\n        self.mask = mask_img.get_data() > 0  # 3D boolean array of mask voxels\n\n        # within-class reference to numTimepts for use in later methods\n        self.numTimepts = numTimepts\n\n        # Add the directory that this script lives in to the path. This way it\n        # is easy to load any additional files you want to put in the same\n        # directory as your custom analysis script\n        self.customAnalysisDir = os.path.abspath(os.path.dirname(__file__))\n        sys.path.append(self.customAnalysisDir)\n\n        # Import the logger. If desired, you can write log messages to the\n        # Pyneal log file using:\n        # self.logger.info('my log message') - log file and stdOut\n        # self.logger.debug('my log message') - log file only\n        self.logger = logging.getLogger('PynealLog')\n\n        ########################################################################\n        ############# vvv INSERT USER-SPECIFIED CODE BELOW vvv #################\n        self.myResult = 1\n\n\n        ############# ^^^ END USER-SPECIFIED CODE ^^^ ##########################\n        ########################################################################\n\n    def compute(self, volume, volIdx):\n        \"\"\" Compute method\n\n        This method will be executed on EACH new 3D volume that arrives\n        DURING the real-time scan. Results must be returned in a dictionary. No\n        restrictions on dict key names or values, but note that the volume\n        index will get added automatically by Pyneal before the result gets\n        placed on the results server, so no need to specify that here\n\n        Parameters\n        ----------\n        volume : nibabel-like image\n            nibabel-like image containing a 3D array of voxel data, a (4,4)\n            affine matrix mapping the volume to RAS+ space, and image metadata\n        volIdx : int\n            0-based index indicating where, in time (4th dimension), the volume\n            belongs\n\n        Returns\n        -------\n        dict\n            dictionary containing key:value pair(s) for the results for the\n            current volume\n\n        \"\"\"\n        ########################################################################\n        ############# vvv INSERT USER-SPECIFIED CODE BELOW vvv #################\n        self.myResult += 1\n\n\n        ############# ^^^ END USER-SPECIFIED CODE ^^^ ##########################\n        ########################################################################\n\n        return {'result': self.myResult}\n\n\n\n\nThe script class consists of a single class (\nCustomAnalysis\n) with two methods: \n__init__\n and \ncompute\n. You are welcome to include any additional methods that are useful, just make sure these two methods exist. See below for details on what each method does and how to customize them. \n\n\n__init__\n (initialize)\n\u00b6\n\n\nThe \n__init__\n method is called as soon as you hit \nsubmit\n on the setup GUI. In other words, the code in this method runs \nbefore\n the scan begins. Thus, the \n__init__\n method is where you will specify any set up code that needs to be initialized before the scan begins (e.g. loading multiple mask files).\n\n\nLet's take a look at the code in more detail:\n\n\ndef __init__(self, maskFile, weightMask, numTimepts):\n    \"\"\" Initialize the class\n\n    Everything in the `__init__` method will be executed BEFORE the scan\n    begins. This is a place to run any necessary setup code.\n\n    The `__init__` method provides a number of inputs from the setup GUI\n    that can be used to help set up a customized analyses. You are free to\n    use or ignore these inputs as needed.\n\n    Parameters\n    ----------\n    maskFile : string\n        full path to the mask file specified in the Pyneal setup GUI\n    weightMask : boolean\n        flag indicating whether the \"weight mask?\" option in setup GUI was\n        checked.\n    numTimepts : int\n        number of timepts in the run, as specified in the setup GUI\n\n    \"\"\"\n    # Load masks and weights, and create an within-class reference to\n    # each for use in later methods.\n    mask_img = nib.load(maskFile)\n    if weightMask is True:\n        self.weights = mask_img.get_data().copy()\n    self.mask = mask_img.get_data() > 0  # 3D boolean array of mask voxels\n\n    # within-class reference to numTimepts for use in later methods\n    self.numTimepts = numTimepts\n\n    # Add the directory that this script lives in to the path. This way it\n    # is easy to load any additional files you want to put in the same\n    # directory as your custom analysis script\n    self.customAnalysisDir = os.path.abspath(os.path.dirname(__file__))\n    sys.path.append(self.customAnalysisDir)\n\n    # Import the logger. If desired, you can write log messages to the\n    # Pyneal log file using:\n    # self.logger.info('my log message') - log file and stdOut\n    # self.logger.debug('my log message') - log file only\n    self.logger = logging.getLogger('PynealLog')\n\n    ########################################################################\n    ############# vvv INSERT USER-SPECIFIED CODE BELOW vvv #################\n    self.myResult = 1\n\n\n    ############# ^^^ END USER-SPECIFIED CODE ^^^ ##########################\n    ########################################################################\n\n\n\n\nPreset variables, and creating new ones\n\u00b6\n\n\nFirst, note that certain settings from the setup GUI are passed into the custom analysis script. Namely:\n\n\n\n\nmaskFile\n: the path to the mask specified in the GUI\n\n\nweightMask\n: a True/False boolean flag indicating whether the \nweight mask?\n option was checked or not.\n\n\nnumTimepts\n: the number of timepts in the run, as specified in the GUI. \n\n\n\n\nAt the top of the \n__init__\n method, you'll see some code that reads in each of those settings, and creates local variables for each:\n\n\n# Load masks and weights, and create an within-class reference to\n# each for use in later methods.\nmask_img = nib.load(maskFile)\nif weightMask == True:\n    self.weights = mask_img.get_data().copy()\nself.mask = mask_img.get_data() > 0  # 3D boolean array of mask voxels\n\n# within-class reference to numTimepts for use in later methods\nself.numTimepts = numTimepts\n\n\n\n\nThis enables you to reference these variables in any other method by referring to \nself.mask\n, \nself.weights\n, and \nself.numTimepts\n. In fact, the same thing is true for any variable you create in the \n__init__\n method; in order to access the variable in other methods, you must prepend the variable name with \nself.\n\n\nThe \n__init__\n method also contains a couple of other useful tidbits near the top. First, we add the directory that contains your custom analysis script to the path. This way, you can easily load any additional files that are exist in that same directory. \n\n\n# Add the directory that this script lives in to the path. This way it\n# is easy to load any additional files you want to put in the same\n# directory as your custom analysis script\nself.customAnalysisDir = os.path.abspath(os.path.dirname(__file__))\nsys.path.append(self.customAnalysisDir)\n\n\n\n\nAdding log messages\n\u00b6\n\n\nIt also creates a reference to the logger, which is the tool that adds new messages to the \npynealLog.log\n output file. You can use this reference anywhere in your script to add new log messages, which will be automatically timestamped and included in the output file. You can even control the type of log message\n\n\n\n\ninfo\n messages will get written to the output file \nAND\n appear in the stdOut of the terminal\n\n\ndebug\n messages will only get written to the output file\n\n\n\n\n# Import the logger. If desired, you can write log messages to the\n# Pyneal log file using:\n# self.logger.info('my log message') - log file and stdOut\n# self.logger.debug('my log message') - log file only\nself.logger = logging.getLogger('PynealLog')\n\n\n\n\nUser-specified \n__init__\n code\n\u00b6\n\n\nFinally, at the bottom of the \n__init__\n method is space for you to include any additional code that is needed. \n\n\n########################################################################\n############# vvv INSERT USER-SPECIFIED CODE BELOW vvv #################\nself.myResult = 1\n\n\n\n############# ^^^ END USER-SPECIFIED CODE ^^^ ##########################\n########################################################################\n\n\n\n\nIn order to illustrate, in the example above we're simply creating a new variable (\nself.myResult\n) and assigning it a value of \n1\n.\n\n\ncompute\n\u00b6\n\n\nThe \ncompute\n method is what actually gets called during a scan. In fact, it gets called each time a new 3D volume appears from the scanner. Here's the code in more detail:\n\n\ndef compute(self, volume, volIdx):\n    \"\"\" Compute method\n\n    This method will be executed on EACH new 3D volume that arrives\n    DURING the real-time scan. Results must be returned in a dictionary. No\n    restrictions on dict key names or values, but note that the volume\n    index will get added automatically by Pyneal before the result gets\n    placed on the results server, so no need to specify that here\n\n    Parameters\n    ----------\n    volume : nibabel-like image\n        nibabel-like image containing a 3D array of voxel data, a (4,4)\n        affine matrix mapping the volume to RAS+ space, and image metadata\n    volIdx : int\n        0-based index indicating where, in time (4th dimension), the volume\n        belongs\n\n    Returns\n    -------\n    dict\n        dictionary containing key:value pair(s) for the results for the\n        current volume\n\n    \"\"\"\n    ########################################################################\n    ############# vvv INSERT USER-SPECIFIED CODE BELOW vvv #################\n    self.myResult += 1\n\n\n    ############# ^^^ END USER-SPECIFIED CODE ^^^ ##########################\n    ########################################################################\n\n    return {'result': self.myResult}\n\n\n\n\nNote that the \ncompute\n method passes in references to the current \nvolume\n (3D numpy array, [x,y,z]), as well as the \nvolIdx\n, an integer representing the current volume index (in 4th dimension; 0-based index). \n\n\nUser-specified \ncompute\n code\n\u00b6\n\n\nThe \ncompute\n method includes space for you to insert your own analysis code:\n\n\n########################################################################\n############# vvv INSERT USER-SPECIFIED CODE BELOW vvv #################\nself.myResult += 1\n\n\n\n\n############# ^^^ END USER-SPECIFIED CODE ^^^ ##########################\n########################################################################\n\n\n\n\n\nYou can use this area to write customized analysis code that will be executed on each volume. In the simple example above, each time a new volume arrives, the \ncompute\n method will increment the \nself.myResult\n variable (created in the \n__init__\n method) by 1.\n\n\nStoring results\n\u00b6\n\n\nThe \ncompute\n method must return a python dictionary containing the analysis result (or results) for the current volume. \n\n\nreturn {'result': self.myResult}\n\n\n\n\nThat said, you are free to customize the contents of this dictionary as needed to fit your experimental needs. For instance, if you are calculating the mean signal in multiple ROIs (and storing those value in variables named \nroi1_meanSignal\n, \nroi2_meanSignal\n, and \nroi3_meanSignal\n) your dictionary could look something like this:\n\n\n{'roi1_mean': roi1_meanSignal,\n'roi2_mean`: roi2_meanSignal,\n'roi3_mean`: roi3_meanSignal}\n\n\n\n\nPyneal\n automatically tacks on the current \nvolIdx\n as an entry to the dictionary later on, so no need to include that information here.",
            "title": "Customized Analyses"
        },
        {
            "location": "/customAnalysis/#customized-analyses",
            "text": "One of  Pyneal's  most powerful features is its ability to run customized analyses during a real-time scan. This means you can design your own analyses to fit your unique experimental needs, and  Pyneal  will execute those analyses on every new timepoint and store the results.   To take advantage of this feature, you write a custom analysis script (in  python ), and select the  Custom  button in the Analysis pane of the GUI:",
            "title": "Customized Analyses"
        },
        {
            "location": "/customAnalysis/#custom-analysis-script",
            "text": "While custom analyses offer a lot of flexibility, there are a couple of important constraints that need to be included in the script to ensure it can be integrated into the typical  Pyneal  data flow.   The best way to ensure these constraints are met is to base your script off of the template file included with  Pyneal . You can find this template in   pyneal/utils/customAnalyses/customAnalysisTemplate.py  Or, you can simply copy the text here:  import sys\nimport os\nfrom os.path import join\nimport logging\n\nimport numpy as np\nimport nibabel as nib\n\n\nclass CustomAnalysis:\n    \"\"\" Custom Analysis Module\n\n    This class contains all of the methods needed for setting up and executing\n    customized analyses in Pyneal during a real-time scan\n\n    \"\"\"\n    def __init__(self, maskFile, weightMask, numTimepts):\n        \"\"\" Initialize the class\n\n        Everything in the `__init__` method will be executed BEFORE the scan\n        begins. This is a place to run any necessary setup code.\n\n        The `__init__` method provides a number of inputs from the setup GUI\n        that can be used to help set up a customized analyses. You are free to\n        use or ignore these inputs as needed.\n\n        Parameters\n        ----------\n        maskFile : string\n            full path to the mask file specified in the Pyneal setup GUI\n        weightMask : boolean\n            flag indicating whether the \"weight mask?\" option in setup GUI was\n            checked.\n        numTimepts : int\n            number of timepts in the run, as specified in the setup GUI\n\n        \"\"\"\n        # Load masks and weights, and create an within-class reference to\n        # each for use in later methods.\n        mask_img = nib.load(maskFile)\n        if weightMask is True:\n            self.weights = mask_img.get_data().copy()\n        self.mask = mask_img.get_data() > 0  # 3D boolean array of mask voxels\n\n        # within-class reference to numTimepts for use in later methods\n        self.numTimepts = numTimepts\n\n        # Add the directory that this script lives in to the path. This way it\n        # is easy to load any additional files you want to put in the same\n        # directory as your custom analysis script\n        self.customAnalysisDir = os.path.abspath(os.path.dirname(__file__))\n        sys.path.append(self.customAnalysisDir)\n\n        # Import the logger. If desired, you can write log messages to the\n        # Pyneal log file using:\n        # self.logger.info('my log message') - log file and stdOut\n        # self.logger.debug('my log message') - log file only\n        self.logger = logging.getLogger('PynealLog')\n\n        ########################################################################\n        ############# vvv INSERT USER-SPECIFIED CODE BELOW vvv #################\n        self.myResult = 1\n\n\n        ############# ^^^ END USER-SPECIFIED CODE ^^^ ##########################\n        ########################################################################\n\n    def compute(self, volume, volIdx):\n        \"\"\" Compute method\n\n        This method will be executed on EACH new 3D volume that arrives\n        DURING the real-time scan. Results must be returned in a dictionary. No\n        restrictions on dict key names or values, but note that the volume\n        index will get added automatically by Pyneal before the result gets\n        placed on the results server, so no need to specify that here\n\n        Parameters\n        ----------\n        volume : nibabel-like image\n            nibabel-like image containing a 3D array of voxel data, a (4,4)\n            affine matrix mapping the volume to RAS+ space, and image metadata\n        volIdx : int\n            0-based index indicating where, in time (4th dimension), the volume\n            belongs\n\n        Returns\n        -------\n        dict\n            dictionary containing key:value pair(s) for the results for the\n            current volume\n\n        \"\"\"\n        ########################################################################\n        ############# vvv INSERT USER-SPECIFIED CODE BELOW vvv #################\n        self.myResult += 1\n\n\n        ############# ^^^ END USER-SPECIFIED CODE ^^^ ##########################\n        ########################################################################\n\n        return {'result': self.myResult}  The script class consists of a single class ( CustomAnalysis ) with two methods:  __init__  and  compute . You are welcome to include any additional methods that are useful, just make sure these two methods exist. See below for details on what each method does and how to customize them.",
            "title": "Custom Analysis Script"
        },
        {
            "location": "/customAnalysis/#__init__-initialize",
            "text": "The  __init__  method is called as soon as you hit  submit  on the setup GUI. In other words, the code in this method runs  before  the scan begins. Thus, the  __init__  method is where you will specify any set up code that needs to be initialized before the scan begins (e.g. loading multiple mask files).  Let's take a look at the code in more detail:  def __init__(self, maskFile, weightMask, numTimepts):\n    \"\"\" Initialize the class\n\n    Everything in the `__init__` method will be executed BEFORE the scan\n    begins. This is a place to run any necessary setup code.\n\n    The `__init__` method provides a number of inputs from the setup GUI\n    that can be used to help set up a customized analyses. You are free to\n    use or ignore these inputs as needed.\n\n    Parameters\n    ----------\n    maskFile : string\n        full path to the mask file specified in the Pyneal setup GUI\n    weightMask : boolean\n        flag indicating whether the \"weight mask?\" option in setup GUI was\n        checked.\n    numTimepts : int\n        number of timepts in the run, as specified in the setup GUI\n\n    \"\"\"\n    # Load masks and weights, and create an within-class reference to\n    # each for use in later methods.\n    mask_img = nib.load(maskFile)\n    if weightMask is True:\n        self.weights = mask_img.get_data().copy()\n    self.mask = mask_img.get_data() > 0  # 3D boolean array of mask voxels\n\n    # within-class reference to numTimepts for use in later methods\n    self.numTimepts = numTimepts\n\n    # Add the directory that this script lives in to the path. This way it\n    # is easy to load any additional files you want to put in the same\n    # directory as your custom analysis script\n    self.customAnalysisDir = os.path.abspath(os.path.dirname(__file__))\n    sys.path.append(self.customAnalysisDir)\n\n    # Import the logger. If desired, you can write log messages to the\n    # Pyneal log file using:\n    # self.logger.info('my log message') - log file and stdOut\n    # self.logger.debug('my log message') - log file only\n    self.logger = logging.getLogger('PynealLog')\n\n    ########################################################################\n    ############# vvv INSERT USER-SPECIFIED CODE BELOW vvv #################\n    self.myResult = 1\n\n\n    ############# ^^^ END USER-SPECIFIED CODE ^^^ ##########################\n    ########################################################################",
            "title": "__init__ (initialize)"
        },
        {
            "location": "/customAnalysis/#preset-variables-and-creating-new-ones",
            "text": "First, note that certain settings from the setup GUI are passed into the custom analysis script. Namely:   maskFile : the path to the mask specified in the GUI  weightMask : a True/False boolean flag indicating whether the  weight mask?  option was checked or not.  numTimepts : the number of timepts in the run, as specified in the GUI.    At the top of the  __init__  method, you'll see some code that reads in each of those settings, and creates local variables for each:  # Load masks and weights, and create an within-class reference to\n# each for use in later methods.\nmask_img = nib.load(maskFile)\nif weightMask == True:\n    self.weights = mask_img.get_data().copy()\nself.mask = mask_img.get_data() > 0  # 3D boolean array of mask voxels\n\n# within-class reference to numTimepts for use in later methods\nself.numTimepts = numTimepts  This enables you to reference these variables in any other method by referring to  self.mask ,  self.weights , and  self.numTimepts . In fact, the same thing is true for any variable you create in the  __init__  method; in order to access the variable in other methods, you must prepend the variable name with  self.  The  __init__  method also contains a couple of other useful tidbits near the top. First, we add the directory that contains your custom analysis script to the path. This way, you can easily load any additional files that are exist in that same directory.   # Add the directory that this script lives in to the path. This way it\n# is easy to load any additional files you want to put in the same\n# directory as your custom analysis script\nself.customAnalysisDir = os.path.abspath(os.path.dirname(__file__))\nsys.path.append(self.customAnalysisDir)",
            "title": "Preset variables, and creating new ones"
        },
        {
            "location": "/customAnalysis/#adding-log-messages",
            "text": "It also creates a reference to the logger, which is the tool that adds new messages to the  pynealLog.log  output file. You can use this reference anywhere in your script to add new log messages, which will be automatically timestamped and included in the output file. You can even control the type of log message   info  messages will get written to the output file  AND  appear in the stdOut of the terminal  debug  messages will only get written to the output file   # Import the logger. If desired, you can write log messages to the\n# Pyneal log file using:\n# self.logger.info('my log message') - log file and stdOut\n# self.logger.debug('my log message') - log file only\nself.logger = logging.getLogger('PynealLog')",
            "title": "Adding log messages"
        },
        {
            "location": "/customAnalysis/#user-specified-__init__-code",
            "text": "Finally, at the bottom of the  __init__  method is space for you to include any additional code that is needed.   ########################################################################\n############# vvv INSERT USER-SPECIFIED CODE BELOW vvv #################\nself.myResult = 1\n\n\n\n############# ^^^ END USER-SPECIFIED CODE ^^^ ##########################\n########################################################################  In order to illustrate, in the example above we're simply creating a new variable ( self.myResult ) and assigning it a value of  1 .",
            "title": "User-specified __init__ code"
        },
        {
            "location": "/customAnalysis/#compute",
            "text": "The  compute  method is what actually gets called during a scan. In fact, it gets called each time a new 3D volume appears from the scanner. Here's the code in more detail:  def compute(self, volume, volIdx):\n    \"\"\" Compute method\n\n    This method will be executed on EACH new 3D volume that arrives\n    DURING the real-time scan. Results must be returned in a dictionary. No\n    restrictions on dict key names or values, but note that the volume\n    index will get added automatically by Pyneal before the result gets\n    placed on the results server, so no need to specify that here\n\n    Parameters\n    ----------\n    volume : nibabel-like image\n        nibabel-like image containing a 3D array of voxel data, a (4,4)\n        affine matrix mapping the volume to RAS+ space, and image metadata\n    volIdx : int\n        0-based index indicating where, in time (4th dimension), the volume\n        belongs\n\n    Returns\n    -------\n    dict\n        dictionary containing key:value pair(s) for the results for the\n        current volume\n\n    \"\"\"\n    ########################################################################\n    ############# vvv INSERT USER-SPECIFIED CODE BELOW vvv #################\n    self.myResult += 1\n\n\n    ############# ^^^ END USER-SPECIFIED CODE ^^^ ##########################\n    ########################################################################\n\n    return {'result': self.myResult}  Note that the  compute  method passes in references to the current  volume  (3D numpy array, [x,y,z]), as well as the  volIdx , an integer representing the current volume index (in 4th dimension; 0-based index).",
            "title": "compute"
        },
        {
            "location": "/customAnalysis/#user-specified-compute-code",
            "text": "The  compute  method includes space for you to insert your own analysis code:  ########################################################################\n############# vvv INSERT USER-SPECIFIED CODE BELOW vvv #################\nself.myResult += 1\n\n\n\n\n############# ^^^ END USER-SPECIFIED CODE ^^^ ##########################\n########################################################################  You can use this area to write customized analysis code that will be executed on each volume. In the simple example above, each time a new volume arrives, the  compute  method will increment the  self.myResult  variable (created in the  __init__  method) by 1.",
            "title": "User-specified compute code"
        },
        {
            "location": "/customAnalysis/#storing-results",
            "text": "The  compute  method must return a python dictionary containing the analysis result (or results) for the current volume.   return {'result': self.myResult}  That said, you are free to customize the contents of this dictionary as needed to fit your experimental needs. For instance, if you are calculating the mean signal in multiple ROIs (and storing those value in variables named  roi1_meanSignal ,  roi2_meanSignal , and  roi3_meanSignal ) your dictionary could look something like this:  {'roi1_mean': roi1_meanSignal,\n'roi2_mean`: roi2_meanSignal,\n'roi3_mean`: roi3_meanSignal}  Pyneal  automatically tacks on the current  volIdx  as an entry to the dictionary later on, so no need to include that information here.",
            "title": "Storing results"
        },
        {
            "location": "/troubleshooting/",
            "text": "troubleshooting\n\u00b6\n\n\nInstallation\n\u00b6\n\n\nproblems installing kivy\n\u00b6\n\n\nIf you have followed the instructions under \nInstallation\n: Pyneal\n but are still having trouble getting Kivy to work, there are a couple of other options you may want to try. \n\n\nFirst off, check out \ndetailed Kivy installation instructions\n to see if there are any tips. \n\n\nSecond, you can try to manually compile Kivy following these steps\n\n\n\n\nclone the Kivy repo from github:\n\n\n\n\n\n\ngit clone https://github.com/kivy/kivy\n\n\n\n\n\n\nNavigate into the cloned \nkivy\n directory and set environmental variables:\n\n\n\n\n\n\ncd kivy\n\nexport USE_SDL2=1\n\nexport USE_GSTREAMER=1  \n\n\n\n\nIn order for this to work, make sure you have installed the SDL2 and GSTREAMER libraries for Kivy listed under \nKivy Libraries\n\n\n\n\nrun \nmake\n to compile the package\n\n\n\n\n\n\nmake\n\n\n\n\nIf this proceeded without error, test by running \nPyneal\n to see if the GUI appears:\n\n\n\n\npython pyneal.py  \n\n\n\n\nPyneal Scanner\n\u00b6\n\n\nPyneal scanner issue 1\n\u00b6\n\n\nPyneal\n\u00b6\n\n\nPyneal issue 1\n\u00b6\n\n\nCreating Masks\n\u00b6\n\n\nMy output masks are misaligned\n\u00b6\n\n\nIn addition to creating the desired masks, the \ncreateMask.py\n tool creates a number of additional output files that can be used to help diagnose issues. Within the \nmask_transforms\n directory, check the quality of the following output files for clues:\n\n\n\n\n\n\nexampleFunc.nii.gz\n - mean 3D functional image, created by collapsing the input 4D functional image over time\n\n\n\n\n\n\nhires_brain.nii.gz\n - skull stripped version of the input anatomical image. If the default skull stripping performs poorly, try to skull strip the anatomical image manually, and then re-run \ncreateMask.py\n with the newly skull stripped image (and make sure to deselect the \nskull strip?\n option within the \ncreateMask.py\n GUI). \n\n\n\n\n\n\nhires_FUNC.nii.gz\n - the hi-res anatomical transformed to functional space. Problems with this image suggest the hires2func transformation matrix failed. \n\n\n\n\n\n\nmni_HIRES.nii.z\n - the MNI standard image transformed to hi-res anatomical space. Problems with this image suggest the mni2hires tranformation matrix failed.",
            "title": "Troubleshooting"
        },
        {
            "location": "/troubleshooting/#troubleshooting",
            "text": "",
            "title": "troubleshooting"
        },
        {
            "location": "/troubleshooting/#installation",
            "text": "",
            "title": "Installation"
        },
        {
            "location": "/troubleshooting/#problems-installing-kivy",
            "text": "If you have followed the instructions under  Installation : Pyneal  but are still having trouble getting Kivy to work, there are a couple of other options you may want to try.   First off, check out  detailed Kivy installation instructions  to see if there are any tips.   Second, you can try to manually compile Kivy following these steps   clone the Kivy repo from github:    git clone https://github.com/kivy/kivy    Navigate into the cloned  kivy  directory and set environmental variables:    cd kivy \nexport USE_SDL2=1 \nexport USE_GSTREAMER=1     In order for this to work, make sure you have installed the SDL2 and GSTREAMER libraries for Kivy listed under  Kivy Libraries   run  make  to compile the package    make   If this proceeded without error, test by running  Pyneal  to see if the GUI appears:   python pyneal.py",
            "title": "problems installing kivy"
        },
        {
            "location": "/troubleshooting/#pyneal-scanner",
            "text": "",
            "title": "Pyneal Scanner"
        },
        {
            "location": "/troubleshooting/#pyneal-scanner-issue-1",
            "text": "",
            "title": "Pyneal scanner issue 1"
        },
        {
            "location": "/troubleshooting/#pyneal",
            "text": "",
            "title": "Pyneal"
        },
        {
            "location": "/troubleshooting/#pyneal-issue-1",
            "text": "",
            "title": "Pyneal issue 1"
        },
        {
            "location": "/troubleshooting/#creating-masks",
            "text": "",
            "title": "Creating Masks"
        },
        {
            "location": "/troubleshooting/#my-output-masks-are-misaligned",
            "text": "In addition to creating the desired masks, the  createMask.py  tool creates a number of additional output files that can be used to help diagnose issues. Within the  mask_transforms  directory, check the quality of the following output files for clues:    exampleFunc.nii.gz  - mean 3D functional image, created by collapsing the input 4D functional image over time    hires_brain.nii.gz  - skull stripped version of the input anatomical image. If the default skull stripping performs poorly, try to skull strip the anatomical image manually, and then re-run  createMask.py  with the newly skull stripped image (and make sure to deselect the  skull strip?  option within the  createMask.py  GUI).     hires_FUNC.nii.gz  - the hi-res anatomical transformed to functional space. Problems with this image suggest the hires2func transformation matrix failed.     mni_HIRES.nii.z  - the MNI standard image transformed to hi-res anatomical space. Problems with this image suggest the mni2hires tranformation matrix failed.",
            "title": "My output masks are misaligned"
        },
        {
            "location": "/glossary/",
            "text": "Glossary\n\u00b6\n\n\nComputers\n\u00b6\n\n\nThe documentation refers to computers by their \nfunctional\n role:\n\n\n\n\n\n\nScanner computer\n: The computer where reconstructed images from the scanner appear. In the case of GE scanners, for instance, new slice dicom files appear in a directory on the scanner console. Siemens scanners, on the other hand, may export new images to a directory on a shared network drive. The \nscanner computer\n is simply the computer that has local access to the directory where new images appear\n\n\n\n\n\n\nAnalysis computer\n: The computer that will be running \nPyneal\n. This is the computer on which users will setup their analysis, launch \nPyneal\n, and monitor on-going scans.\n\n\n\n\n\n\nNote that in some cases, the \nsame physical computer\n can play both functional roles. For instance, when working in a Siemens environment, new images from the scanner might be exported to a shared directory that is accessible on the \nanalysis computer\n. In this case, the same machine could be playing the role of both the \nscanner computer\n and the \nanalysis computer\n.\n\n\n\n\nEnd User\n: Generic term for any computer/process that is making a request to \nPyneal\n for results during a scan. For instance, a task presentation computer that is requesting specific feedback values to present to the participant. \n\n\n\n\nAdditional terms used\n\u00b6\n\n\n\n\n\n\nSeries\n: A complete scan representing either a single 3D anatomical image, or a 4D functional image.\n\n\n\n\n\n\nSession\n:  A collection of series collected within the same experimental session. A \nsession\n would typically represent all of the scans collected after the subject is placed in the scanner (e.g. Anatomical, functional series1, functional series2, etc...)",
            "title": "Glossary"
        },
        {
            "location": "/glossary/#glossary",
            "text": "",
            "title": "Glossary"
        },
        {
            "location": "/glossary/#computers",
            "text": "The documentation refers to computers by their  functional  role:    Scanner computer : The computer where reconstructed images from the scanner appear. In the case of GE scanners, for instance, new slice dicom files appear in a directory on the scanner console. Siemens scanners, on the other hand, may export new images to a directory on a shared network drive. The  scanner computer  is simply the computer that has local access to the directory where new images appear    Analysis computer : The computer that will be running  Pyneal . This is the computer on which users will setup their analysis, launch  Pyneal , and monitor on-going scans.    Note that in some cases, the  same physical computer  can play both functional roles. For instance, when working in a Siemens environment, new images from the scanner might be exported to a shared directory that is accessible on the  analysis computer . In this case, the same machine could be playing the role of both the  scanner computer  and the  analysis computer .   End User : Generic term for any computer/process that is making a request to  Pyneal  for results during a scan. For instance, a task presentation computer that is requesting specific feedback values to present to the participant.",
            "title": "Computers"
        },
        {
            "location": "/glossary/#additional-terms-used",
            "text": "Series : A complete scan representing either a single 3D anatomical image, or a 4D functional image.    Session :  A collection of series collected within the same experimental session. A  session  would typically represent all of the scans collected after the subject is placed in the scanner (e.g. Anatomical, functional series1, functional series2, etc...)",
            "title": "Additional terms used"
        },
        {
            "location": "/imageOrientation/",
            "text": "Image Orientation\n\u00b6\n\n\nPyneal uses the RAS+ convention...",
            "title": "Image Orientation"
        },
        {
            "location": "/imageOrientation/#image-orientation",
            "text": "Pyneal uses the RAS+ convention...",
            "title": "Image Orientation"
        }
    ]
}